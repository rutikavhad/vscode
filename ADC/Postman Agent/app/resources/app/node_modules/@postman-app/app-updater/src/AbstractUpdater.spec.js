const AbstractUpdater = require('./AbstractUpdater');

describe('AbstractUpdater', function () {
  let abstractUpdater;
  let globalUpdaterOptions = {
    autoUpdater: {
      on: jest.fn(),
    },
    adapter: {
      getLogger: function () {
        return {
          error: jest.fn(),
          info: jest.fn(),
          warn: jest.fn(),
          getContext: jest.fn().mockReturnValue({
            api: '@postman/app-updater',
            domain: 'starship',
          }),
        };
      },
      getCurrentVersion: jest.fn(),
      getLastKnownVersion: jest.fn(),
      setLastKnownVersion: jest.fn(),
    },
  };

  beforeEach(function () {
    abstractUpdater = new AbstractUpdater(globalUpdaterOptions);
  });

  describe('getFeedUrl', function () {
    it('should return a string', () => {
      const updateInfo = {
        platform: 'linux_64',
        version: '6.1.0',
        updateServerDomain: 'https://dl-beta.pstmn.io/',
        additionalParamsString: 'params',
      };
      const returnVal = abstractUpdater.getFeedUrl(updateInfo);

      expect(returnVal).toEqual(
        'https://dl-beta.pstmn.io/update/linux_64/6.1.0/?params'
      );
    });

    it('should throw error if the updateInfo is of type String', () => {
      let error = null;
      try {
        abstractUpdater.getFeedUrl('updateInfo');
      } catch (e) {
        error = e;
      } finally {
        expect(error).toBeInstanceOf(Error);
      }
    });

    it('should throw error if the updateInfo is of type Array', () => {
      let error = null;
      try {
        abstractUpdater.getFeedUrl([]);
      } catch (e) {
        error = e;
      } finally {
        expect(error).toBeInstanceOf(Error);
      }
    });

    it('should throw error if the updateInfo is just spaces', () => {
      let error = null;
      try {
        abstractUpdater.getFeedUrl('  ');
      } catch (e) {
        error = e;
      } finally {
        expect(error).toBeInstanceOf(Error);
      }
    });

    it('should throw error if the updateInfo.platform is not of type string', () => {
      let error = null;
      try {
        abstractUpdater.getFeedUrl({ platform: 12 });
      } catch (e) {
        error = e;
      } finally {
        expect(error).toBeInstanceOf(Error);
      }
    });
  });

  describe('assignUpdaterOptions', function () {
    it('should throw error if updaterOptions is null', () => {
      let error = null;
      try {
        abstractUpdater.assignUpdaterOptions(null);
      } catch (e) {
        error = e;
      } finally {
        expect(error).toBeInstanceOf(Error);
      }
    });

    it('should not throw an error if adapter and autoUpdater property of updaterOptions have truthy value', () => {
      let error = null;
      try {
        abstractUpdater.assignUpdaterOptions(globalUpdaterOptions);
      } catch (e) {
        error = e;
      } finally {
        expect(error).toBeNull();
      }
    });

    it('should throw an error if adapter and autoUpdater does not exist as a property of updaterOptions', () => {
      let error = null;
      try {
        abstractUpdater.assignUpdaterOptions({});
      } catch (e) {
        error = e;
      } finally {
        expect(error).toBeInstanceOf(Error);
      }
    });

    it('should throw an error if adapter is empty', () => {
      let error = null;
      try {
        abstractUpdater.assignUpdaterOptions({
          adapter: '',
          autoUpdater: 'something2',
        });
      } catch (e) {
        error = e;
      } finally {
        expect(error).toBeInstanceOf(Error);
      }
    });

    it('should throw an error if autoUpdater is empty', () => {
      let error = null;
      try {
        abstractUpdater.assignUpdaterOptions({
          adapter: 'something',
          autoUpdater: '',
        });
      } catch (e) {
        error = e;
      } finally {
        expect(error).toBeInstanceOf(Error);
      }
    });

    it('should throw an error if adapter and autoUpdater is null', () => {
      let error = null;
      try {
        abstractUpdater.assignUpdaterOptions({
          adapter: null,
          autoUpdater: null,
        });
      } catch (e) {
        error = e;
      } finally {
        expect(error).toBeInstanceOf(Error);
      }
    });
  });

  describe('validation', function () {
    it('should handle when getContext is not a function gracefully', function () {
      const abstractUpdater = new AbstractUpdater({
        autoUpdater: {
          on: jest.fn(),
        },
        adapter: {
          getLogger: function () {
            return {
              error: jest.fn(),
              info: jest.fn(),
              warn: jest.fn(),
              getContext: 'not a function',
            };
          },
          getCurrentVersion: jest.fn(),
          getLastKnownVersion: jest.fn(),
          setLastKnownVersion: jest.fn(),
        },
      });

      expect(abstractUpdater.context).toEqual({
        api: '@postman/app-updater',
        domain: 'starship',
      });
    });
  });

  describe('downloadUpdate', function () {
    it('should throw an error if updateInfo is null', () => {
      let error = null;
      try {
        abstractUpdater.downloadUpdate(null);
      } catch (e) {
        error = e;
      } finally {
        expect(error).toBeInstanceOf(Error);
      }
    });

    it('should throw an error if updateInfo.platform is empty', () => {
      let error = null;
      const updateInfo = {
        updateServerDomain: 'domain',
        platform: '',
        version: '6.2.0',
        channel: 'stage',
      };
      try {
        abstractUpdater.downloadUpdate(updateInfo);
      } catch (e) {
        error = e;
      } finally {
        expect(error).toBeInstanceOf(Error);
      }
    });

    it('should throw error if updateInfo.version is empty', () => {
      let error = null;
      const updateInfo = {
        updateServerDomain: 'domain',
        platform: 'linux_64',
        version: '',
        channel: 'stage',
      };
      try {
        AbstractUpdater.downloadUpdate(updateInfo);
      } catch (e) {
        error = e;
      } finally {
        expect(error).toBeInstanceOf(Error);
      }
    });

    it('should throw error if updateInfo.updateServerDomain is empty', () => {
      let error = null;
      const updateInfo = {
        updateServerDomain: '',
        platform: 'linux_64',
        version: '6.2.0',
        channel: 'stage',
      };
      try {
        abstractUpdater.downloadUpdate(updateInfo);
      } catch (e) {
        error = e;
      } finally {
        expect(error).toBeInstanceOf(Error);
      }
    });

    it('should throw error if updateInfo.channel is empty', () => {
      let error = null;
      const updateInfo = {
        updateServerDomain: 'domain',
        platform: 'linux_64',
        version: '6.2.0',
        channel: '',
      };
      try {
        abstractUpdater.downloadUpdate(updateInfo);
      } catch (e) {
        error = e;
      } finally {
        expect(error).toBeInstanceOf(Error);
      }
    });

    it('should throw an error if all the properties of updateInfo is empty', () => {
      let error = null;
      const updateInfo = {
        updateServerDomain: '',
        platform: '',
        version: '',
        channel: '',
      };
      try {
        abstractUpdater.downloadUpdate(updateInfo);
      } catch (e) {
        error = e;
      } finally {
        expect(error).toBeInstanceOf(Error);
      }
    });
  });

  describe('EventEmitter', function () {
    it('should invoke event emitter', function () {
      const emitterSpy = jest.spyOn(abstractUpdater, 'emit');
      let error = null;

      try {
        abstractUpdater.onCheckingForUpdate({ appName: 'PostmanStage' });
      } catch (e) {
        error = e;
      } finally {
        expect(error).toBeNull();
        expect(emitterSpy).toHaveBeenCalledTimes(1);
      }
    });
  });

  describe('onUpdateError', function () {
    let emitterStub;
    let loggerStub;

    beforeEach(function () {
      emitterStub = jest
        .spyOn(abstractUpdater, 'emit')
        .mockImplementation(() => {});
      loggerStub = jest.spyOn(abstractUpdater.logger, 'error');
    });

    afterEach(function () {
      emitterStub.mockRestore();
      loggerStub.mockRestore();
    });

    it('Should invoke error logger', function () {
      const errInstance = new Error('Error occurred while updating');

      abstractUpdater.onUpdateError(errInstance, null);

      expect(emitterStub).toHaveBeenCalledTimes(1);
      expect(emitterStub).toHaveBeenCalledWith('error', errInstance, null);
      expect(loggerStub).toHaveBeenCalledTimes(1);
      expect(loggerStub).toHaveBeenCalledWith(
        '@postman/app-updater: error',
        errInstance,
        {
          context: { api: '@postman/app-updater', domain: 'starship' },
          info: 'null',
        }
      );
    });
  });

  describe('checkForVersionUpdated', function () {
    let emitSpy;

    beforeEach(function () {
      emitSpy = jest.spyOn(abstractUpdater, 'emit');
    });

    it('should not emit version updated when lastKnownVersion is empty string', async () => {
      globalUpdaterOptions.adapter.getLastKnownVersion.mockImplementation(
        (cb) => cb(null, '')
      );
      globalUpdaterOptions.adapter.getCurrentVersion.mockReturnValue('1.0.0');

      abstractUpdater.checkForVersionUpdated();

      await new Promise((resolve) => setImmediate(resolve));
      expect(emitSpy).not.toHaveBeenCalledWith('versionUpdated');
    });

    it('should not emit version updated when lastKnownVersion equals currentVersion', async () => {
      const currentVersion = '1.0.0';

      globalUpdaterOptions.adapter.getLastKnownVersion.mockImplementation(
        (cb) => cb(null, currentVersion)
      );
      globalUpdaterOptions.adapter.getCurrentVersion.mockReturnValue(
        currentVersion
      );

      abstractUpdater.checkForVersionUpdated();

      await new Promise((resolve) => setImmediate(resolve));
      expect(emitSpy).not.toHaveBeenCalledWith('versionUpdated');
    });

    it('should emit version updated when versions differ', async () => {
      const lastKnownVersion = '1.0.0';
      const currentVersion = '2.0.0';

      globalUpdaterOptions.adapter.getLastKnownVersion.mockImplementation(
        (cb) => cb(null, lastKnownVersion)
      );
      globalUpdaterOptions.adapter.getCurrentVersion.mockReturnValue(
        currentVersion
      );

      abstractUpdater.checkForVersionUpdated();

      await new Promise((resolve) => setImmediate(resolve));
      expect(emitSpy).toHaveBeenCalledWith(
        'versionUpdated',
        lastKnownVersion,
        currentVersion
      );
      expect(
        globalUpdaterOptions.adapter.setLastKnownVersion
      ).toHaveBeenCalledWith(currentVersion);
    });

    it('should not emit when getLastKnownVersion returns error', async () => {
      globalUpdaterOptions.adapter.getLastKnownVersion.mockImplementation(
        (cb) => cb(new Error('Failed'))
      );
      globalUpdaterOptions.adapter.getCurrentVersion.mockReturnValue('1.0.0');

      abstractUpdater.checkForVersionUpdated();

      await new Promise((resolve) => setImmediate(resolve));
      expect(emitSpy).not.toHaveBeenCalledWith('versionUpdated');
      expect(
        globalUpdaterOptions.adapter.setLastKnownVersion
      ).not.toHaveBeenCalled();
    });
  });
});
