"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vitest_1 = require("vitest");
const events_1 = require("../events");
const onBeforeRequest = {
    listen: 'beforeRequest',
    script: { type: 'text/javascript', exec: '' },
};
const onInvoke = {
    listen: 'invoke',
    script: { type: 'text/javascript', exec: '' },
};
const onMessage = {
    listen: 'message',
    script: { type: 'text/javascript', exec: '' },
};
const onAfterResponse = {
    listen: 'afterResponse',
    script: {
        type: 'text/javascript',
        exec: '',
        packages: { react: { id: 'react@19.0.0' } },
    },
};
(0, vitest_1.test)('should constrain to certain event types', () => {
    const Specific = events_1.Events.constraints({
        supportedListeners: ['beforeRequest', 'afterResponse'],
    });
    (0, vitest_1.expect)(Specific.parse([onBeforeRequest, onAfterResponse])).toEqual([
        onBeforeRequest,
        onAfterResponse,
    ]);
    (0, vitest_1.expect)(Specific.validate([onBeforeRequest, onInvoke, onMessage, onAfterResponse])).toMatchInlineSnapshot(`
		{
		  "issues": [
		    {
		      "code": "invalid_value",
		      "message": "Unsupported event listener "invoke"",
		      "path": [
		        1,
		        "listen",
		      ],
		      "values": [
		        "beforeRequest",
		        "afterResponse",
		      ],
		    },
		    {
		      "code": "invalid_value",
		      "message": "Unsupported event listener "message"",
		      "path": [
		        2,
		        "listen",
		      ],
		      "values": [
		        "beforeRequest",
		        "afterResponse",
		      ],
		    },
		  ],
		}
	`);
});
//# sourceMappingURL=events.test.js.map