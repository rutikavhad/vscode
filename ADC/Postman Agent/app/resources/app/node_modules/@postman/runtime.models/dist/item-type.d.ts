import * as z from 'zod/v4-mini';
import { type Model } from './model';
export interface AnyItemType {
    type: string;
    id?: Id;
    payload: unknown;
    children?: AnyItemType[] | never;
    extensions?: unknown;
    title?: string;
    workspace?: string;
    createdAt?: string;
    updatedAt?: string;
}
export type ItemType<Type extends AnyItemType = AnyItemType> = Model<Type, ItemTypeExtensions<Type>> & z.core.$ZodObject;
export type ItemTypeExtensions<Type extends AnyItemType> = {
    type: Type['type'];
    resource: ItemTypeResource<Type>;
};
export type ItemTypeResource<Type extends AnyItemType> = Model<Omit<Type, 'id' | 'children'> & {
    id: Id;
    children?: Array<Type['children'] extends AnyItemType ? {
        type: Type['children'][number]['type'];
        id: Id;
    } | Type['children'][number] : never>;
}, {
    type: Type['type'];
}>;
export declare const Id: z.ZodMiniString<string>;
export type Id = z.infer<typeof Id>;
/**
 * Define a new item type
 *
 * @example
 * ```ts
 * const HTTPRequest = itemType({
 *   type: 'http-request',
 *   payload: z.strictObject({
 *     ...
 *   }),
 *   children: {
 *     allowed: [HTTPExample],
 *     // available: allowed, limit
 *   },
 *   extensions: {
 *     optional: {
 *       auth: Auth.constraints({ supportedAuthTypes: [...] }),
 *       documentation: Documentation,
 *       events: Events.constraints({ supportedListeners: [...] }),
 *     }
 *     // available: optional, required
 *   },
 * });
 * ```
 */
export declare function itemType<TType extends string, TPayload extends z.ZodMiniObject | z.ZodMiniDiscriminatedUnion, TOptionalExtensions extends Record<string, z.core.$ZodType<unknown, unknown>> = Record<string, never>, TRequiredExtensions extends Record<string, z.core.$ZodType<unknown, unknown>> = Record<string, never>, TChildren extends [
    ItemType | z.ZodMiniLazy<ItemType>,
    ...Array<ItemType | z.ZodMiniLazy<ItemType>>
] | never = never, TExtensions = TOptionalExtensions extends Record<string, never> ? TRequiredExtensions extends Record<string, never> ? {
    [key: string]: never;
} : {
    [Key in keyof TRequiredExtensions]: z.output<TRequiredExtensions[Key]>;
} : TRequiredExtensions extends Record<string, never> ? {
    [Key in keyof TOptionalExtensions]?: z.output<TOptionalExtensions[Key]>;
} : {
    [Key in keyof TOptionalExtensions]?: z.output<TOptionalExtensions[Key]>;
} & {
    [Key in keyof TRequiredExtensions]: z.output<TRequiredExtensions[Key]>;
}, Type extends AnyItemType = {
    type: TType;
    id?: Id;
    title?: string;
    workspace?: string;
    createdAt?: string;
    updatedAt?: string;
    payload: z.output<TPayload>;
    children?: TChildren extends never ? never : z.output<z.core.$ZodDiscriminatedUnion<TChildren>>[];
} & (TRequiredExtensions extends Record<string, never> ? {
    extensions?: TExtensions;
} : {
    extensions: TExtensions;
})>(item: {
    type: TType;
    payload: TPayload;
    children?: {
        allowed?: TChildren;
        limit?: number;
    };
    extensions?: {
        optional?: TOptionalExtensions;
        required?: TRequiredExtensions;
    };
}): ItemType<Type>;
/**
 * Assert that the given input is a valid value for the given item type's resource schema,
 * throwing an error if invalid
 */
export declare function assertResourceType<TItemType extends ItemType>(itemType: TItemType, input: unknown): asserts input is TItemType extends ItemType<infer Type> ? Type : never;
