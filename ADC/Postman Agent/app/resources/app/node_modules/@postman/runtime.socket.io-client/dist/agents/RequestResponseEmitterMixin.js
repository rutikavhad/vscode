"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = RequestResponseEmitterMixin;
const utils_1 = require("../utils");
function RequestResponseEmitterMixin(Superclass) {
    return class extends Superclass {
        createConnection(options, onCreate) {
            // @ts-ignore Ignore the error caused due to ill-defined types for agents
            const socket = super.createConnection(options, onCreate);
            const requestMetaEmit = (remotePort) => {
                const req = socket._httpMessage;
                const defaultPort = req.agent.defaultPort;
                const portStr = remotePort === defaultPort ? '' : `:${remotePort}`;
                const request = {
                    method: req.method,
                    href: `${req.agent.protocol}//${req.host}${portStr}${req.path}`,
                    headers: Object.entries(JSON.parse(JSON.stringify(req.getHeaders()))).map(([key, value]) => ({ key, value: value.toString() })),
                    httpVersion: '1.1',
                };
                this.emit('request-meta', request);
            };
            // Lookup is not emitted when the request is made to the IP address
            socket.on('lookup', () => {
                const req = socket._httpMessage;
                const remotePort = options.port || req.agent.defaultPort;
                if (!remotePort) {
                    return;
                }
                requestMetaEmit(remotePort);
            });
            const errorListener = () => {
                const remotePort = socket.remotePort;
                if (!remotePort) {
                    return;
                }
                requestMetaEmit(remotePort);
            };
            // If the socket emits an error, before then the ready event is emitted
            // We need to emit the request meta in the error event as well
            // Note: This is only "required" if the connection is being made to an IP address, since the lookup event is not
            // emitted in that case
            socket.on('error', errorListener);
            // If request meta was not fired, then the socket ready event is used to emit the request meta
            // We safeguard against multiple ready events by using the once method in the connection handler
            socket.on('ready', () => {
                socket.off('error', errorListener);
                const remotePort = socket.remotePort;
                if (!remotePort) {
                    return;
                }
                requestMetaEmit(remotePort);
            });
            socket.once('data', (chunk) => {
                const res = chunk.toString(), [_, httpVersion, statusCode, statusMessage = ''] = /^HTTP\/(\d.\d) (\d{3})( .*)?/.exec(res) || [];
                if (statusCode) {
                    const response = {
                        statusCode: parseInt(statusCode),
                        statusMessage: statusMessage.substring(1),
                        headers: (0, utils_1.parseHeaders)(res),
                        httpVersion: httpVersion,
                    };
                    this.emit('response-meta', response);
                }
            });
            return socket;
        }
    };
}
//# sourceMappingURL=RequestResponseEmitterMixin.js.map