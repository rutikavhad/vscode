# Runtime

This package provides a complete `Runtime`, allowing you to validate and execute Items (and trees of Items) for all ItemTypes supported by Postman.

See [@postman/runtime.core](../core) for more information about the `Runtime` class.

## Node.js usage

```js
import { createRuntime } from '@postman/runtime';

const runtime = createRuntime();
const run = runtime.execItem(myGrpcItem);

for await (const event of run) {
  console.log(event);
}
```

## Browser usage

In the browser, you'll need a RuntimeRPC client to connect to a Runtime server. The RuntimeRPC connection is usually over [WebSockets](../../runtime-rpc/runtime-rpc-ws) or [Electron IPC](../../runtime-rpc/runtime-rpc-electron).

```js
import { createRemoteRuntime } from '@postman/runtime';
import { Client as ElectronClient } from '@postman/runtime.runtime-rpc-electron';
import { Client as WebSocketClient } from '@postman/runtime.runtime-rpc-ws';

let client;
if (/\belectron\//i.test(navigator.userAgent)) {
  client = new ElectronClient('my-ipc-channel-name');
} else {
  client = new WebSocketClient('ws://my-websocket-server.com');
}

const runtime = createRemoteRuntime({ client });
const run = runtime.execItem(myGrpcItem);

for await (const event of run) {
  console.log(event);
}
```

## Setting up a Runtime server over WebSockets

```js
import { Server } from '@postman/runtime.runtime-rpc-ws';
import { ServerMethods } from '@postman/runtime';

const runtimeServer = new Server({ port }, ServerMethods);

runtimeServer.whenListening().then(() => {
  console.log(`listening on port ${runtimeServer.address().port}`);
});
```

## Setting up a Runtime server over Electron IPC

```js
import { Server } from '@postman/runtime.runtime-rpc-electron';
import { ServerMethods } from '@postman/runtime';

const runtimeServer = new Server('my-ipc-channel-name', ServerMethods);
```

---

(in-development approach)

# @postman/runtime

Execute Postman collections and requests in Node.js and the browser.

## Example

```js
import { Runtime } from '@postman/runtime';

const runtime = new Runtime();
const run = runtime.execute({
  type: 'collection',
  items: [
    {
      type: 'http-request',
      payload: {
        method: 'GET',
        url: 'postman-echo.com/get',
      },
    },
    {
      type: 'grpc-request',
      // ...
    },
    {
      type: 'graphql-request',
      // ...
    },
  ],
});

for await (const event of run) {
  /*
    {
      type: 'run:execute',
      id: '0',
      payload: { item: { type: 'collection', ... }, options: {} },
      context: { ... }
    },
    {
      type: 'run:execute',
      id: '1',
      payload: { item: { type: 'http-request', ... }, options: {} },
      context: { process: ['run:execute#0'], ... }
    },
    {
      type: 'http:send-request',
      id: '2',
      payload: { method: 'GET', url: 'http://postman-echo.com/get' },
      context: { process: ['run:execute#1', 'run:execute#0'], ... }
    },
    {
      type: 'http:received-response-start',
      id: '3',
      payload: { status: 200, statusText: 'OK', headers: [...] },
      context: { process: ['run:execute#1', 'run:execute#0'], ... }
    },
    {
      type: 'http:received-response-data',
      id: '4',
      payload: [...],
      context: { process: ['run:execute#1', 'run:execute#0'], ... }
    },
    ...
    {
      type: 'run:execute',
      id: '5',
      payload: { item: { type: 'grpc-request', ... }, options: {} },
      context: { process: ['run:execute#0'], ... }
    },
    ...
    {
      type: 'run:execute',
      id: '6',
      payload: { item: { type: 'graphql-request', ... }, options: {} },
      context: { process: ['run:execute#0'], ... }
    },
    ...
  */
}
```

## Items

The Runtime can execute collections and items that are specified in `@postman/runtime.models`, including `collection`, `http-request`, `grpc-request`, `graphql-request`, `websocket-request`, `mqtt-request`, and more.

```ts
import { Runtime } from '@postman/runtime';

const runtime = new Runtime();
const run = runtime.execute(
  {
    type: 'grpc-request',
    payload: {
      url: '{{host}}',
      // ...
    },
  },
  {
    variables: [{ key: 'host', value: 'grpc://localhost:9000' }],
  },
);
```

See the [Execution docs](./docs/execution.md) for more information.

## Events

Each event emitted by the Runtime has the following shape:

```ts
interface RuntimeEvent {
  type: `${string}:${string}`; // namespace:event
  payload: unknown;

  id: string;
  context: RuntimeEventContext;
  revisions?: Revision[]; // changes to event during processing
}
```

### Context

```ts
interface RuntimeEventContext {
  timestamp: ISO8601;
  source: string;
  item: Link | null;
  folders: Link[];
  collection: Link | null;
  workspace: Link | null;
  environment: Link | null;
  run: Link | null;
  process: Link[];
}
```

Example:

```ts
const event = {
  type: 'graphql:request',
  id: '4',
  payload: {
    // ...
  },
  context: {
    timestamp: '2024-01-01T00:00:00.000000Z',
    source: 'graphql',
    item: 'graphql-request#1',
    folders: [],
    collection: 'collection#2',
    workspace: 'workspace#3',
    environment: null,
    run: 'run:execute#1',
    process: ['run:execute#1', 'run:execute#4'],
  },
};
```

See the [Events docs](./docs/events.md) for more information.

## Plugins

The Runtime is designed to be extensible, with functionality being added with plugins.

```ts
import type { Plugin } from '@postman/runtime';
import { encrypt, decrypt } from './custom-encryption';

export const customEncryption: Plugin = {
  name: 'custom-encryption',

  resolved: {
    async 'grpc:invoke'(event) {
      event.payload.message = await encrypt(event.payload.message);
    },
  },

  prepare: {
    async 'grpc:receive'(event) {
      event.payload.message = await decrypt(event.payload.message);
    },
  },
};
```

See the [Plugins docs](./docs/plugins.md) for more information.
