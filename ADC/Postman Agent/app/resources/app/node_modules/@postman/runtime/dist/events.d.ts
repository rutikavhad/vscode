import { type Patches } from 'mutative';
import * as z from 'zod/v4-mini';
import type { AnyItem } from './items';
import type { CollectionEvent } from './items/collection';
import { GraphQLEvent } from './items/graphql';
import type { GRPCEvent } from './items/grpc';
import type { HTTPEvent } from './items/http';
import type { MCPEvent } from './items/mcp';
import { WebSocketEvent } from './items/websocket';
import { Link } from './lib/resources';
import type { ScriptingEvent } from './plugins/scripting';
export type Event = InternalEvent | BuiltInEvent;
export type InternalEvent = RunEvent;
export type BuiltInEvent = CollectionEvent | HTTPEvent | GraphQLEvent | MCPEvent | WebSocketEvent | GRPCEvent | ScriptingEvent;
export interface AnyEvent {
    type: string;
    payload?: unknown;
}
export declare function isAnyEvent(input: unknown): input is AnyEvent;
export declare const ISO8601: z.z.iso.ZodMiniISODateTime;
export type ISO8601 = z.infer<typeof ISO8601>;
export declare const RuntimeEventContext: z.ZodMiniObject<{
    timestamp: z.z.iso.ZodMiniISODateTime;
    source: z.ZodMiniString<string>;
    item: z.ZodMiniNullable<z.ZodMiniTemplateLiteral<`${string}#${string}`>>;
    collection: z.ZodMiniNullable<z.ZodMiniTemplateLiteral<`${string}#${string}`>>;
    folders: z.ZodMiniArray<z.ZodMiniTemplateLiteral<`${string}#${string}`>>;
    workspace: z.ZodMiniNullable<z.ZodMiniTemplateLiteral<`${string}#${string}`>>;
    environment: z.ZodMiniNullable<z.ZodMiniTemplateLiteral<`${string}#${string}`>>;
    run: z.ZodMiniTemplateLiteral<`${string}#${string}`>;
    process: z.ZodMiniArray<z.ZodMiniTemplateLiteral<`${string}#${string}`>>;
}, z.z.core.$strip>;
/**
 * Standard context included with all runtime events
 *
 * - timestamp: datetime of when event was created
 * - source: plugin name or "external" that created event
 * - item, collection, workspace, environment: execution environment
 * - folders: chain of folders containing current item (from farthest-to-closest)
 * - run: root `run:execute` event representing entire run
 * - process: chain of `run:execute` events (from run-to-closest)
 */
export type RuntimeEventContext = z.infer<typeof RuntimeEventContext>;
export declare function isRuntimeEventContext(input: unknown): input is RuntimeEventContext;
/**
 * Interface for all events emitted by the Runtime
 * (note: event types should be considered _input_ types and should not extend RuntimeEvent)
 *
 * @example
 * ```ts
 * // Event type only has type and (optionally) payload
 * export namespace CustomEvent {
 *   export type Message = { type: 'custom:message', payload: string }
 * }
 * export type CustomEvent = CustomEvent.Message;
 *
 * function eventHandler(event: RuntimeEvent<CustomEvent>) {
 *   // event has additional information emitted by runtime
 * }
 * ```
 */
export type RuntimeEvent<TEvent extends AnyEvent = AnyEvent> = {
    id: string;
    context: RuntimeEventContext;
    /**
     * List of revisions that occurred while the event was being processed
     */
    revisions?: Array<{
        source: string;
        inversePatches: Patches;
    }>;
} & TEvent;
export declare function isRuntimeEvent(input: unknown): input is RuntimeEvent;
export declare namespace RunEvent {
    type Execute<TItem extends AnyItem = AnyItem, TOptions extends Record<string, unknown> = Record<string, unknown>> = {
        type: 'run:execute';
        payload: {
            item: TItem;
            options: TOptions;
        };
    };
    type Start = {
        type: 'run:start';
        payload: {
            iterations: number;
            iteration: number;
        };
    };
    type End = {
        type: 'run:end';
        payload?: undefined;
    };
    type Cancel = {
        type: 'run:cancel';
        payload?: undefined;
    };
    type Retry = {
        type: 'run:retry';
        payload?: undefined;
    };
    type Error = {
        type: 'run:error';
        payload: {
            error: unknown;
        };
    };
    type Patch = {
        type: 'run:patch';
        payload: {
            link: Link;
            patches: Patches;
        };
    };
}
export type RunEvent = RunEvent.Execute | RunEvent.Start | RunEvent.End | RunEvent.Cancel | RunEvent.Retry | RunEvent.Error | RunEvent.Patch;
/**
 * Check if the given event as an event of the given type
 */
export declare function isEventOfType<Type extends Event['type']>(type: Type): (event: AnyEvent) => event is Extract<Event, {
    type: Type;
}>;
export declare function isEventOfType<Type extends Event['type']>(type: Type, event: AnyEvent): event is Extract<Event, {
    type: Type;
}>;
/**
 * Check if the given event as a RuntimeEvent of the given type
 */
export declare function isRuntimeEventOfType<Type extends Event['type']>(type: Type): (event: RuntimeEvent) => event is RuntimeEvent<Extract<Event, {
    type: Type;
}>>;
export declare function isRuntimeEventOfType<Type extends Event['type']>(type: Type, event: RuntimeEvent): event is RuntimeEvent<Extract<Event, {
    type: Type;
}>>;
export type ErrorEvent = Extract<Event, {
    payload: {
        error: unknown;
    };
}>;
export declare function isErrorEvent(input: unknown): input is ErrorEvent;
