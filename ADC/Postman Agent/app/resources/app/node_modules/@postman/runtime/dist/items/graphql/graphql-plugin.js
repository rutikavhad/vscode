"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.graphql = void 0;
exports.incrementalDelivery = incrementalDelivery;
exports.graphqlOverSSE = graphqlOverSSE;
exports.graphqlOverWebSocket = graphqlOverWebSocket;
const runtime_models_1 = require("@postman/runtime.models");
const client_1 = require("graphql-ws/client");
const key_values_1 = require("../../lib/key-values");
const objects_1 = require("../../lib/objects");
const promises_1 = require("../../lib/promises");
const jsonc_1 = require("../../lib/serialization/jsonc");
const streams_1 = require("../../lib/streams");
const urls_1 = require("../../lib/urls");
const http_1 = require("../http");
const websocket_1 = require("../websocket");
const graphql_1 = require("./graphql");
exports.graphql = {
    name: 'graphql',
    items: {
        'graphql-request'(item, run) {
            (0, runtime_models_1.assertResourceType)(runtime_models_1.GraphQLRequest, item);
            run.enqueue({
                type: 'graphql:send-request',
                payload: {
                    query: item.payload.query,
                    operationName: run.context.options?.operationName,
                    variables: item.payload.variables ?? '',
                    method: undefined,
                    url: item.payload.url,
                    headers: item.payload.headers ?? [],
                    settings: {
                        disabledSystemHeaders: item.payload.settings?.disabledSystemHeaders ?? [],
                        followOriginalHttpMethod: true,
                    },
                },
            });
        },
    },
    execute: {
        'graphql:send-request'(event, run) {
            run.waitUntil(async () => {
                const [protocol, operationType] = (0, graphql_1.inferProtocol)(event.payload);
                const url = (0, urls_1.parseURL)(event.payload.url, {
                    defaultProtocol: protocol === 'websocket' ? 'ws:' : 'http:',
                }).href;
                // Ensure variables are JS object
                // (ignore invalid JSON and invalid type)
                let maybeVariables = event.payload.variables || {};
                try {
                    if (typeof maybeVariables === 'string') {
                        maybeVariables = jsonc_1.JSONC.deserialize(maybeVariables || '{}');
                    }
                }
                catch (_error) {
                    // (ignore invalid variables JSON)
                }
                const variables = (0, objects_1.isPlainObject)(maybeVariables) ? maybeVariables : {};
                // Add computed / internal information to event
                run.patch(event, (payload) => {
                    payload.variables = variables;
                    payload.protocol = protocol;
                    payload.operationType = operationType;
                });
                if (run.context.execution?.dryRun) {
                    return;
                }
                if (protocol === 'http' || protocol === 'sse') {
                    await graphqlOverHTTP({ ...event.payload, url, variables }, run);
                }
                else {
                    await graphqlOverWebSocket({ ...event.payload, url, variables }, run);
                }
            });
        },
    },
};
async function graphqlOverHTTP(payload, run) {
    const execution = run.execute({
        type: 'http-request',
        payload: {
            method: payload.method ?? 'POST',
            url: payload.url,
            headers: payload.headers,
            body: {
                type: 'json',
                content: JSON.stringify({
                    query: payload.query,
                    operationName: payload.operationName,
                    variables: payload.variables,
                }),
            },
            settings: payload.settings,
        },
        extensions: {
            auth: run.item?.extensions?.auth,
        },
    }, {
        scripting: { disabled: true },
    });
    try {
        const response = await http_1.Response.from(execution);
        if (!response.ok) {
            // Wait for response to finish and then exit
            await (0, streams_1.done)(response.body);
            throw new Error(`Unsuccessful GraphQL request, ${response.status} ${response.statusText}`);
        }
        const contentType = (0, key_values_1.getValue)(response.headers, 'content-type', {
            caseInsensitive: true,
        })?.toLowerCase();
        if (contentType === 'text/event-stream') {
            return graphqlOverSSE();
        }
        if (contentType === 'multipart/mixed') {
            return incrementalDelivery();
        }
        let payload;
        try {
            payload = await response.json();
        }
        catch (_error) {
            // (ignore, handled in object check)
        }
        if (!payload || !(0, objects_1.isPlainObject)(payload)) {
            throw new Error(`Received an invalid GraphQL response`);
        }
        run.enqueue({
            type: 'graphql:received-response',
            payload,
        });
    }
    catch (error) {
        run.error({ type: 'graphql:error', payload: { error } });
    }
}
//
// #region Incremental Delivery
//
async function incrementalDelivery() {
    throw new Error('Incremental Delivery over HTTP is not supported');
}
//
// #region GraphQL over SSE
//
async function graphqlOverSSE() {
    throw new Error('GraphQL over SSE is not supported');
}
//
// #region GraphQL over WebSocket
//
async function graphqlOverWebSocket(payload, run) {
    const complete = (0, promises_1.promiseWithResolvers)();
    const WebSocket = (0, websocket_1.createWebSocketConstructor)(run, {
        type: 'ws-raw-request',
        payload: {
            headers: payload.headers,
        },
    }, {
        scripting: { disabled: true },
    }, (socket) => {
        socket.addEventListener('close', () => {
            complete.resolve();
        });
    });
    const client = (0, client_1.createClient)({ url: payload.url, webSocketImpl: WebSocket });
    client.on('connected', () => {
        run.enqueue({
            type: 'graphql:received-response-stream-start',
        });
    });
    const unsubscribe = client.subscribe({
        query: payload.query,
        operationName: payload.operationName,
        variables: payload.variables,
    }, {
        next(value) {
            run.enqueue({
                type: 'graphql:received-response-stream-data',
                payload: value,
            });
        },
        error(error) {
            // Avoid leaking symbols in errors
            const errors = (Array.isArray(error) ? error : [error]).map(removeSymbols);
            run.enqueue({
                type: 'graphql:received-response-stream-data',
                payload: { errors },
            });
        },
        complete() { },
    });
    run.subscribe({
        'run:cancel'() {
            unsubscribe();
        },
    });
    run.defer(async () => {
        unsubscribe();
        return await client.dispose();
    });
    run.waitUntil(complete.promise);
}
//
// #region Utilities
//
function removeSymbols(value) {
    return Object.fromEntries(Object.entries(value).filter(([key]) => typeof key === 'string'));
}
//# sourceMappingURL=graphql-plugin.js.map