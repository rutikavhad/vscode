"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.platform = void 0;
const runtime_grpc_client_1 = require("@postman/runtime.grpc-client");
const runtime_grpc_utils_1 = require("@postman/runtime.grpc-utils");
const json_bigint_string_1 = __importDefault(require("json-bigint-string"));
const character_encoding_1 = require("../../lib/character-encoding");
const objects_1 = require("../../lib/objects");
const rpc_1 = require("../../lib/rpc");
const jsonc_1 = require("../../lib/serialization/jsonc");
const sizes_1 = require("../../lib/sizes");
const streams_1 = require("../../lib/streams");
const urls_1 = require("../../lib/urls");
const metadata_1 = require("./metadata");
exports.platform = {
    async invoke(event) {
        return new rpc_1.Channel(async ({ incoming, outgoing }) => {
            const url = event.payload.url;
            const settings = event.payload.settings ?? {};
            const metadata = (0, metadata_1.toRawMetadata)(event.payload.metadata);
            if (!event.payload.methodDescriptor) {
                throw new Error('Missing service definition');
            }
            const descriptor = (0, runtime_grpc_utils_1.toJSONDescriptor)(event.payload.methodDescriptor);
            const definition = new runtime_grpc_utils_1.Definition(descriptor);
            const method = definition.methods.get(event.payload.methodPath);
            if (!method) {
                throw new Error(`Method not found: "${event.payload.methodPath}"`);
            }
            const message = method.kind === 'unary' || method.kind === 'server-stream' ?
                normalizeMessage(event.payload.message.content, method)
                : undefined;
            const channelOptions = {
                'grpc.max_send_message_length': -1,
                'grpc.max_receive_message_length': settings.maxResponseMessageSize ?
                    settings.maxResponseMessageSize * sizes_1.MiB
                    : -1,
                'grpc.ssl_target_name_override': settings.serverNameOverride ?? '',
                'grpc.enable_http_proxy': !settings.proxy ? 0 : 1,
            };
            const callOptions = {
                connectionTimeout: settings.connectionTimeout ?? Infinity,
            };
            const secure = (0, urls_1.isTLS)((0, urls_1.parseURL)(url));
            const tlsOptions = secure || settings.secureConnection ?
                {
                    rejectUnauthorized: Boolean(settings.strictSSL),
                    secureContext: prepareSecureContextOptions(settings),
                }
                : undefined;
            const invocation = new runtime_grpc_client_1.Client({
                url,
                descriptor,
                includeDefaultFields: Boolean(settings.includeDefaultFields ?? true),
                proxy: settings.proxy === true ? undefined : settings.proxy,
                channelOptions,
                callOptions,
                tlsOptions,
            }).invoke(method.name, {
                metadata,
                message,
                callOptions,
            });
            incoming.enqueue({
                type: 'grpc:sent-request-header',
                payload: {
                    metadata: (0, metadata_1.toItemMetadata)(metadata),
                    isRequestStreamed: ['client-stream', 'bidi'].includes(method.kind),
                    isResponseStreamed: ['server-stream', 'bidi'].includes(method.kind),
                },
            });
            if (message !== undefined) {
                incoming.enqueue({
                    type: 'grpc:sent-request-data',
                    payload: { data: json_bigint_string_1.default.parse(message) },
                });
            }
            invocation
                .on('response', (data) => {
                incoming.enqueue({
                    type: 'grpc:received-response-data',
                    payload: { data },
                });
            })
                .on('metadata', (metadata) => {
                incoming.enqueue({
                    type: 'grpc:received-response-header',
                    payload: {
                        metadata: (0, metadata_1.toItemMetadata)(metadata),
                    },
                });
            })
                .on('status', (status) => {
                incoming.enqueue({
                    type: 'grpc:status',
                    payload: {
                        statusCode: status.code,
                        statusMessage: status.message,
                        metadata: (0, metadata_1.toItemMetadata)(status.metadata),
                        timings: status.timings,
                    },
                });
                incoming.close();
            })
                .on('error', (error) => {
                invocation.cancel();
                incoming.error(error);
            });
            incoming.signal.addEventListener('abort', () => {
                invocation.cancel();
            });
            for await (const event of (0, streams_1.values)(outgoing)) {
                if (event.type === 'grpc:close') {
                    invocation.end();
                }
                if (event.type === 'run:cancel') {
                    invocation.cancel();
                }
                if (event.type === 'grpc:write') {
                    try {
                        const message = normalizeMessage(event.payload.json, method);
                        invocation.write(message);
                        incoming.enqueue({
                            type: 'grpc:sent-request-data',
                            payload: {
                                data: json_bigint_string_1.default.parse(message),
                            },
                        });
                    }
                    catch (error) {
                        incoming.enqueue({
                            type: 'grpc:transient-error',
                            payload: { error },
                        });
                    }
                }
            }
        });
    },
};
function prepareSecureContextOptions(options) {
    const { certificate, ca } = options;
    return {
        cert: certificate?.cert ? character_encoding_1.UTF8.decode(certificate.cert) : undefined,
        key: certificate?.key ? character_encoding_1.UTF8.decode(certificate.key) : undefined,
        pfx: certificate?.pfx ? character_encoding_1.UTF8.decode(certificate.pfx) : undefined,
        passphrase: certificate?.passphrase,
        ca: ca ? character_encoding_1.UTF8.decode(ca) : undefined,
    };
}
/**
 * Both object and array representation of Map fields are accepted for backwards compatibility.
 * This converts to object representation to comply with actual descriptor.
 */
function normalizeMessage(message, method) {
    let normalizedMessage = '{}';
    try {
        const parsedMessage = jsonc_1.JSONC.deserialize(message);
        method?.requestType.jsonSchema.mapFields?.forEach((path) => {
            const value = (0, objects_1.get)(parsedMessage, path);
            if (Array.isArray(value)) {
                const object = {};
                for (const item of value) {
                    object[item.key] = item.value;
                }
                (0, objects_1.set)(parsedMessage, path, object);
            }
        });
        normalizedMessage = JSON.stringify(parsedMessage);
    }
    catch (_error) {
        // fallthrough, to be handled by validation
    }
    if (!method?.requestType.validate(normalizedMessage)) {
        throw new Error('Message violates its Protobuf type definition');
    }
    return normalizedMessage;
}
//# sourceMappingURL=grpc-platform.node.js.map