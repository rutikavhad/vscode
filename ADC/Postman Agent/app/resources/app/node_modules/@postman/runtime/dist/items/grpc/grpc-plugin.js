"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.grpc = grpc;
const runtime_models_1 = require("@postman/runtime.models");
const streams_1 = require("../../lib/streams");
const unimplementedPlatform = {
    invoke() {
        throw new Error('GRPC `invoke` not implemented');
    },
};
function grpc(options) {
    const { platform = unimplementedPlatform } = options;
    return {
        name: 'grpc',
        items: {
            'grpc-request'(item, run) {
                (0, runtime_models_1.assertResourceType)(runtime_models_1.GRPCRequest, item);
                run.enqueue({
                    type: 'grpc:invoke',
                    payload: {
                        url: item.payload.url,
                        methodPath: item.payload.methodPath ?? '',
                        message: item.payload.message ?? { content: '' },
                        metadata: item.payload.metadata ?? [],
                        methodDescriptor: item.payload.methodDescriptor ?? '',
                        settings: {
                            secureConnection: item.payload.settings?.secureConnection ?? false,
                            strictSSL: item.payload.settings?.strictSSL ?? true,
                            includeDefaultFields: item.payload.settings?.includeDefaultFields ?? true,
                            connectionTimeout: item.payload.settings?.connectionTimeout ?? Infinity,
                            ...item.payload.settings,
                        },
                        schema: item.extensions?.schema,
                    },
                });
            },
        },
        execute: {
            async 'grpc:invoke'(event, run) {
                let connection;
                try {
                    connection = await platform.invoke(event, run.context);
                }
                catch (error) {
                    return run.error({
                        type: 'grpc:error',
                        payload: { error },
                    });
                }
                // After the connection has been established,
                // continue processing events to allow gRPC messages to be written to the connection
                run.waitUntil(async () => {
                    const writer = connection.writable.getWriter();
                    run.subscribe({
                        'run:cancel'(event) {
                            writer.write(event);
                        },
                        'grpc:close'(event) {
                            writer.write(event);
                        },
                        'grpc:write'(event) {
                            writer.write(event);
                        },
                    });
                    try {
                        for await (const event of (0, streams_1.values)(connection.readable)) {
                            run.enqueue(event);
                        }
                    }
                    catch (error) {
                        run.error({
                            type: 'grpc:error',
                            payload: { error },
                        });
                    }
                });
            },
        },
    };
}
//# sourceMappingURL=grpc-plugin.js.map