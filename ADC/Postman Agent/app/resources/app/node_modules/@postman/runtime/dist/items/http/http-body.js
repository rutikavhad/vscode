"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareBody = prepareBody;
exports.readBody = readBody;
exports.computeBodyHash = computeBodyHash;
const hashing_1 = require("../../lib/crypto/hashing");
const file_system_1 = require("../../lib/file-system/file-system");
const key_values_1 = require("../../lib/key-values");
const form_data_1 = require("../../lib/serialization/form-data");
const url_encoded_1 = require("../../lib/serialization/url-encoded");
const CONTENT_TYPES = {
    file: 'application/octet-stream',
    formdata: 'multipart/form-data',
    html: 'text/html',
    javascript: 'application/javascript',
    json: 'application/json',
    none: undefined,
    text: 'text/plain',
    urlencoded: 'application/x-www-form-urlencoded',
    xml: 'application/xml',
};
const FORM_URLENCODED = /^application\/x-www-form-urlencoded\b/;
async function prepareBody(bodyInfo, details = {}, platform = {}) {
    if (bodyInfo == null) {
        return {
            body: new Uint8Array(),
            contentType: null,
            contentSize: 0,
        };
    }
    let body = new Uint8Array();
    let { contentType } = details;
    switch (bodyInfo.type) {
        case 'text':
        case 'json':
        case 'xml':
        case 'html':
        case 'javascript':
            body = new TextEncoder().encode(bodyInfo.content);
            contentType ??= CONTENT_TYPES[bodyInfo.type];
            break;
        case 'formdata':
            const boundary = (0, form_data_1.getBoundary)(contentType ?? '');
            const result = await (0, form_data_1.serializeFormData)(bodyInfo.content, { boundary }, platform);
            if (!contentType || result.boundary !== boundary) {
                contentType = `multipart/form-data; boundary=${result.boundary}`;
            }
            body = result.data;
            break;
        case 'urlencoded':
            if (!contentType || !FORM_URLENCODED.test(contentType)) {
                contentType = 'application/x-www-form-urlencoded';
            }
            body = new TextEncoder().encode((0, url_encoded_1.serializeURLEncoded)(bodyInfo.content));
            break;
        case 'file':
            if (!platform.fs) {
                throw new Error('Unable to prepare file body, filesystem not provided');
            }
            if (bodyInfo.content.src) {
                body = await (0, file_system_1.fs)(platform.fs).readFile(bodyInfo.content.src);
            }
            break;
    }
    return {
        body,
        contentType: contentType ?? null,
        contentSize: body.length,
    };
}
/**
 * Read then body for the given request
 */
async function readBody(request, platform) {
    const { body: data } = await prepareBody(request.body, {
        contentType: (0, key_values_1.getValue)(request.headers, 'content-type', {
            caseInsensitive: true,
        }),
    }, platform);
    return data;
}
/**
 * Read the body for the given request and compute the hash
 * for the given hashing algorithm and encoding
 */
async function computeBodyHash(request, algorithm, encoding, platform) {
    const data = await readBody(request, platform);
    const bodyHash = await (0, hashing_1.computeHash)(data, algorithm, encoding);
    return bodyHash;
}
//# sourceMappingURL=http-body.js.map