import type { DescriptiveKeyValues, DescriptiveNullableKeyValues, HTTPRequest, KeyValues } from '@postman/runtime.models';
import type { EphemeralKeyInfo } from 'node:tls';
import { EmptyObject } from '../../lib/objects';
import { Certificate } from '../../plugins/certificates/certificates';
export declare namespace HTTPEvent {
    /**
     * Request information and settings for what will be sent
     */
    type SendRequest = {
        type: 'http:send-request';
        payload: {
            url: string;
            method: string;
            headers: HeadersInput;
            queryParams: DescriptiveNullableKeyValues;
            pathVariables: DescriptiveKeyValues;
            body: BodyInput;
            settings: SettingsInput;
        };
    };
    /**
     * Raw information about the request that was sent to the server
     */
    type SentRequest = {
        type: 'http:sent-request';
        payload: {
            httpVersion: '1.1' | '2.0' | {};
            url: string;
            method: string;
            headers: KeyValues;
            body: string | Uint8Array | null;
            sizes: {
                headers: number;
                body: number;
            };
            connection: Connection;
        };
    };
    /**
     * Response information that led to a HTTP redirection
     * (exactly matches http:received-response-start)
     */
    type Redirected = {
        type: 'http:redirected';
        payload: ReceivedResponseStart['payload'];
    };
    /**
     * Response information received at the start of the response
     * (before download has begun)
     */
    type ReceivedResponseStart = {
        type: 'http:received-response-start';
        payload: {
            statusCode: number;
            statusText: string;
            headers: KeyValues;
            /**
             * Set of timing information for the request-response lifecycle,
             * as milliseconds spent in the phase
             */
            timings: {
                prepare: number;
                wait: number;
                dns: number;
                tcp: number;
                secureHandshake?: number;
                firstByte: number;
            };
            sizes: {
                headers: number;
            };
        };
    };
    type ReceivedResponseData = {
        type: 'http:received-response-data';
        payload: {
            data: Uint8Array;
        };
    };
    type ReceivedResponseEnd = {
        type: 'http:received-response-end';
        payload: {
            /**
             * Set of timing information for the request-response lifecycle,
             * as milliseconds spent in the phase
             */
            timings: {
                prepare: number;
                wait: number;
                dns: number;
                tcp: number;
                secureHandshake?: number;
                firstByte: number;
                download: number;
                process: number;
                total: number;
            };
            sizes: {
                headers: number;
                body: number;
                /**
                 * Total bytes of the response data (uncompressed, if applicable)
                 */
                resourceBytes: number;
            };
        };
    };
    type Error = {
        type: 'http:error';
        payload: {
            error: unknown;
        };
    };
}
export type HTTPEvent = HTTPEvent.SendRequest | HTTPEvent.SentRequest | HTTPEvent.Redirected | HTTPEvent.ReceivedResponseStart | HTTPEvent.ReceivedResponseData | HTTPEvent.ReceivedResponseEnd | HTTPEvent.Error;
export type ExtendedHeader = DescriptiveKeyValues[number] & {
    system?: true;
};
export type HeadersInput = Array<ExtendedHeader>;
export type BodyInput = NonNullable<HTTPRequest['payload']['body']>;
export type SettingsInput = NonNullable<HTTPRequest['payload']['settings']> & {
    proxy?: string | boolean;
    certificate?: Certificate | null;
    ca?: Uint8Array | null;
    sslKeyLogFile?: string | null;
    timeout?: number | null;
};
export interface Connection {
    reused: boolean;
    local?: NetworkInfo;
    remote?: NetworkInfo;
    tls?: TLSInfo;
}
export interface NetworkInfo {
    address: string;
    /**
     * Internet protocol family of the address (i.e. "IPv4" or "IPv6")
     */
    family: string;
    port: number;
}
export interface TLSInfo {
    reused: boolean;
    authorized: boolean;
    authorizationError?: string;
    cipher: {
        name: string;
        version: string;
    };
    protocol: string;
    /**
     * An object representing the type, name, and size of parameter of an ephemeral key exchange
     * in perfect forward secrecy on a client connection. Is an empty object when the key exchange is not ephemeral.
     */
    ephemeralKeyInfo: EphemeralKeyInfo | EmptyObject | null;
    peerCertificate: {
        subject: {
            country: string;
            stateOrProvince: string;
            locality: string;
            organization: string;
            organizationalUnit: string;
            commonName: string;
            alternativeNames?: string;
        };
        issuer: {
            country: string;
            stateOrProvince: string;
            locality: string;
            organization: string;
            organizationalUnit: string;
            commonName: string;
        };
        validFrom: string;
        validTo: string;
        fingerprint: string;
        serialNumber: string;
    };
}
