"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareSystemHeaders = prepareSystemHeaders;
exports.applySystemHeaders = applySystemHeaders;
exports.headerKeyValuesToEntries = headerKeyValuesToEntries;
exports.hasHeader = hasHeader;
exports.getHeader = getHeader;
const package_json_1 = __importDefault(require("../../../package.json"));
function prepareSystemHeaders(information) {
    return [
        {
            key: 'Cache-Control',
            value: 'no-cache',
            system: true,
        },
        {
            key: 'Postman-Token',
            value: crypto.randomUUID(),
            system: true,
        },
        !!information.contentType && {
            key: 'Content-Type',
            value: information.contentType,
            system: true,
        },
        information.contentSize != null && {
            key: 'Content-Length',
            value: String(information.contentSize),
            system: true,
        },
        {
            key: 'Host',
            value: information.host,
            system: true,
        },
        {
            key: 'User-Agent',
            value: `PostmanRuntime/${package_json_1.default.version}`,
            system: true,
        },
        {
            key: 'Accept',
            value: '*/*',
            system: true,
        },
        {
            key: 'Accept-Encoding',
            value: 'gzip, deflate, br',
            system: true,
        },
        {
            key: 'Connection',
            value: 'keep-alive',
            system: true,
        },
    ].filter(Boolean);
}
/**
 * **Mutating** Add system headers to HTTP send payload
 */
function applySystemHeaders(payload, systemHeaders) {
    for (const header of systemHeaders) {
        payload.headers.push(header);
    }
}
/**
 * Remove disabled headers and handle with standard Headers support
 */
function headerKeyValuesToEntries(payload) {
    if (!payload.headers)
        return [];
    const disabledSystemHeaders = (payload.settings?.disabledSystemHeaders ?? []).map((key) => key.toLowerCase());
    // First, add user headers
    const combined = payload.headers
        .filter((header) => !header.disabled && !header.system)
        .map((header) => [header.key, header.value]);
    // Next, add system headers that aren't disabled or overridden
    for (const header of payload.headers) {
        if (!header.system)
            continue;
        const key = header.key.toLowerCase();
        const isDisabled = header.disabled || disabledSystemHeaders.includes(key);
        const isOverridden = combined.some((userHeader) => userHeader[0].toLowerCase() === key);
        if (!isDisabled && !isOverridden) {
            combined.push([header.key, header.value]);
        }
    }
    return combined;
}
function hasHeader(headers, key, value) {
    const header = getHeader(headers, key);
    if (!header)
        return false;
    return value == null || header.value === value;
}
function getHeader(headers, key) {
    const search = key.toLowerCase();
    return headers.find((header) => header.key.toLowerCase() === search);
}
//# sourceMappingURL=http-headers.js.map