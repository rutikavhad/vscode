"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.platform = void 0;
const node_crypto_1 = require("node:crypto");
const postman_request_1 = __importDefault(require("postman-request"));
const rpc_1 = require("../../lib/rpc");
const cookie_connection_store_node_1 = require("../../plugins/cookies/cookie-connection-store.node");
const http_headers_1 = require("./http-headers");
exports.platform = {
    async fetch(request) {
        const { url, method, headers: headerEntries, body, settings } = request;
        const start = performance.now();
        const headers = entriesToOutgoingHeaders(headerEntries);
        let httpRequest;
        return new rpc_1.Channel(({ incoming, outgoing }) => {
            const secureOptions = settings.tlsDisabledProtocols.reduce((memo, protocol) => memo | node_crypto_1.constants[`SSL_OP_NO_${protocol}`], 0);
            const jar = !settings.disableCookies ?
                postman_request_1.default.jar(new cookie_connection_store_node_1.CookieConnectionStore({ incoming, outgoing }))
                : false;
            httpRequest = (0, postman_request_1.default)({
                method,
                url,
                headers,
                body,
                jar,
                gzip: true,
                brotli: true,
                time: true,
                verbose: true,
                //
                // Encoding
                //
                // - Use pre-encoded URL
                // - Encode formdata/querystring as foo=bar&foo=baz instead of foo[0]=bar&foo[1]=baz
                // - encoding = null to stream data
                //
                disableUrlEncoding: true,
                useQuerystring: true,
                encoding: null,
                statusMessageEncoding: 'utf8',
                //
                // TLS / SSL
                //
                honorCipherOrder: !!settings.tlsPreferServerCiphers,
                secureOptions,
                ciphers: settings.tlsCipherSelection.join(':'),
                strictSSL: settings.strictSSL,
                ca: settings.ca,
                cert: settings.certificate?.cert,
                key: settings.certificate?.key,
                pfx: settings.certificate?.pfx,
                passphrase: settings.certificate?.passphrase,
                sslKeyLogFile: settings.sslKeyLogFile,
                //
                // Redirects
                //
                followAllRedirects: settings.followRedirects,
                maxRedirects: settings.maxRedirects,
                followOriginalHttpMethod: settings.followOriginalHttpMethod,
                followAuthorizationHeader: settings.followAuthorizationHeader,
                removeRefererHeader: settings.removeRefererHeaderOnRedirect,
                //
                // Proxy
                //
                proxy: settings.proxy === true ? undefined : settings.proxy,
                //
                // Agent / Settings
                //
                timeout: settings.timeout,
                agents: undefined,
                extraCA: undefined,
                agentIdleTimeout: undefined,
                protocolVersion: settings.protocolVersion,
            }, () => { });
            let resourceBytes = 0;
            httpRequest
                .on('redirect', function onRedirect() {
                const debugData = this._debug.at(-1);
                incoming.enqueue(getSentRequestEvent(debugData, request));
                incoming.enqueue({
                    type: 'http:redirected',
                    payload: {
                        statusCode: debugData.response.statusCode,
                        statusText: this.response?.statusMessage ?? '',
                        headers: debugData.response.headers,
                        timings: calculateTimings(start, debugData),
                        sizes: {
                            headers: estimateHeaderSize(debugData.response.headers),
                        },
                    },
                });
            })
                .on('response', function onResponse(response) {
                const debugData = this._debug.at(-1);
                const headers = incomingHeadersToKeyValues(response.headers);
                incoming.enqueue(getSentRequestEvent(debugData, request));
                incoming.enqueue({
                    type: 'http:received-response-start',
                    payload: {
                        statusCode: response.statusCode,
                        statusText: response.statusMessage ?? '',
                        headers,
                        timings: calculateTimings(start, debugData),
                        sizes: {
                            headers: estimateHeaderSize(headers, response),
                        },
                    },
                });
            })
                .on('data', (data) => {
                resourceBytes += data.byteLength;
                incoming.enqueue({
                    type: 'http:received-response-data',
                    payload: { data },
                });
            })
                .on('complete', function onComplete(response) {
                const debugData = this._debug.at(-1);
                const headers = incomingHeadersToKeyValues(response.headers);
                const headerSize = estimateHeaderSize(headers, response);
                const timings = calculateTimings(start, debugData);
                // Compute body size:
                //
                // 1. Use downloadedBytes
                // 2. Use content-length header
                // 3. Use measured bytes from data events
                const contentLength = (0, http_headers_1.getHeader)(headers, 'content-length')?.value;
                const bodySize = debugData.response.downloadedBytes ??
                    (contentLength ? parseInt(contentLength, 10) : resourceBytes);
                incoming.enqueue({
                    type: 'http:received-response-end',
                    payload: {
                        timings,
                        sizes: {
                            headers: headerSize,
                            body: bodySize,
                            resourceBytes,
                        },
                    },
                });
            })
                .on('error', (error) => {
                incoming.error(error);
            })
                .on('close', () => {
                incoming.close();
            });
            // Abort the request if readable stream is cancelled
            incoming.signal.addEventListener('abort', () => {
                httpRequest?.abort();
            });
        });
    },
};
function getSentRequestEvent(debug, request) {
    const bodySize = request.body == null ? 0
        : typeof request.body === 'string' ? request.body.length
            : request.body.byteLength;
    return {
        type: 'http:sent-request',
        payload: {
            httpVersion: debug.request.httpVersion,
            url: debug.request.href,
            method: debug.request.method,
            headers: debug.request.headers,
            body: request.body ?? null,
            sizes: {
                headers: estimateHeaderSize(debug.request.headers),
                body: bodySize,
            },
            connection: {
                reused: debug.session.reused,
                local: debug.session.data.addresses?.local,
                remote: debug.session.data.addresses?.remote,
                tls: debug.session.data.tls,
            },
        },
    };
}
/**
 * Estimate header size per the [HTTP message format][1]:
 *
 * HTTP-message   = start-line (request-line / status-line)
 *                  *( header-field CRLF )
 *                  CRLF
 *                  [ message-body ]
 * status-line = HTTP-version SP status-code SP reason-phrase CRLF
 *
 * [1]: https://tools.ietf.org/html/rfc7230#section-3
 */
function estimateHeaderSize(headers, responseInfo) {
    const headersSize = headers
        .map(({ key, value }) => `${key}: ${value}`)
        .join('\r\n').length;
    const headerSize = responseInfo ?
        `HTTP/X.X ${responseInfo.statusCode ?? ''} ${responseInfo.statusMessage ?? ''}\r\n\r\n`
            .length + headersSize
        : headersSize;
    return headerSize;
}
/**
 * Map IncomingHttpHeaders to key-values
 */
function incomingHeadersToKeyValues(headers) {
    return Object.entries(headers).flatMap(([key, value]) => {
        if (!value)
            return [];
        if (Array.isArray(value)) {
            return value.map((subvalue) => ({
                key,
                value: subvalue,
            }));
        }
        return [{ key, value }];
    });
}
/**
 * Map entries array to OutgoingHttpHeaders
 */
function entriesToOutgoingHeaders(headerEntries) {
    const headers = {};
    for (const [rawKey, value] of headerEntries) {
        // (case-insensitive and uses Node.js headers `string | string[]` approach)
        const key = rawKey.toLowerCase();
        const existing = headers[key];
        headers[key] =
            !existing ? value
                : Array.isArray(existing) ? [...existing, value]
                    : [existing, value];
    }
    return headers;
}
/**
 * Calculate timing phases from debug information
 */
function calculateTimings(start, debug) {
    const prepare = debug.timingStartTimer - start;
    const total = performance.now() - start;
    return {
        prepare,
        wait: debug.timings.socket,
        dns: debug.timings.lookup - debug.timings.socket,
        tcp: debug.timings.connect - debug.timings.lookup,
        secureHandshake: debug.timings.secureConnect ?
            debug.timings.secureConnect - debug.timings.connect
            : undefined,
        firstByte: debug.timings.secureConnect ?
            debug.timings.response - debug.timings.secureConnect
            : debug.timings.response - debug.timings.connect,
        download: debug.timings.end ?
            debug.timings.end - debug.timings.response
            : undefined,
        process: debug.timings.end ? total - (debug.timings.end + prepare) : undefined,
        total: debug.timings.end ? total : undefined,
    };
}
//# sourceMappingURL=http-platform.node.js.map