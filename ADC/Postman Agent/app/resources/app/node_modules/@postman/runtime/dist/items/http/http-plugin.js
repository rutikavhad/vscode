"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.http = http;
const runtime_models_1 = require("@postman/runtime.models");
const key_values_1 = require("../../lib/key-values");
const objects_1 = require("../../lib/objects");
const streams_1 = require("../../lib/streams");
const urls_1 = require("../../lib/urls");
const cookies_1 = require("../../plugins/cookies");
const http_body_1 = require("./http-body");
const http_headers_1 = require("./http-headers");
const http_url_1 = require("./http-url");
const unimplemented = {
    fetch() {
        throw new Error('HTTP `fetch` not implemented');
    },
};
/**
 * Built-in http-request support
 */
function http(options = {}) {
    const { platform = unimplemented } = options;
    return {
        name: 'http',
        items: {
            'http-request'(item, run) {
                (0, runtime_models_1.assertResourceType)(runtime_models_1.HTTPRequest, item);
                run.enqueue({
                    type: 'http:send-request',
                    payload: {
                        ...item.payload,
                        headers: item.payload.headers ?? [],
                        queryParams: item.payload.queryParams ?? [],
                        pathVariables: item.payload.pathVariables ?? [],
                        body: item.payload.body ?? { type: 'none' },
                        settings: item.payload.settings ?? {},
                    },
                });
            },
        },
        resolve: {
            'http:send-request'(event, run) {
                const url = (0, http_url_1.prepareURL)(event.payload);
                run.patch(event, (payload) => {
                    payload.url = url.href;
                });
            },
        },
        execute: {
            async 'http:send-request'(event, run) {
                const { host } = (0, urls_1.parseURL)(event.payload.url);
                const { body, contentType, contentSize } = await (0, http_body_1.prepareBody)(event.payload.body, {
                    contentType: (0, key_values_1.getValue)(event.payload.headers, 'content-type', {
                        caseInsensitive: true,
                    }),
                }, run.runtime.platform);
                const systemHeaders = (0, http_headers_1.prepareSystemHeaders)({
                    host,
                    contentType,
                    contentSize,
                });
                // Patch the event before execution to ensure what's emitted
                // includes all relevant information (especially for dry-run)
                run.patch(event, (payload) => {
                    (0, http_headers_1.applySystemHeaders)(payload, systemHeaders);
                });
                if (run.context.execution?.dryRun) {
                    return;
                }
                run.waitUntil(async () => {
                    try {
                        const channel = await platform.fetch({
                            url: event.payload.url,
                            method: event.payload.method,
                            headers: (0, http_headers_1.headerKeyValuesToEntries)(event.payload),
                            body,
                            settings: (0, objects_1.defaulted)(event.payload.settings, {
                                protocolVersion: 'http1',
                                strictSSL: run.context.tls?.strict ?? false,
                                followRedirects: run.context.http?.followRedirects ?? true,
                                maxRedirects: 10,
                                followOriginalHttpMethod: false,
                                followAuthorizationHeader: false,
                                removeRefererHeaderOnRedirect: false,
                                insecureHTTPParser: false,
                                disableUrlEncoding: false,
                                disableCookies: !run.context.cookies,
                                tlsPreferServerCiphers: false,
                                tlsDisabledProtocols: [],
                                tlsCipherSelection: [],
                                disabledSystemHeaders: [],
                                proxy: true,
                                certificate: null,
                                ca: null,
                                sslKeyLogFile: run.context.tls?.keyLog?.src ?? null,
                                timeout: run.context.http?.requestTimeoutMs ?? null,
                            }),
                        });
                        const controller = new AbortController();
                        run.subscribe((event) => {
                            if (event.type === 'run:cancel') {
                                controller.abort();
                            }
                        });
                        const readable = run.context.cookies ?
                            channel.readable.pipeThrough(new cookies_1.CookieConnectionTransform(run.context.cookies, channel.writable))
                            : channel.readable;
                        for await (const event of (0, streams_1.values)(readable, {
                            signal: controller.signal,
                        })) {
                            run.enqueue(event);
                        }
                    }
                    catch (error) {
                        const event = {
                            type: 'http:error',
                            payload: { error },
                        };
                        run.error(event);
                    }
                });
            },
        },
    };
}
//# sourceMappingURL=http-plugin.js.map