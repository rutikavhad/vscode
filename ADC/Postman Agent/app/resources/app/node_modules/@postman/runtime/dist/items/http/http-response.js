"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Response = void 0;
const streams_1 = require("../../lib/streams");
const typed_array_1 = require("../../lib/typed-array");
class Response {
    headers;
    ok;
    redirected;
    status;
    statusText;
    type;
    url;
    downloadedBytes;
    responseTime;
    body;
    constructor(run, events, start) {
        const { headers, statusCode, statusText } = start.payload;
        const sent = events.filter((event) => event.type === 'http:sent-request');
        const redirected = events.filter((event) => event.type === 'http:redirected');
        this.type = 'default';
        this.ok = statusCode >= 200 && statusCode <= 299;
        this.status = statusCode;
        this.statusText = statusText;
        this.headers = headers;
        this.redirected = redirected.length > 0;
        this.url = sent.at(-1)?.payload.url ?? '';
        this.body = new ReadableStream({
            start: async (controller) => {
                try {
                    for await (const event of run) {
                        switch (event.type) {
                            case 'http:received-response-data':
                                controller.enqueue(event.payload.data);
                                break;
                            case 'http:received-response-end':
                                this.downloadedBytes = event.payload.sizes.resourceBytes;
                                this.responseTime = event.payload.timings.total;
                                controller.close();
                                break;
                        }
                    }
                }
                catch (error) {
                    controller.error(error);
                }
            },
        });
    }
    get bodyUsed() {
        return this.body.locked;
    }
    async arrayBuffer() {
        const bytes = await this.bytes();
        return bytes.buffer;
    }
    // TODO blob
    async bytes() {
        const chunks = [];
        for await (const chunk of (0, streams_1.values)(this.body)) {
            chunks.push(chunk);
        }
        return (0, typed_array_1.combineInto)(Uint8Array, chunks);
    }
    // TODO clone
    // TODO formData
    async json() {
        const text = await this.text();
        return JSON.parse(text);
    }
    async text() {
        const data = await this.bytes();
        const text = new TextDecoder().decode(data);
        return text;
    }
    static async from(run) {
        const events = [];
        let start;
        for await (const event of run.values({ preventCancel: true })) {
            if (event.type === 'http:received-response-start') {
                start = event;
                break;
            }
            events.push(event);
        }
        if (!start) {
            throw new Error('No http:received-response-start event found');
        }
        return new Response(run, events, start);
    }
}
exports.Response = Response;
//# sourceMappingURL=http-response.js.map