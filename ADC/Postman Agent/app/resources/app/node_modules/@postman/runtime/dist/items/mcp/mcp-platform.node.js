"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.platform = void 0;
const types_js_1 = require("@modelcontextprotocol/sdk/types.js");
const rpc_1 = require("../../lib/rpc");
const ClientWrapper_1 = require("./utils/ClientWrapper");
const mcp_platform_transport_utils_1 = require("./utils/mcp-platform-transport-utils");
// Store clients by ID for each connected session
const clientToIdMap = new Map();
/**
 * Helper function to create a channel for MCP functions
 */
function createMCPOperationChannel(connectionId, event, operation, outputSchema) {
    return Promise.resolve(new rpc_1.Channel(async ({ incoming }) => {
        const clientWrapper = clientToIdMap.get(connectionId);
        if (!clientWrapper) {
            incoming.enqueue({
                type: 'mcp:error',
                payload: {
                    message: 'Client not connected',
                    source: 'connect',
                },
                timestamp: new Date().toISOString(),
            });
            return;
        }
        const client = clientWrapper.getClient();
        // Handle abort signal to emit aborted event
        const abortController = clientWrapper.resetAbortController(event, incoming);
        const startTime = performance.now();
        operation(client, abortController.signal)
            .then((result) => {
            incoming.enqueue({
                type: event.type.replace('request', 'response'),
                payload: {
                    data: {
                        ...result,
                    },
                    ...('params' in event.payload && event.payload.params?.name ?
                        { name: event.payload.params.name }
                        : {}), // Add tool or prompt name
                    responseTime: performance.now() - startTime,
                },
                timestamp: new Date().toISOString(),
                schema: outputSchema,
            });
        })
            .catch((error) => {
            if (error.name !== 'AbortError') {
                const errorSource = event.type.endsWith('disconnect') ? 'disconnect' : 'message';
                incoming.enqueue({
                    type: 'mcp:error',
                    payload: {
                        message: error instanceof Error ? error.message : 'Unknown error',
                        source: errorSource,
                    },
                    timestamp: new Date().toISOString(),
                });
            }
        });
    }));
}
exports.platform = {
    async connect({ connectionId, event }) {
        const { transport: transportInput } = event.payload;
        return new rpc_1.Channel(async ({ incoming }) => {
            let transport;
            try {
                if (transportInput === 'sse') {
                    transport = (0, mcp_platform_transport_utils_1.generateHTTPTransport)(event.payload, 'http', incoming);
                }
                else if (transportInput === 'stdio') {
                    transport = (0, mcp_platform_transport_utils_1.generateStdioTransport)(event.payload);
                }
                else {
                    // TODO: do we have an error syntax we'd like to use
                    throw new Error(`Invalid transport: ${transportInput}`);
                }
            }
            catch (err) {
                return incoming.error(err);
            }
            const notificationHandler = (notification) => {
                incoming.enqueue({
                    type: 'mcp:received-notification',
                    payload: {
                        notification,
                    },
                    timestamp: new Date().toISOString(),
                    schema: types_js_1.NotificationSchema,
                });
            };
            const configureClientNotifications = (0, mcp_platform_transport_utils_1.updateNotificationHandlers)(mcp_platform_transport_utils_1.NOTIFICATION_SCHEMAS, notificationHandler);
            // Holds the pending elicitation and sampling requests for this client
            const pendingRequests = new Map();
            const elicitationHandler = (0, mcp_platform_transport_utils_1.createServerRequestHandler)(pendingRequests, incoming, 'mcp:request-elicitation', types_js_1.ElicitRequestSchema);
            const configureClientElicitation = (client) => {
                client.setRequestHandler(types_js_1.ElicitRequestSchema, elicitationHandler);
            };
            const samplingHandler = (0, mcp_platform_transport_utils_1.createServerRequestHandler)(pendingRequests, incoming, 'mcp:request-sampling', types_js_1.CreateMessageRequestSchema);
            const configureClientSampling = (client) => {
                client.setRequestHandler(types_js_1.CreateMessageRequestSchema, samplingHandler);
            };
            let client = (0, mcp_platform_transport_utils_1.createClient)([
                configureClientNotifications,
                configureClientElicitation,
                configureClientSampling,
            ]);
            const clientWrapper = new ClientWrapper_1.ClientWrapper({ client, pendingRequests });
            const abortController = clientWrapper.resetAbortController(event, incoming);
            clientToIdMap.set(connectionId, clientWrapper);
            const statusCodeRegex = /http\s+401/i;
            /**
             * Connection flow:
             * 1. Try to connect using the transport
             * 2. If successful, emit the connected event and start to request capabilities from the server
             * 3. If unsuccessful, check the reason. If it is http and not a 401 try close the client and try again using the sse transport
             * 4. If unsuccessful, emit the error event
             */
            await client
                .connect(transport, { signal: abortController.signal })
                .catch(async (err) => {
                // First fallback: close client and potentially retry with SSE
                await client.close();
                if (transportInput === 'stdio') {
                    if (err instanceof Error && statusCodeRegex.test(err.message)) {
                        err.code = 401;
                    }
                    throw err;
                }
                // Retry with SSE transport
                const sseRetryTransport = (0, mcp_platform_transport_utils_1.generateHTTPTransport)(event.payload, 'sse', incoming);
                client = (0, mcp_platform_transport_utils_1.createClient)([
                    configureClientNotifications,
                    configureClientElicitation,
                    configureClientSampling,
                ]);
                clientToIdMap.set(connectionId, new ClientWrapper_1.ClientWrapper({ client, pendingRequests, abortController }));
                await client.connect(sseRetryTransport, {
                    signal: abortController.signal,
                });
            })
                .catch(async (err) => {
                // Second fallback: handle SSE failure
                await client.close();
                if (err instanceof Error && statusCodeRegex.test(err.message)) {
                    err.code = 401;
                }
                throw err;
            })
                .catch((err) => {
                // Final error handling
                return incoming.error(err);
            });
            incoming.enqueue({
                type: 'mcp:response-connect',
                payload: {
                    connectionStatus: 'connected',
                    serverCapabilities: client.getServerCapabilities() || {},
                },
                schema: types_js_1.ServerCapabilitiesSchema,
                timestamp: new Date().toISOString(),
            });
        });
    },
    async disconnect({ connectionId, event }) {
        return createMCPOperationChannel(connectionId, event, async (client) => {
            await client.close();
            clientToIdMap.delete(connectionId);
            return { message: 'Disconnected from MCP server' };
        });
    },
    async cancel({ connectionId }) {
        const abortController = clientToIdMap
            .get(connectionId)
            ?.getAbortController();
        return new rpc_1.Channel(async ({ incoming }) => {
            if (!abortController) {
                incoming.enqueue({
                    type: 'mcp:error',
                    payload: {
                        message: 'Connection not found',
                        source: 'message',
                    },
                    timestamp: new Date().toISOString(),
                });
                return;
            }
            abortController.abort('Operation cancelled');
        });
    },
    async listTools({ connectionId, event }) {
        return createMCPOperationChannel(connectionId, event, (mcpClient, signal) => mcpClient.listTools(event.payload.params, { signal }), types_js_1.ListToolsResultSchema);
    },
    async callTool({ connectionId, event }) {
        return createMCPOperationChannel(connectionId, event, (mcpClient, signal) => mcpClient.callTool(event.payload.params, undefined, { signal }), types_js_1.CallToolResultSchema);
    },
    async listPrompts({ connectionId, event }) {
        return createMCPOperationChannel(connectionId, event, (mcpClient, signal) => mcpClient.listPrompts(event.payload.params, { signal }), types_js_1.ListPromptsResultSchema);
    },
    async getPrompt({ connectionId, event }) {
        return createMCPOperationChannel(connectionId, event, (mcpClient, signal) => mcpClient.getPrompt(event.payload.params, { signal }), types_js_1.GetPromptResultSchema);
    },
    async listResources({ connectionId, event }) {
        return createMCPOperationChannel(connectionId, event, (mcpClient, signal) => mcpClient.listResources(event.payload.params, { signal }), types_js_1.ListResourcesResultSchema);
    },
    async listResourceTemplates({ connectionId, event }) {
        return createMCPOperationChannel(connectionId, event, (mcpClient, signal) => mcpClient.listResourceTemplates(event.payload.params, { signal }), types_js_1.ListResourceTemplatesResultSchema);
    },
    async readResource({ connectionId, event }) {
        return createMCPOperationChannel(connectionId, event, (mcpClient, signal) => mcpClient.readResource(event.payload.params, { signal }), types_js_1.ReadResourceResultSchema);
    },
    async subscribeResource({ connectionId, event }) {
        return createMCPOperationChannel(connectionId, event, (mcpClient, signal) => mcpClient.subscribeResource(event.payload.params, { signal }));
    },
    async unsubscribeResource({ connectionId, event }) {
        return createMCPOperationChannel(connectionId, event, (mcpClient, signal) => mcpClient.unsubscribeResource(event.payload.params, { signal }));
    },
    async resolvePendingRequest({ connectionId, event }) {
        return new rpc_1.Channel(async ({ incoming }) => {
            const pendingRequest = clientToIdMap
                .get(connectionId)
                ?.getPendingRequests()
                ?.get(event.payload.relatedRequestId.toString());
            if (!pendingRequest) {
                incoming.enqueue({
                    type: 'mcp:error',
                    payload: {
                        message: 'Pending request not found',
                        source: 'message',
                    },
                    timestamp: new Date().toISOString(),
                });
                return;
            }
            // Remove the pending entry and resolve
            clientToIdMap
                .get(connectionId)
                ?.getPendingRequests()
                ?.delete(event.payload.relatedRequestId.toString());
            if (event.type === 'mcp:response-sampling' && event.payload.isRejected) {
                pendingRequest.reject(new Error('Sampling request rejected'));
                return;
            }
            event.payload.result && pendingRequest.resolve(event.payload.result);
        });
    },
    async getServerCapabilities({ connectionId, event }) {
        return createMCPOperationChannel(connectionId, event, async (client, signal) => {
            const results = await Promise.allSettled([
                client.listTools(undefined, { signal }),
                client.listPrompts(undefined, { signal }),
                client.listResources(undefined, { signal }),
            ]);
            const [toolsResult, promptsResult, resourcesResult] = results;
            const data = {
                ...(toolsResult.status === 'fulfilled' ?
                    { tools: toolsResult.value }
                    : {}),
                ...(promptsResult.status === 'fulfilled' ?
                    { prompts: promptsResult.value }
                    : {}),
                ...(resourcesResult.status === 'fulfilled' ?
                    { resources: resourcesResult.value }
                    : {}),
            };
            return data;
        }, types_js_1.ServerCapabilitiesSchema);
    },
};
//# sourceMappingURL=mcp-platform.node.js.map