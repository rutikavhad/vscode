"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mcp = mcp;
const runtime_models_1 = require("@postman/runtime.models");
const platform_1 = require("../../lib/platform");
const streams_1 = require("../../lib/streams");
const unimplemented = {
    connect() {
        throw new Error('MCP `connect` not implemented');
    },
    disconnect() {
        throw new Error('MCP `disconnect` not implemented');
    },
    cancel() {
        throw new Error('MCP `cancel` not implemented');
    },
    listTools() {
        throw new Error('MCP `listTools` not implemented');
    },
    callTool() {
        throw new Error('MCP `callTool` not implemented');
    },
    listPrompts() {
        throw new Error('MCP `listPrompts` not implemented');
    },
    getPrompt() {
        throw new Error('MCP `getPrompt` not implemented');
    },
    listResources() {
        throw new Error('MCP `listResources` not implemented');
    },
    listResourceTemplates() {
        throw new Error('MCP `listResourceTemplates` not implemented');
    },
    readResource() {
        throw new Error('MCP `readResource` not implemented');
    },
    subscribeResource() {
        throw new Error('MCP `subscribeResource` not implemented');
    },
    unsubscribeResource() {
        throw new Error('MCP `unsubscribeResource` not implemented');
    },
    resolvePendingRequest() {
        throw new Error('MCP `resolvePendingRequest` not implemented');
    },
    getServerCapabilities() {
        throw new Error('MCP `getServerCapabilities` not implemented');
    },
};
const MCP_ERROR = 'mcp:error';
function mcp(options = {}) {
    const { platform = unimplemented } = options;
    return {
        name: 'mcp',
        items: {
            ['mcp-request'](item, run) {
                (0, runtime_models_1.assertResourceType)(runtime_models_1.MCPRequest, item);
                const parsedMessage = JSON.parse(item.payload.message || '{}');
                run.enqueue({
                    type: 'mcp:request-connect',
                    payload: {
                        ...item.payload,
                        ...parsedMessage,
                    },
                    timestamp: new Date().toISOString(),
                });
            },
        },
        execute: {
            async 'mcp:request-connect'(event, run) {
                if (run.context.execution?.dryRun) {
                    return;
                }
                if (event.payload.transport === 'sse' && event.payload.url) {
                    try {
                        new URL(event.payload.url);
                    }
                    catch (error) {
                        run.error({
                            type: 'mcp:error',
                            payload: {
                                message: error instanceof Error ? error.message : 'Invalid URL',
                                source: 'mcp-request',
                            },
                        });
                        return;
                    }
                }
                run.waitUntil(async () => {
                    try {
                        const channel = await platform.connect({
                            connectionId: run.id,
                            event: event,
                        });
                        // Handle incoming events from the connection
                        const controller = new AbortController();
                        run.subscribe((event) => {
                            if (event.type === 'run:cancel') {
                                controller.abort();
                            }
                        });
                        // Forward events to the run
                        try {
                            for await (const mcpEvent of (0, streams_1.values)(channel.readable)) {
                                run.enqueue(mcpEvent);
                            }
                        }
                        catch (channelError) {
                            // Handle errors from the channel itself
                            run.error({
                                type: 'mcp:error',
                                payload: {
                                    message: channelError instanceof Error ?
                                        channelError.message
                                        : 'Channel error',
                                    source: 'connect',
                                },
                            });
                        }
                    }
                    catch (error) {
                        run.emit({
                            type: 'mcp:error',
                            payload: {
                                message: error instanceof Error ?
                                    error.message
                                    : 'MCP operation failed',
                                source: 'connect',
                            },
                            timestamp: new Date().toISOString(),
                        });
                    }
                });
            },
            async 'mcp:request-disconnect'(event, run) {
                return (0, platform_1.forwardPlatformEventsToRun)({
                    event,
                    run,
                    errorType: MCP_ERROR,
                    callPlatform: async () => await platform.disconnect({ connectionId: run.id, event }),
                });
            },
            async 'mcp:cancel'(event, run) {
                return (0, platform_1.forwardPlatformEventsToRun)({
                    event,
                    run,
                    errorType: MCP_ERROR,
                    callPlatform: async () => await platform.cancel({ connectionId: run.id }),
                });
            },
            async 'mcp:request-list-tools'(event, run) {
                return (0, platform_1.forwardPlatformEventsToRun)({
                    event,
                    run,
                    errorType: MCP_ERROR,
                    callPlatform: async () => await platform.listTools({ connectionId: run.id, event }),
                });
            },
            async 'mcp:request-call-tool'(event, run) {
                return (0, platform_1.forwardPlatformEventsToRun)({
                    event,
                    run,
                    errorType: MCP_ERROR,
                    callPlatform: async () => await platform.callTool({ connectionId: run.id, event }),
                });
            },
            async 'mcp:request-list-prompts'(event, run) {
                return (0, platform_1.forwardPlatformEventsToRun)({
                    event,
                    run,
                    errorType: MCP_ERROR,
                    callPlatform: async () => await platform.listPrompts({ connectionId: run.id, event }),
                });
            },
            async 'mcp:request-get-prompt'(event, run) {
                return (0, platform_1.forwardPlatformEventsToRun)({
                    event,
                    run,
                    errorType: MCP_ERROR,
                    callPlatform: async () => await platform.getPrompt({ connectionId: run.id, event }),
                });
            },
            async 'mcp:request-list-resources'(event, run) {
                return (0, platform_1.forwardPlatformEventsToRun)({
                    event,
                    run,
                    errorType: MCP_ERROR,
                    callPlatform: async () => await platform.listResources({ connectionId: run.id, event }),
                });
            },
            async 'mcp:request-read-resource'(event, run) {
                return (0, platform_1.forwardPlatformEventsToRun)({
                    event,
                    run,
                    errorType: MCP_ERROR,
                    callPlatform: async () => await platform.readResource({ connectionId: run.id, event }),
                });
            },
            async 'mcp:request-subscribe-resource'(event, run) {
                return (0, platform_1.forwardPlatformEventsToRun)({
                    event,
                    run,
                    errorType: MCP_ERROR,
                    callPlatform: async () => await platform.subscribeResource({ connectionId: run.id, event }),
                });
            },
            async 'mcp:request-unsubscribe-resource'(event, run) {
                return (0, platform_1.forwardPlatformEventsToRun)({
                    event,
                    run,
                    errorType: MCP_ERROR,
                    callPlatform: async () => await platform.unsubscribeResource({ connectionId: run.id, event }),
                });
            },
            async 'mcp:response-elicitation'(event, run) {
                return (0, platform_1.forwardPlatformEventsToRun)({
                    event,
                    run,
                    errorType: MCP_ERROR,
                    callPlatform: async () => await platform.resolvePendingRequest({
                        connectionId: run.id,
                        event,
                    }),
                });
            },
            async 'mcp:response-sampling'(event, run) {
                return (0, platform_1.forwardPlatformEventsToRun)({
                    event,
                    run,
                    errorType: MCP_ERROR,
                    callPlatform: async () => await platform.resolvePendingRequest({
                        connectionId: run.id,
                        event,
                    }),
                });
            },
            async 'mcp:request-server-capabilities'(event, run) {
                return (0, platform_1.forwardPlatformEventsToRun)({
                    event,
                    run,
                    errorType: MCP_ERROR,
                    callPlatform: async () => await platform.getServerCapabilities({
                        connectionId: run.id,
                        event,
                    }),
                });
            },
        },
    };
}
//# sourceMappingURL=mcp-plugin.js.map