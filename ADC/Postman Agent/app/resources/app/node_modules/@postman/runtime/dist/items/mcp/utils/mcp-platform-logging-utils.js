"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.loggingMiddleware = loggingMiddleware;
exports.streamLoggingMiddleware = streamLoggingMiddleware;
const middleware_js_1 = require("@modelcontextprotocol/sdk/client/middleware.js");
// Create a history object with execution data structure for the console.
function createHistory(initialEntry) {
    const history = {
        execution: {
            data: [],
            sessions: {
                [crypto.randomUUID()]: {},
            },
        },
    };
    return initialEntry ?
        addToHistory(history, initialEntry.request, initialEntry.response)
        : history;
}
function addToHistory(history, request, response) {
    const sessionId = Object.keys(history.execution.sessions)[0] ?? '';
    history.execution.data.push({
        request,
        response,
        session: { id: sessionId, reused: false },
    });
    return history;
}
// Helper to take a Headers object and convert them to Postman structured headers.
function headersToArray(headers) {
    const result = [];
    headers.forEach((value, key) => {
        result.push({ key, value });
    });
    return result;
}
// Builds a request object from a RequestInit object and a URL for Postman Console logging.
function buildRequest(init, url) {
    return {
        headers: (() => {
            if (init?.headers && init.headers instanceof Headers) {
                return headersToArray(init.headers);
            }
            if (typeof init?.headers === 'object' && init.headers !== null) {
                return Object.entries(init.headers).map(([key, value]) => ({
                    key,
                    value,
                }));
            }
            if (Array.isArray(init?.headers)) {
                return init.headers;
            }
            return [];
        })(),
        method: init?.method ?? 'GET',
        url: url || '',
        ...(init?.body ? { body: init.body.toString() } : {}),
    };
}
// Builds a response object from a Response object and a response time for Postman Console logging.
function buildResponse(response, responseTime, body) {
    return {
        headers: headersToArray(response.headers),
        // Console uses both code and statusCode
        code: response.status,
        statusCode: response.status,
        responseTime,
        status: response.statusText,
        redirected: response.redirected,
        type: response.type,
        ...(body ? { body } : {}),
        contentInfo: {
            charset: 'utf-8',
        },
    };
}
// Get location header with case-insensitive fallback.
function getLocationHeader(headers) {
    return headers.get('Location') ?? headers.get('location');
}
function resolveLocation(location, input) {
    if (typeof location === 'string' && location.startsWith('/')) {
        const inputObj = typeof input === 'string' ? new URL(input) : input;
        return inputObj.protocol + '//' + inputObj.host + location;
    }
    return location;
}
/**
 * Middleware for non-streaming HTTP requests. This sits over the fetch function and enqueues HTTP
 * requests and responses to the Postman Console.
 */
function loggingMiddleware(incoming) {
    return (0, middleware_js_1.createMiddleware)(async (next, input, init) => {
        // Used when timeout is 0 or undefined
        const MAX_REDIRECTS = 4;
        const history = createHistory();
        let request = buildRequest(init, input instanceof URL ? input.href : input);
        let originalResponse = await next(input, { ...init, redirect: 'manual' });
        const start = performance.now();
        let step = performance.now();
        let redirectCount = 0;
        // Handle redirects
        while (originalResponse.status >= 300 &&
            originalResponse.status < 400 &&
            redirectCount < MAX_REDIRECTS) {
            const location = getLocationHeader(originalResponse.headers);
            if (!location)
                break;
            // Log the redirect response
            const response = originalResponse.clone();
            addToHistory(history, request, buildResponse(response, performance.now() - step));
            step = performance.now();
            // Prepare for next request
            const resolvedLocation = resolveLocation(location, input);
            request = buildRequest(init, resolvedLocation);
            originalResponse = await next(new URL(location), {
                ...init,
                redirect: 'manual',
            });
            redirectCount++;
        }
        // Handle final response
        const response = originalResponse.clone();
        const reader = response.body
            ?.pipeThrough(new TextDecoderStream())
            .getReader();
        reader
            ?.read()
            .then(({ value }) => {
            const finalResponse = buildResponse(response, performance.now() - start, value);
            incoming.enqueue({
                type: 'mcp:log-http',
                payload: {
                    request,
                    response: finalResponse,
                    history: addToHistory(history, request, finalResponse),
                },
                timestamp: new Date().toISOString(),
            });
        })
            .catch((err) => {
            incoming.enqueue({
                type: 'mcp:error',
                payload: {
                    message: `[mcp:logging-utils~loggingMiddleware] had an error while reading the response: ${err}`,
                    source: 'message',
                },
                timestamp: new Date().toISOString(),
            });
        });
        return originalResponse;
    });
}
/**
 * Middleware for streaming HTTP requests. This sits over the fetch function and enqueues HTTP
 * requests and responses to the Postman Console.
 */
function streamLoggingMiddleware(incoming) {
    return (0, middleware_js_1.createMiddleware)(async (next, input, init) => {
        const start = performance.now();
        const originalResponse = await next(input, init);
        const signal = init?.signal ?? undefined;
        // Assuming method is POST if it is undefined. This is only the case when using the SSE transport.
        const request = buildRequest({ ...init, method: init?.method ?? 'POST' }, input instanceof URL ? input.href : input);
        const response = originalResponse.clone();
        const reader = response.body
            ?.pipeThrough(new TextDecoderStream(), { signal })
            .getReader();
        let body = '';
        const readStream = async () => {
            if (!reader)
                return;
            try {
                while (!signal?.aborted) {
                    const { value, done } = await reader.read();
                    if (value) {
                        body += value;
                    }
                    if (done) {
                        break;
                    }
                }
            }
            catch (error) {
                // An abort error is thrown when the client is closed.
                // We emit the event here assuming the connection is closed.
                if (error instanceof Error && error.name === 'AbortError') {
                    const end = performance.now();
                    const finalResponse = buildResponse(response, end - start, body);
                    const history = createHistory({ request, response: finalResponse });
                    incoming.enqueue({
                        type: 'mcp:log-http',
                        payload: {
                            request,
                            response: finalResponse,
                            history: history,
                        },
                        timestamp: new Date().toISOString(),
                    });
                }
            }
            finally {
                reader.releaseLock();
            }
        };
        readStream().catch(() => {
            // no-op
        });
        return originalResponse;
    });
}
//# sourceMappingURL=mcp-platform-logging-utils.js.map