"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.NOTIFICATION_SCHEMAS = void 0;
exports.createClient = createClient;
exports.generateStdioTransport = generateStdioTransport;
exports.generateHTTPTransport = generateHTTPTransport;
exports.updateNotificationHandlers = updateNotificationHandlers;
exports.createServerRequestHandler = createServerRequestHandler;
const index_js_1 = require("@modelcontextprotocol/sdk/client/index.js");
const middleware_js_1 = require("@modelcontextprotocol/sdk/client/middleware.js");
const sse_js_1 = require("@modelcontextprotocol/sdk/client/sse.js");
const stdio_js_1 = require("@modelcontextprotocol/sdk/client/stdio.js");
const streamableHttp_js_1 = require("@modelcontextprotocol/sdk/client/streamableHttp.js");
const types_js_1 = require("@modelcontextprotocol/sdk/types.js");
const tls = __importStar(require("tls"));
const undici_1 = require("undici");
const promises_1 = require("../../../lib/promises");
const mcp_platform_logging_utils_1 = require("./mcp-platform-logging-utils");
function createClient(callbacks = []) {
    const client = new index_js_1.Client({
        name: 'Postman Client',
        version: '1.0.0',
    }, {
        capabilities: {
            elicitation: {},
            sampling: {},
        },
    });
    // Used for any post-creation callbacks
    for (const callback of callbacks) {
        callback(client);
    }
    return client;
}
/**
 * Helper function to convert Postman header/env arrays to key/value objects.
 * @param entries - headers or env from a MCP connect request
 * @returns key/value object
 */
function entriesToRecord(entries) {
    const record = {};
    entries?.forEach(({ key, value, disabled }) => {
        if (!disabled) {
            record[key] = value;
        }
    });
    return record;
}
// Both transport functions might need to be added to the platform to have access to the channel.
// Going to try and get this to work without the shellEnv shenanigans for now and without the custom transport classes for now.
function generateStdioTransport(request) {
    const { command, args, env: envKeyValueArray } = request;
    const envRecord = entriesToRecord(envKeyValueArray);
    const env = {
        ...(0, stdio_js_1.getDefaultEnvironment)(),
        ...envRecord,
    };
    return new stdio_js_1.StdioClientTransport({
        command,
        args,
        env,
    });
}
function buildHTTPAgent(options) {
    const { proxy, secureContext, strictSSL } = options;
    const connectOptions = {
        secureContext,
        rejectUnauthorized: strictSSL,
    };
    return typeof proxy === 'string' && proxy.length > 0 ?
        new undici_1.ProxyAgent({ uri: proxy, requestTls: connectOptions })
        : new undici_1.Agent({ connect: connectOptions });
}
function generateHTTPTransport(request, transport, incoming) {
    // Might move the url parsing to early in the run. That way can reuse some validate URL logic.
    const { url: urlInput, headers: headersKeyValueArray, settings } = request;
    const headers = entriesToRecord(headersKeyValueArray);
    const { strictSSL = false, proxy, certificate, ca } = settings;
    let url;
    try {
        url = new URL(urlInput);
    }
    catch (error) {
        throw new Error(`Invalid URL: ${urlInput}`);
    }
    const cert = certificate?.cert ? Buffer.from(certificate.cert) : undefined;
    const key = certificate?.key ? Buffer.from(certificate.key) : undefined;
    const pfx = certificate?.pfx ? Buffer.from(certificate.pfx) : undefined;
    const secureContext = certificate ?
        tls.createSecureContext({
            cert,
            key,
            pfx,
            passphrase: certificate?.passphrase,
        })
        : undefined;
    secureContext?.context.addCACert(ca);
    const agent = buildHTTPAgent({
        proxy,
        secureContext: certificate ?
            {
                context: secureContext,
            }
            : undefined,
        strictSSL,
    });
    const requestInit = {
        dispatcher: agent,
        ...(headers && { headers }),
    };
    const clientTransport = transport === 'http' ?
        new streamableHttp_js_1.StreamableHTTPClientTransport(url, {
            requestInit,
            fetch: (0, middleware_js_1.applyMiddlewares)((0, mcp_platform_logging_utils_1.loggingMiddleware)(incoming))(async (url, init) => {
                let response = await fetch(url, init);
                // Only updating transport here. The rest of the redirect logic lives in the logger.
                if (response.status >= 300 && response.status < 400) {
                    let location = response.headers.get('Location');
                    if (location) {
                        if (location.startsWith('/')) {
                            location = (url instanceof URL ? url.host : url) + location;
                        }
                        // @ts-expect-error this is a private property but need to do this to update the url if there was a redirect
                        clientTransport._url = location;
                    }
                }
                return response;
            }),
        })
        : new sse_js_1.SSEClientTransport(url, {
            eventSourceInit: {
                fetch: (0, middleware_js_1.applyMiddlewares)((0, mcp_platform_logging_utils_1.streamLoggingMiddleware)(incoming))((url, init) => {
                    return fetch(url, {
                        ...init,
                        headers: {
                            ...init?.headers,
                            // If a user passes an Accept header without text/event-stream, the connection will break, but that's expected.
                            Accept: 'text/event-stream',
                            ...headers,
                        },
                        // I can't remember if for SSE we can't reuse the same agent for the stream and requests.
                        // @ts-expect-error - there seems to be some mismatch between undici and undici-types
                        dispatcher: buildHTTPAgent({
                            proxy,
                            secureContext: certificate ?
                                {
                                    context: secureContext,
                                }
                                : undefined,
                            strictSSL,
                        }),
                    });
                }),
            },
            requestInit,
            fetch: (0, middleware_js_1.applyMiddlewares)((0, mcp_platform_logging_utils_1.loggingMiddleware)(incoming))(fetch),
        });
    return clientTransport;
}
exports.NOTIFICATION_SCHEMAS = [
    types_js_1.CancelledNotificationSchema,
    types_js_1.LoggingMessageNotificationSchema,
    types_js_1.ResourceUpdatedNotificationSchema,
    types_js_1.ResourceListChangedNotificationSchema,
    types_js_1.ToolListChangedNotificationSchema,
    types_js_1.PromptListChangedNotificationSchema,
];
function updateNotificationHandlers(schemas, handler) {
    return (client) => {
        for (const schema of schemas) {
            client.setNotificationHandler(schema, handler);
        }
    };
}
/**
 * Creates a generic request handler for server-initiated requests (elicitation, sampling, etc.)
 * @param pendingRequests - Map to store pending promises
 * @param incoming - Readable stream controller to enqueue events
 * @param eventType - Type of the event to enqueue
 * @param schema - Zod schema for validation
 * @returns Handler function for the request
 */
function createServerRequestHandler(pendingRequests, incoming, eventType, schema) {
    return (request, extra) => {
        const { requestId } = extra;
        const requestPromise = (0, promises_1.promiseWithResolvers)();
        pendingRequests.set(requestId.toString(), requestPromise);
        incoming.enqueue({
            type: eventType,
            payload: {
                data: {
                    id: requestId,
                    ...request,
                },
            },
            timestamp: new Date().toISOString(),
            schema,
        });
        return requestPromise.promise;
    };
}
//# sourceMappingURL=mcp-platform-transport-utils.js.map