"use strict";
/// <reference lib="dom" />
Object.defineProperty(exports, "__esModule", { value: true });
exports.CLOSED = exports.CLOSING = exports.OPEN = exports.CONNECTING = void 0;
exports.createWebSocketConstructor = createWebSocketConstructor;
const key_values_1 = require("../../lib/key-values");
const match_event_1 = require("../../lib/match-event");
exports.CONNECTING = 0;
exports.OPEN = 1;
exports.CLOSING = 2;
exports.CLOSED = 3;
function createWebSocketConstructor(run, item, context, onCreated) {
    class WebSocketTransport extends EventTarget {
        readyState = exports.CONNECTING;
        onopen = null;
        onmessage = null;
        onerror = null;
        onclose = null;
        url = '';
        protocol = '';
        extensions = '';
        binaryType = 'blob';
        bufferedAmount = 0;
        CONNECTING = exports.CONNECTING;
        OPEN = exports.OPEN;
        CLOSING = exports.CLOSING;
        CLOSED = exports.CLOSED;
        static CONNECTING = exports.CONNECTING;
        static OPEN = exports.OPEN;
        static CLOSING = exports.CLOSING;
        static CLOSED = exports.CLOSED;
        #connection;
        constructor(url, protocols) {
            super();
            const headers = withProtocols(item?.payload.headers ?? [], protocols);
            this.#connection = run.execute({
                type: 'ws-raw-request',
                payload: {
                    url: url.toString(),
                    queryParams: item?.payload.queryParams ?? [],
                    headers,
                    settings: item?.payload.settings ?? {},
                },
                children: item?.children,
                extensions: item?.extensions,
            }, context);
            this.#connection.subscribe((0, match_event_1.matchEvent)({
                'websocket:opened': () => {
                    this.readyState = exports.OPEN;
                    const event = new Event('open');
                    this.dispatchEvent(event);
                    this.onopen?.(event);
                },
                'websocket:received-message': (event) => {
                    const message = new MessageEvent('message', {
                        data: event.payload.content,
                    });
                    this.dispatchEvent(message);
                    this.onmessage?.(message);
                },
                'websocket:closed': (event) => {
                    this.#close(event.payload);
                },
                'websocket:error': () => {
                    this.#error();
                },
                'run:error': () => {
                    this.#error();
                },
            }));
            onCreated?.(this);
        }
        send(data) {
            if (this.readyState === exports.CONNECTING) {
                throw new Error("Failed to execute 'send' on 'WebSocket': Still in CONNECTING state.");
            }
            if (this.readyState === exports.CLOSING || this.readyState === exports.CLOSED) {
                throw new Error('WebSocket is already in CLOSING or CLOSED state.');
            }
            (async () => {
                const size = data instanceof Blob ? data.size
                    : ArrayBuffer.isView(data) ? data.byteLength
                        : typeof data === 'string' ? data.length
                            : data.byteLength;
                this.bufferedAmount += size;
                const content = data instanceof Blob ? await data.bytes()
                    : typeof data === 'string' ? data
                        : new Uint8Array(ArrayBuffer.isView(data) ?
                            data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength)
                            : data);
                this.#connection.enqueue({
                    type: 'websocket:send-message',
                    payload: typeof content === 'string' ?
                        { type: 'text', content }
                        : { type: 'bytes', content },
                });
            })().catch((error) => {
                this.#connection.error(error);
            });
        }
        close(code, reason) {
            if (this.readyState !== exports.OPEN) {
                return;
            }
            this.readyState = exports.CLOSING;
            this.#connection.enqueue({
                type: 'websocket:close',
                payload: { code, reason },
            });
        }
        #error = () => {
            const error = new Event('error');
            this.dispatchEvent(error);
            this.onerror?.(error);
            // (from https://github.com/Luka967/websocket-close-codes, 1011 = Internal Error)
            this.#close({ code: 1011 });
        };
        #close = (details) => {
            const { code = 1000, reason = '', wasClean = true } = details;
            this.readyState = exports.CLOSED;
            const closed = closeEvent({ code, reason, wasClean });
            this.dispatchEvent(closed);
            this.onclose?.(closed);
        };
    }
    return WebSocketTransport;
}
function closeEvent(details) {
    const event = new Event('close');
    Object.assign(event, details);
    return event;
}
function withProtocols(headers, protocols) {
    const userProtocolHeader = (0, key_values_1.findKeyValue)(headers, 'sec-websocket-protocol', {
        caseInsensitive: true,
    });
    const userProtocols = userProtocolHeader?.value
        .split(',')
        .map((protocol) => protocol.trim());
    // Prefer user-defined protocol (via header) over system protocol (via direct WebSocket usage)
    const systemProtocols = typeof protocols === 'string' ? [protocols] : (protocols ?? []);
    const connectionProtocols = userProtocols ?? systemProtocols;
    // Remove existing and add set value
    const withProtocol = headers.filter((header) => header.key.toLowerCase() !== 'sec-websocket-protocol');
    withProtocol.push({
        key: 'sec-websocket-protocol',
        value: connectionProtocols.join(','),
    });
    return withProtocol;
}
//# sourceMappingURL=create-websocket.js.map