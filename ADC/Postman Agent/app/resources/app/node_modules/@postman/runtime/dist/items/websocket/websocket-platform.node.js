"use strict";
/// <reference types="node" />
Object.defineProperty(exports, "__esModule", { value: true });
exports.platform = void 0;
const runtime_websocket_client_1 = require("@postman/runtime.websocket-client");
const key_values_1 = require("../../lib/key-values");
const rpc_1 = require("../../lib/rpc");
const streams_1 = require("../../lib/streams");
exports.platform = {
    async connect(url, options) {
        return new rpc_1.Channel(async ({ incoming, outgoing }) => {
            const connection = new runtime_websocket_client_1.Connection({
                url,
                protocols: options.protocols,
                headers: (0, key_values_1.keyValuesToObject)(options.headers ?? [], {
                    approach: 'combine',
                }),
                connectOptions: {
                    handshakeTimeout: options.handshakeTimeout,
                    maxPayload: options.maxPayload,
                    followRedirects: options.followRedirects,
                },
                reconnectOptions: {
                    retryCount: options.retryCount,
                    retryDelay: options.retryDelay,
                },
                tlsOptions: {
                    rejectUnauthorized: options.rejectUnauthorized,
                    secureContext: {
                        cert: options.cert ? Buffer.from(options.cert) : undefined,
                        key: options.key ? Buffer.from(options.key) : undefined,
                        pfx: options.pfx ? Buffer.from(options.pfx) : undefined,
                        passphrase: options.passphrase,
                        ca: options.ca ? Buffer.from(options.ca) : undefined,
                    },
                },
            });
            connection.addListener('open', ({ request, response }) => {
                incoming.enqueue({
                    type: 'open',
                    payload: {
                        request: request ?
                            {
                                method: request.method,
                                url: request.href,
                                headers: request.headers,
                            }
                            : undefined,
                        response: response ?
                            {
                                statusCode: response.statusCode,
                                statusText: response.statusMessage,
                                headers: response.headers,
                            }
                            : undefined,
                    },
                });
            });
            connection.addListener('reconnect', ({ attempt, timeout }) => {
                incoming.enqueue({
                    type: 'reconnect',
                    payload: { attempt, timeout },
                });
            });
            connection.addListener('error', ({ error, handshakeRequest, handshakeResponse }) => {
                incoming.enqueue({
                    type: 'error',
                    payload: {
                        error: {
                            message: error.message,
                        },
                        request: handshakeRequest ?
                            {
                                method: handshakeRequest.method,
                                url: handshakeRequest.href,
                                headers: handshakeRequest.headers,
                            }
                            : undefined,
                        response: handshakeResponse ?
                            {
                                statusCode: handshakeResponse.statusCode,
                                statusText: handshakeResponse.statusMessage,
                                headers: handshakeResponse.headers,
                            }
                            : undefined,
                    },
                });
            });
            connection.addListener('end', ({ code, reason, aborted }) => {
                incoming.enqueue({
                    type: 'end',
                    payload: {
                        code,
                        reason,
                        aborted,
                    },
                });
                incoming.close();
            });
            connection.addListener('message', ({ message }) => {
                incoming.enqueue({
                    type: 'message',
                    payload: message,
                });
            });
            incoming.signal.addEventListener('abort', () => {
                connection.removeAllListeners();
                connection.close();
            });
            try {
                for await (const event of (0, streams_1.values)(outgoing)) {
                    if (event.type === 'close') {
                        connection.close(event.payload.code, event.payload.reason);
                        break;
                    }
                    if (event.type === 'send') {
                        connection.send(event.payload);
                    }
                    if (event.type === 'run:cancel') {
                        connection.removeAllListeners();
                        connection.close();
                        break;
                    }
                }
            }
            catch (error) {
                throw error;
            }
        });
    },
};
//# sourceMappingURL=websocket-platform.node.js.map