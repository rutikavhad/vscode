"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.websocket = websocket;
const runtime_models_1 = require("@postman/runtime.models");
const character_encoding_1 = require("../../lib/character-encoding");
const key_values_1 = require("../../lib/key-values");
const match_event_1 = require("../../lib/match-event");
const jsonc_1 = require("../../lib/serialization/jsonc");
const sizes_1 = require("../../lib/sizes");
const streams_1 = require("../../lib/streams");
const websocket_message_1 = require("./websocket-message");
const unimplemented = {
    connect() {
        throw new Error('HTTP `fetch` not implemented');
    },
};
function websocket(options) {
    const { platform = unimplemented } = options;
    return {
        name: 'websocket',
        items: {
            'ws-raw-request'(item, run) {
                (0, runtime_models_1.assertResourceType)(runtime_models_1.WebSocketRequest, item);
                const { url = '', headers = [], queryParams = [], settings = {}, } = item.payload;
                run.enqueue({
                    type: 'websocket:open',
                    payload: { url, headers, queryParams, settings },
                });
            },
        },
        resolved: {
            async 'websocket:send-message'(event, run) {
                const message = event.payload;
                const messageType = message.type;
                if (messageType === 'json') {
                    const content = message.content;
                    const strippedContent = jsonc_1.JSONC.stripComments(content);
                    run.patch(event, (payload) => {
                        if (payload.type === 'json') {
                            // Double check only to appease the type checker
                            payload.content = strippedContent;
                        }
                    });
                }
                else if (messageType === 'binary') {
                    let finalContent;
                    try {
                        finalContent =
                            message.subtype === 'hex' ?
                                character_encoding_1.Hex.encode(message.content)
                                : character_encoding_1.Base64.encode(message.content);
                    }
                    catch (error) {
                        run.rejectEvent(event, error);
                        return;
                    }
                    run.patch(event, (payload) => {
                        payload.content = finalContent;
                    });
                }
            },
            async 'websocket:received-message'(event, run) {
                const payload = event.payload;
                const content = payload.content;
                if (typeof content === 'string') {
                    const encoder = new TextEncoder();
                    const size = encoder.encode(content).byteLength;
                    const mimeType = (0, websocket_message_1.isJSON)(content) ? 'application/json' : 'text/plain';
                    const fileExtension = mimeType === 'application/json' ? 'json' : undefined;
                    run.patch(event, (payload) => {
                        payload.mimeType = mimeType;
                        payload.size = size;
                        payload.fileExtension = fileExtension;
                    });
                }
                else {
                    const size = content.byteLength;
                    let mimeType = 'application/octet-stream';
                    let fileExtension = 'bin';
                    try {
                        // Dynamically import file-type for MIME detection
                        const { fromBuffer } = await import('file-type');
                        const result = await fromBuffer(content);
                        mimeType = result?.mime || 'application/octet-stream';
                        fileExtension = result?.ext || 'bin';
                    }
                    catch (error) {
                        // If file-type fails, keep defaults
                    }
                    run.patch(event, (payload) => {
                        payload.mimeType = mimeType;
                        payload.size = size;
                        payload.fileExtension = fileExtension;
                    });
                }
            },
        },
        execute: {
            async 'websocket:open'(event, run) {
                const url = event.payload.url;
                const protocols = getProtocols(event.payload.headers);
                const settings = event.payload.settings;
                // Prepare connection options with defaults
                const connectionOptions = {
                    protocols,
                    headers: event.payload.headers ?? {},
                    handshakeTimeout: settings?.handshakeTimeout ?? 0,
                    maxPayload: (settings?.maxPayload ?? 10) * sizes_1.MiB,
                    followRedirects: run.context.http?.followRedirects ?? true,
                    retryCount: settings?.retryCount ?? 0,
                    retryDelay: settings?.retryDelay ?? 5000,
                    ca: settings?.ca,
                    rejectUnauthorized: Boolean(settings?.strictSSL ?? run.context.tls?.strict),
                    cert: settings?.certificate?.cert,
                    key: settings?.certificate?.key,
                    pfx: settings?.certificate?.pfx,
                    passphrase: settings?.certificate?.passphrase,
                };
                run.waitUntil(async () => {
                    try {
                        const connection = await platform.connect(url, connectionOptions);
                        const writer = connection.writable.getWriter();
                        const controller = new AbortController();
                        run.subscribe((0, match_event_1.matchEvent)({
                            'run:cancel'() {
                                controller.abort();
                                writer.write({
                                    type: 'close',
                                    payload: {
                                        code: 1000,
                                        reason: 'Connection closed',
                                    },
                                });
                            },
                            'websocket:send-message'(event) {
                                const payload = event.payload;
                                // Send message through connection
                                writer.write({
                                    type: 'send',
                                    payload: payload.content,
                                });
                                const encoder = new TextEncoder();
                                const mimeType = websocket_message_1.MIME_TYPE_MAP[payload.type];
                                const size = typeof payload.content === 'string' ?
                                    encoder.encode(payload.content).byteLength
                                    : payload.content.byteLength;
                                const sentMessagePayload = {
                                    content: payload.content,
                                    mimeType,
                                    size,
                                };
                                run.emit({
                                    type: 'websocket:sent-message',
                                    payload: sentMessagePayload,
                                });
                            },
                            'websocket:close'(event) {
                                writer.write({
                                    type: 'close',
                                    payload: {
                                        code: event.payload.code,
                                        reason: event.payload.reason,
                                    },
                                });
                            },
                        }));
                        for await (const event of (0, streams_1.values)(connection.readable, {
                            signal: controller.signal,
                        })) {
                            switch (event.type) {
                                case 'open':
                                    run.enqueue({
                                        type: 'websocket:opened',
                                        payload: {
                                            request: event.payload.request,
                                            response: event.payload.response,
                                        },
                                    });
                                    break;
                                case 'reconnect':
                                    run.enqueue({
                                        type: 'websocket:reconnect',
                                        payload: {},
                                    });
                                    break;
                                case 'error':
                                    run.enqueue({
                                        type: 'websocket:error',
                                        payload: {
                                            error: event.payload.error,
                                            request: event.payload.request,
                                            response: event.payload.response,
                                        },
                                    });
                                    break;
                                case 'message': {
                                    const payload = event.payload;
                                    run.enqueue({
                                        type: 'websocket:received-message',
                                        payload: {
                                            content: payload,
                                            mimeType: '',
                                            size: 0,
                                            fileExtension: undefined,
                                        },
                                    });
                                    break;
                                }
                                case 'end':
                                    // Emit aborted event if connection was aborted, otherwise just finish
                                    if (event.payload.aborted) {
                                        run.enqueue({
                                            type: 'websocket:aborted',
                                            payload: {},
                                        });
                                        return;
                                    }
                                    run.enqueue({
                                        type: 'websocket:closed',
                                        payload: {
                                            code: event.payload.code,
                                            reason: event.payload.reason,
                                        },
                                    });
                                    break;
                            }
                        }
                    }
                    catch (error) {
                        run.error({
                            type: 'websocket:error',
                            payload: {
                                error: {
                                    message: error instanceof Error ? error.message : 'Unknown error',
                                },
                            },
                        });
                    }
                });
            },
        },
    };
}
function getProtocols(headers) {
    const protocolHeader = (0, key_values_1.getValue)(headers, 'sec-websocket-protocol', {
        caseInsensitive: false,
    });
    const protocols = protocolHeader?.split(',').map((part) => part.trim()) ?? [];
    return protocols;
}
//# sourceMappingURL=websocket-plugin.js.map