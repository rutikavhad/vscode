export type Continuation = Promise<unknown> | (() => Promise<unknown>);
/**
 * Queue that is pausable and auto-closes when exhausted
 *
 * @example
 * ```ts
 * const queue = new AutoQueue();
 * const iterator = queue[Symbol.asyncIterable]();
 *
 * queue.enqueue(1);
 * queue.enqueue(2);
 *
 * await iterator.next(); // -> { value: 1, done: false }
 * await iterator.next(); // -> { value: 2, done: false }
 * await iterator.next(); // -> { value: undefined, done: true }
 * ```
 *
 * **Auto-close**:
 *
 * The queue is closed when the following conditions are met:
 *
 * - queue is empty
 * - queue is not paused
 * - queue has no pending continuations
 *
 * When these conditions are met, the queue is closed immediately
 *
 * **Continuations**
 *
 * For cases when the queue needs to remain open until a task completes,
 * `waitUntil` allows you add continuations to the queue.
 *
 * @example
 * ```ts
 * const queue = new AutoQueue();
 *
 * queue.waitUntil(wait(200));
 * queue.waitUntil(async () => wait(500));
 *
 * // Wait at least 500ms before queue can auto-close
 * ```
 */
export declare class AutoQueue<TValue> {
    #private;
    get paused(): boolean;
    get closed(): boolean;
    get length(): number;
    get __postman_runtime_xray__(): {
        paused: boolean;
        closed: boolean;
        length: number;
        error: unknown;
        continuations: number;
    };
    enqueue(value: TValue): void;
    /**
     * Close the queue and discard any queued values
     */
    cancel(): void;
    /**
     * Discard any queued values
     */
    empty(): void;
    /**
     * Close the queue, continuing to iterate any queued values
     * and ignoring any future enqueued values
     */
    close(): void;
    /**
     * Close the queue and throw the given error
     */
    error(error: unknown): void;
    pause(): void;
    resume(): void;
    /**
     * Keep queue open until at least the given continuation settles
     * (continuation errors are thrown by the queue)
     *
     * @example
     * ```ts
     * const queue = new AutoQueue();
     *
     * queue.waitUntil(wait(200));
     * queue.waitUntil(async () => wait(500));
     *
     * // Wait until all continuations resolve, before queue can close
     * // (at least 500ms for this example)
     * ```
     */
    waitUntil(continuation: Continuation): void;
    /**
     * During async iteration, if the loop is exited early (e.g. with break),
     * the queue is cancelled, discarding any queued values.
     * This is generally preferred, but for cases where iteration may be resumed,
     * `values` with `preventCancel` will prevent cancellation and keep the queue open
     * for continued enqueue and iteration.
     *
     * @example
     * ```ts
     * const queue = new AutoQueue();
     *
     * // Read first 3 values
     * let count = 0;
     * for await (const value of queue.values({ preventCancel: true })) {
     *   // ...
     *
     *   count += 1;
     *   if (count >= 3) break;
     * }
     *
     * // queue is still open
     * ```
     * @param [options]
     * @param [options.preventCancel = false] prevent cancellation when the iterator returns
     * @returns
     */
    values(options?: {
        preventCancel?: boolean;
    }): AsyncIterable<TValue>;
    [Symbol.asyncIterator](): AsyncIterator<TValue>;
    [Symbol.dispose](): void;
}
