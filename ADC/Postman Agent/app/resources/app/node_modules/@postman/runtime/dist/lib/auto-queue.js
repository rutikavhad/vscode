"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AutoQueue = void 0;
const promises_js_1 = require("./promises.js");
/**
 * Queue that is pausable and auto-closes when exhausted
 *
 * @example
 * ```ts
 * const queue = new AutoQueue();
 * const iterator = queue[Symbol.asyncIterable]();
 *
 * queue.enqueue(1);
 * queue.enqueue(2);
 *
 * await iterator.next(); // -> { value: 1, done: false }
 * await iterator.next(); // -> { value: 2, done: false }
 * await iterator.next(); // -> { value: undefined, done: true }
 * ```
 *
 * **Auto-close**:
 *
 * The queue is closed when the following conditions are met:
 *
 * - queue is empty
 * - queue is not paused
 * - queue has no pending continuations
 *
 * When these conditions are met, the queue is closed immediately
 *
 * **Continuations**
 *
 * For cases when the queue needs to remain open until a task completes,
 * `waitUntil` allows you add continuations to the queue.
 *
 * @example
 * ```ts
 * const queue = new AutoQueue();
 *
 * queue.waitUntil(wait(200));
 * queue.waitUntil(async () => wait(500));
 *
 * // Wait at least 500ms before queue can auto-close
 * ```
 */
class AutoQueue {
    #queue = [];
    #paused = false;
    #closed = false;
    #error = null;
    #continuations = 0;
    #waiting = null;
    get paused() {
        return this.#paused;
    }
    get closed() {
        return this.#closed;
    }
    get length() {
        return this.#queue.length;
    }
    get __postman_runtime_xray__() {
        return {
            paused: this.#paused,
            closed: this.#closed,
            length: this.#queue.length,
            error: this.#error,
            continuations: this.#continuations,
        };
    }
    enqueue(value) {
        if (this.#closed)
            return;
        if (this.#waiting && !this.#paused) {
            this.#waiting.resolve({ value, done: false });
            this.#waiting = null;
        }
        else {
            this.#queue.push(value);
        }
    }
    //
    // #region Lifecycle
    //
    /**
     * Close the queue and discard any queued values
     */
    cancel() {
        this.#queue = [];
        this.close();
    }
    /**
     * Discard any queued values
     */
    empty() {
        this.#queue = [];
    }
    /**
     * Close the queue, continuing to iterate any queued values
     * and ignoring any future enqueued values
     */
    close() {
        this.#closed = true;
        if (!this.#queue.length && this.#waiting) {
            this.#waiting.resolve({ value: undefined, done: true });
            this.#waiting = null;
        }
    }
    #tryAutoClose = () => {
        if (!this.#queue.length && !this.#continuations && !this.#paused) {
            this.close();
        }
    };
    /**
     * Close the queue and throw the given error
     */
    error(error) {
        if (!!this.#error)
            return;
        this.#paused = false;
        this.#closed = true;
        this.#queue = [];
        this.#error = error;
        if (this.#waiting) {
            this.#waiting.reject(error);
            this.#waiting = null;
        }
    }
    pause() {
        this.#paused = true;
    }
    resume() {
        this.#paused = false;
        if (this.#queue.length && this.#waiting) {
            const value = this.#queue.shift();
            this.#waiting.resolve({ value, done: false });
            this.#waiting = null;
        }
        this.#tryAutoClose();
    }
    /**
     * Keep queue open until at least the given continuation settles
     * (continuation errors are thrown by the queue)
     *
     * @example
     * ```ts
     * const queue = new AutoQueue();
     *
     * queue.waitUntil(wait(200));
     * queue.waitUntil(async () => wait(500));
     *
     * // Wait until all continuations resolve, before queue can close
     * // (at least 500ms for this example)
     * ```
     */
    waitUntil(continuation) {
        if (this.closed)
            return;
        this.#continuations += 1;
        (async () => {
            if (typeof continuation === 'function') {
                continuation = continuation();
            }
            await continuation;
        })()
            .catch((error) => {
            this.error(error);
        })
            .finally(() => {
            this.#continuations -= 1;
            if (this.#continuations <= 0) {
                this.#tryAutoClose();
            }
        });
    }
    /**
     * During async iteration, if the loop is exited early (e.g. with break),
     * the queue is cancelled, discarding any queued values.
     * This is generally preferred, but for cases where iteration may be resumed,
     * `values` with `preventCancel` will prevent cancellation and keep the queue open
     * for continued enqueue and iteration.
     *
     * @example
     * ```ts
     * const queue = new AutoQueue();
     *
     * // Read first 3 values
     * let count = 0;
     * for await (const value of queue.values({ preventCancel: true })) {
     *   // ...
     *
     *   count += 1;
     *   if (count >= 3) break;
     * }
     *
     * // queue is still open
     * ```
     * @param [options]
     * @param [options.preventCancel = false] prevent cancellation when the iterator returns
     * @returns
     */
    values(options) {
        const preventCancel = options?.preventCancel ?? false;
        return {
            [Symbol.asyncIterator]: () => {
                return {
                    next: () => {
                        if (this.#waiting) {
                            return this.#waiting.promise;
                        }
                        if (this.#error) {
                            return Promise.reject(this.#error);
                        }
                        if (this.#closed && !this.#queue.length) {
                            return Promise.resolve({ value: undefined, done: true });
                        }
                        if (!this.#paused && this.#queue.length) {
                            const value = this.#queue.shift();
                            if (!this.#queue.length && !this.#continuations) {
                                this.#closed = true;
                            }
                            return Promise.resolve({ value: value, done: false });
                        }
                        if (!this.#paused && !this.#continuations) {
                            this.#closed = true;
                            return Promise.resolve({ value: undefined, done: true });
                        }
                        this.#waiting = (0, promises_js_1.promiseWithResolvers)();
                        return this.#waiting.promise;
                    },
                    return: async () => {
                        if (!preventCancel)
                            this.cancel();
                        return { value: undefined, done: true };
                    },
                };
            },
        };
    }
    [Symbol.asyncIterator]() {
        return this.values({ preventCancel: false })[Symbol.asyncIterator]();
    }
    [Symbol.dispose]() {
        this.cancel();
    }
}
exports.AutoQueue = AutoQueue;
//# sourceMappingURL=auto-queue.js.map