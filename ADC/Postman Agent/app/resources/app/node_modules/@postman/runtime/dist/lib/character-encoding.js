"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UTF16LE = exports.UTF16CodeUnit = exports.ASCII = exports.Hex = exports.Base64 = exports.UTF8 = void 0;
const arrays_1 = require("./arrays");
const typed_array_1 = require("./typed-array");
/**
 * # Character Encoding
 *
 * Mapping between bytes and text.
 *
 * Encode {format}: convert text with {format} into bytes
 * Decode {format}: convert bytes into text with {format}
 *
 * Formats:
 *
 * - Text
 * - Base64
 * - Hex
 * - ASCII
 * - UTF16LE
 *
 * @module character-encoding
 */
//
// #region UTF8
//
exports.UTF8 = {
    /**
     * Encode UTF-8 string as bytes
     */
    encode(text) {
        return new TextEncoder().encode(text);
    },
    /**
     * Decode bytes as UTF-8 string.
     */
    decode(bytes) {
        return new TextDecoder().decode(bytes);
    },
};
//
// #region base-64
//
// Should always be a multiple of [3][1], base64-js [chose 16,383][2]
//
// [1]: https://stackoverflow.com/a/18518605
// [2]: https://github.com/beatgammit/base64-js/blob/303e81353e21339da09adb1e2fc0da74626bd8b2/index.js#L124
const CHUNK_SIZE_BASE64 = 16_383;
exports.Base64 = {
    /**
     * Encode a base-64 string as bytes.
     */
    encode(text) {
        if (!/^([a-zA-Z\d+/]{4})*([a-zA-Z\d+/]{3}=|[a-zA-Z\d+/]{2}==)?$/.test(text)) {
            throw new SyntaxError('Invalid Base64');
        }
        const decoded = atob(text);
        const bytes = new Uint8Array(decoded.length);
        for (let i = 0; i < decoded.length; i += 1) {
            bytes[i] = decoded.charCodeAt(i);
        }
        return bytes;
    },
    /**
     * Decode bytes to a base-64 string.
     *
     * Note: There is a maximum limit on string size above which `btoa` fails.
     * `toBase64` chunks the `btoa` calls into sizes that generate base-64 strings without the need for padding.
     */
    decode(bytes) {
        const array = (0, typed_array_1.toTypedArray)(bytes);
        // Limited availability for [`toBase64`][1]
        //
        // [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array/toBase64
        if ('toBase64' in array && typeof array.toBase64 === 'function') {
            return array.toBase64();
        }
        const chunks = (0, arrays_1.toChunked)(array, CHUNK_SIZE_BASE64);
        return chunks.map((chunk) => btoa(String.fromCharCode(...chunk))).join('');
    },
};
//
// #region Hex
//
exports.Hex = {
    /**
     * Encode a hex string as bytes.
     */
    encode(text) {
        if (text.length % 2 !== 0) {
            throw new Error('Hex string must have an even number of characters');
        }
        if (!/^([a-fA-F\d]{2})*$/.test(text)) {
            throw new SyntaxError('Invalid Hexadecimal');
        }
        const bytes = new Uint8Array(text.length / 2);
        for (let i = 0; i < text.length; i += 2) {
            bytes[i / 2] = parseInt(text.substring(i, i + 2), 16);
        }
        return bytes;
    },
    /**
     * Decode bytes to a hex string.
     */
    decode(bytes) {
        const array = (0, typed_array_1.toTypedArray)(bytes);
        // Limited availability for [`toHex`][1]
        //
        // [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array/toHex
        if ('toHex' in array && typeof array.toHex === 'function') {
            return array.toHex();
        }
        return Array.from(array, (byte) => byte.toString(16).padStart(2, '0')).join('');
    },
};
//
// #region ASCII
//
exports.ASCII = {
    /**
     * Encode an ASCII string as bytes.
     */
    encode(text) {
        const result = new Uint8Array(text.length);
        for (let i = 0; i < text.length; i++) {
            const code = text.charCodeAt(i);
            if (code > 0x7f) {
                throw new Error('Non-ASCII character');
            }
            result[i] = code;
        }
        return result;
    },
    /**
     * Decode bytes to an ASCII string.
     */
    decode(bytes) {
        const array = (0, typed_array_1.toTypedArray)(bytes);
        let result = '';
        for (let i = 0; i < array.length; i++) {
            const byte = array[i];
            if (byte > 0x7f) {
                throw new Error('Non-ASCII character');
            }
            result += String.fromCharCode(byte);
        }
        return result;
    },
};
//
// #region UTF-16 Code Units
//
exports.UTF16CodeUnit = {
    /**
     * Encode UTF-16 string code units (i.e. charCodeAt) as Uint8Array
     * (truncating to only the lower 8 bits)
     */
    encode(text) {
        const bytes = new Uint8Array(text.length);
        for (let i = 0; i < text.length; i++) {
            // Only keep the lower 8 bits (0-255) of the character code (mask higher bits)
            bytes[i] = text.charCodeAt(i) & 0xff;
        }
        return bytes;
    },
    /**
     * Decode Uint8Array into UTF-16 string code units (i.e. fromCharCode)
     */
    decode(bytes) {
        const array = (0, typed_array_1.toTypedArray)(bytes);
        return String.fromCharCode(...array);
    },
};
//
// #region UTF-16LE
//
exports.UTF16LE = {
    /**
     * Encode a UTF-16LE string as bytes.
     */
    encode(text) {
        const result = new Uint8Array(text.length * 2);
        for (let i = 0; i < text.length; i += 1) {
            const code = text.charCodeAt(i);
            result[i * 2] = code & 0xff;
            result[i * 2 + 1] = code >>> 8;
        }
        return result;
    },
    /**
     * Decode bytes to a UTF-16LE string.
     */
    decode(bytes) {
        const array = (0, typed_array_1.toTypedArray)(bytes);
        let result = '';
        for (let i = 0; i < array.length; i += 2) {
            const code = array[i] | (array[i + 1] << 8);
            result += String.fromCharCode(code);
        }
        return result;
    },
};
//# sourceMappingURL=character-encoding.js.map