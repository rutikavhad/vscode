"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeHashAlgorithm = exports.HashAlgorithm = void 0;
exports.isHashAlgorithm = isHashAlgorithm;
exports.isNodeHashAlgorithm = isNodeHashAlgorithm;
exports.toNodeHashAlgorithm = toNodeHashAlgorithm;
exports.computeHash = computeHash;
exports.computeSignedHash = computeSignedHash;
const z = __importStar(require("zod/v4-mini"));
const character_encoding_1 = require("../character-encoding");
const md5_1 = require("./md5");
const SUPPORTED_ALGORITHMS = [
    'MD5',
    'SHA-1',
    'SHA-256',
    'SHA-384',
    'SHA-512',
];
const SUPPORTED_NODE_ALGORITHMS = [
    'md5',
    'sha1',
    'sha256',
    'sha384',
    'sha512',
];
const MAPPING_TO_NODE = {
    MD5: 'md5',
    'SHA-1': 'sha1',
    'SHA-256': 'sha256',
    'SHA-384': 'sha384',
    'SHA-512': 'sha512',
};
const MAPPING_FROM_NODE = {
    md5: 'MD5',
    sha1: 'SHA-1',
    sha256: 'SHA-256',
    sha384: 'SHA-384',
    sha512: 'SHA-512',
};
/**
 * Use hash algorithm format supported by built-in crypto,
 * mapping Node.js-specific values if necessary
 */
exports.HashAlgorithm = z.pipe(z.string(), z.transform((value) => {
    if (isHashAlgorithm(value)) {
        return value;
    }
    if (isNodeHashAlgorithm(value)) {
        return MAPPING_FROM_NODE[value];
    }
    throw new Error(`Unsupported hash algorithm "${value}"`);
}));
function isHashAlgorithm(value) {
    return SUPPORTED_ALGORITHMS.includes(value);
}
/**
 * Backwards-compatibility hashing algorithm suitable for Node.js
 */
exports.NodeHashAlgorithm = z.literal(SUPPORTED_NODE_ALGORITHMS);
function isNodeHashAlgorithm(value) {
    return SUPPORTED_NODE_ALGORITHMS.includes(value);
}
function toNodeHashAlgorithm(value) {
    return MAPPING_TO_NODE[value];
}
async function computeHash(data, algorithm, encoding) {
    if (typeof data === 'string') {
        data = character_encoding_1.UTF8.encode(data);
    }
    const digest = algorithm === 'MD5' ?
        (0, md5_1.md5Digest)(data)
        : await crypto.subtle.digest(algorithm, data);
    if (encoding === 'base64') {
        return character_encoding_1.Base64.decode(digest);
    }
    if (encoding === 'hex') {
        return character_encoding_1.Hex.decode(digest);
    }
    return digest;
}
async function computeSignedHash(key, data, algorithm, encoding) {
    if (typeof data === 'string') {
        data = character_encoding_1.UTF8.encode(data);
    }
    if (typeof key === 'string') {
        key = character_encoding_1.UTF8.encode(key);
    }
    let signature;
    if (algorithm === 'MD5') {
        signature = (0, md5_1.md5HMAC)(key, data);
    }
    else {
        const signingKey = await crypto.subtle.importKey('raw', key, { name: 'HMAC', hash: algorithm }, false, ['sign']);
        signature = await crypto.subtle.sign('HMAC', signingKey, data);
    }
    if (encoding === 'base64') {
        return character_encoding_1.Base64.decode(signature);
    }
    if (encoding === 'hex') {
        return character_encoding_1.Hex.decode(signature);
    }
    return signature;
}
//# sourceMappingURL=hashing.js.map