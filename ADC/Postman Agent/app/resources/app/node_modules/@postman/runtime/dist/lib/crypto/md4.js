"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.md4Digest = md4Digest;
const typed_array_1 = require("../typed-array");
/**
 * Minimal MD4 implementation (RFC 1320)
 */
function md4Digest(inputData) {
    const input = (0, typed_array_1.toTypedArray)(inputData);
    const a0 = 0x67452301 | 0;
    const b0 = 0xefcdab89 | 0;
    const c0 = 0x98badcfe | 0;
    const d0 = 0x10325476 | 0;
    // 512-bit
    const blockLength = 64;
    const inputLength = input.length;
    const bitLength = BigInt(inputLength) * 8n;
    // Calculate padded length: append 0x80, zeros, then 64-bit little-endian length
    const paddedLength = (blockLength - ((inputLength + 1 + 8) % blockLength)) % blockLength;
    const totalLength = inputLength + 1 + paddedLength + 8;
    const data = new Uint8Array(totalLength);
    data.set(input, 0);
    data[inputLength] = 0x80;
    // Last 8 bytes: length in bits, little-endian
    const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);
    dataView.setBigUint64(totalLength - 8, bitLength, true);
    let a = a0, b = b0, c = c0, d = d0;
    const X = new Int32Array(16);
    for (let offset = 0; offset < data.length; offset += blockLength) {
        // Load 16 little-endian 32-bit words
        for (let i = 0; i < 16; i++) {
            X[i] = dataView.getInt32(offset + i * 4, true);
        }
        let aa = a, bb = b, cc = c, dd = d;
        // Round 1
        a = round1(a, b, c, d, X[0], 3);
        d = round1(d, a, b, c, X[1], 7);
        c = round1(c, d, a, b, X[2], 11);
        b = round1(b, c, d, a, X[3], 19);
        a = round1(a, b, c, d, X[4], 3);
        d = round1(d, a, b, c, X[5], 7);
        c = round1(c, d, a, b, X[6], 11);
        b = round1(b, c, d, a, X[7], 19);
        a = round1(a, b, c, d, X[8], 3);
        d = round1(d, a, b, c, X[9], 7);
        c = round1(c, d, a, b, X[10], 11);
        b = round1(b, c, d, a, X[11], 19);
        a = round1(a, b, c, d, X[12], 3);
        d = round1(d, a, b, c, X[13], 7);
        c = round1(c, d, a, b, X[14], 11);
        b = round1(b, c, d, a, X[15], 19);
        // Round 2
        a = round2(a, b, c, d, X[0], 3);
        d = round2(d, a, b, c, X[4], 5);
        c = round2(c, d, a, b, X[8], 9);
        b = round2(b, c, d, a, X[12], 13);
        a = round2(a, b, c, d, X[1], 3);
        d = round2(d, a, b, c, X[5], 5);
        c = round2(c, d, a, b, X[9], 9);
        b = round2(b, c, d, a, X[13], 13);
        a = round2(a, b, c, d, X[2], 3);
        d = round2(d, a, b, c, X[6], 5);
        c = round2(c, d, a, b, X[10], 9);
        b = round2(b, c, d, a, X[14], 13);
        a = round2(a, b, c, d, X[3], 3);
        d = round2(d, a, b, c, X[7], 5);
        c = round2(c, d, a, b, X[11], 9);
        b = round2(b, c, d, a, X[15], 13);
        // Round 3
        a = round3(a, b, c, d, X[0], 3);
        d = round3(d, a, b, c, X[8], 9);
        c = round3(c, d, a, b, X[4], 11);
        b = round3(b, c, d, a, X[12], 15);
        a = round3(a, b, c, d, X[2], 3);
        d = round3(d, a, b, c, X[10], 9);
        c = round3(c, d, a, b, X[6], 11);
        b = round3(b, c, d, a, X[14], 15);
        a = round3(a, b, c, d, X[1], 3);
        d = round3(d, a, b, c, X[9], 9);
        c = round3(c, d, a, b, X[5], 11);
        b = round3(b, c, d, a, X[13], 15);
        a = round3(a, b, c, d, X[3], 3);
        d = round3(d, a, b, c, X[11], 9);
        c = round3(c, d, a, b, X[7], 11);
        b = round3(b, c, d, a, X[15], 15);
        a = (a + aa) | 0;
        b = (b + bb) | 0;
        c = (c + cc) | 0;
        d = (d + dd) | 0;
    }
    const digest = new Uint8Array(16);
    const digestView = new DataView(digest.buffer, digest.byteOffset, digest.byteLength);
    digestView.setInt32(0, a, true);
    digestView.setInt32(4, b, true);
    digestView.setInt32(8, c, true);
    digestView.setInt32(12, d, true);
    return digest;
}
function rotl(x, n) {
    return (x << n) | (x >>> (32 - n)) | 0;
}
function F(x, y, z) {
    return (x & y) | (~x & z) | 0;
}
function G(x, y, z) {
    return (x & y) | (x & z) | (y & z) | 0;
}
function H(x, y, z) {
    return (x ^ y ^ z) | 0;
}
function round1(a, b, c, d, xk, s) {
    return rotl((a + F(b, c, d) + xk) | 0, s);
}
function round2(a, b, c, d, xk, s) {
    return rotl((a + G(b, c, d) + xk + 0x5a827999) | 0, s);
}
function round3(a, b, c, d, xk, s) {
    return rotl((a + H(b, c, d) + xk + 0x6ed9eba1) | 0, s);
}
//# sourceMappingURL=md4.js.map