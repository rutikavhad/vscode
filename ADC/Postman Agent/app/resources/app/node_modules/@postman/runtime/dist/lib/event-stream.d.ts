import { AnyEvent } from '../events.js';
import { EventMatcher } from './match-event.js';
import { type Unsubscribe } from './unsubscribe.js';
/**
 * Subscriber interface based on [WICG Observable](https://wicg.github.io/observable/)
 */
export interface EventSubscriber<TEvent extends AnyEvent = AnyEvent> {
    next?: (event: TEvent) => void;
    error?: (error: unknown) => void;
    complete?: () => void;
}
export declare function isEventSubscriber<TEvent extends AnyEvent = AnyEvent>(listener: EventMatcher<TEvent> | EventSubscriber<TEvent>): listener is EventSubscriber<TEvent>;
/**
 * Specialized event emitter that buffers events for async processing as well as synchronous subscription.
 *
 * @example
 * ```ts
 * const events = new EventStream();
 *
 * // Synchronous subscription
 * events.subscribe((event) => {
 *   console.log(event);
 * });
 *
 * // Emit events
 * events.emit({ type: 'namespace:a' })
 * events.emit({ type: 'namespace:b' })
 * events.emit({ type: 'namespace:c' })
 *
 * // Asynchronous subscription
 * for await (const event of events) {
 *   console.log(event);
 * }
 * ```
 */
export declare class EventStream<TEvent extends AnyEvent> {
    #private;
    constructor();
    /**
     * Set of all listeners.
     *
     * @example
     * ```ts
     * const events = new EventEmitter();
     *
     * // Unsubscribe all listeners
     * events.listeners.clear();
     * ```
     */
    subscribers: Set<EventSubscriber<TEvent>>;
    /**
     * Emit an event
     *
     * @example
     * ```ts
     * const events = new EventStream();
     *
     * events.emit({ type: 'a' });
     * events.emit({ type: 'b', payload: 'value' });
     * ```
     */
    emit(event: TEvent): void;
    /**
     * Subscribe to EventEmitter with callback or matcher.
     *
     * @example
     * ```ts
     * const events = new EventEmitter();
     *
     * const unsubscribe = events.subscribe(event => {
     *   // ...
     * });
     *
     * // Alternatively, use matcher
     * events.subscribe({
     *   'namespace:a'(event) {
     *     // ...
     *   }
     * });
     * ```
     */
    subscribe(listener: EventMatcher<TEvent> | EventSubscriber<TEvent>, options?: {
        signal?: AbortSignal;
    }): Unsubscribe;
    /**
     * Throw error in EventStream.
     *
     * (note: subscribers should also generally be notified with an "error" event)
     */
    error(error: unknown): void;
    /**
     * Close the EventStream and clear all listeners.
     */
    close(): void;
    [Symbol.asyncIterator](): AsyncIterator<TEvent>;
    values(options?: {
        preventCancel?: boolean;
    }): AsyncIterable<TEvent>;
}
