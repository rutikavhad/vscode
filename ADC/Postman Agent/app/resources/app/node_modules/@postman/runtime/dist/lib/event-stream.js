"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventStream = void 0;
exports.isEventSubscriber = isEventSubscriber;
const match_event_js_1 = require("./match-event.js");
const streams_js_1 = require("./streams.js");
const unsubscribe_js_1 = require("./unsubscribe.js");
function isEventSubscriber(listener) {
    return (typeof listener === 'object' &&
        ('next' in listener || 'error' in listener || 'complete' in listener));
}
/**
 * Specialized event emitter that buffers events for async processing as well as synchronous subscription.
 *
 * @example
 * ```ts
 * const events = new EventStream();
 *
 * // Synchronous subscription
 * events.subscribe((event) => {
 *   console.log(event);
 * });
 *
 * // Emit events
 * events.emit({ type: 'namespace:a' })
 * events.emit({ type: 'namespace:b' })
 * events.emit({ type: 'namespace:c' })
 *
 * // Asynchronous subscription
 * for await (const event of events) {
 *   console.log(event);
 * }
 * ```
 */
class EventStream {
    #effects = [];
    #emitting = false;
    #closed = false;
    #events;
    #controller;
    constructor() {
        let controller;
        this.#events = new ReadableStream({
            start(_controller) {
                controller = _controller;
            },
            cancel: () => {
                this.#closed = true;
            },
        });
        this.#controller = controller;
    }
    /**
     * Set of all listeners.
     *
     * @example
     * ```ts
     * const events = new EventEmitter();
     *
     * // Unsubscribe all listeners
     * events.listeners.clear();
     * ```
     */
    subscribers = new Set();
    /**
     * Emit an event
     *
     * @example
     * ```ts
     * const events = new EventStream();
     *
     * events.emit({ type: 'a' });
     * events.emit({ type: 'b', payload: 'value' });
     * ```
     */
    emit(event) {
        if (this.#closed)
            return;
        this.#controller.enqueue(event);
        // If already emitting (re-entrant, e.g. emit within listener),
        // save the next emit as a side-effect and emit once the current emit has completed.
        if (this.#emitting) {
            this.#effects.push(event);
            return;
        }
        this.#emitting = true;
        // Create copy of listeners at time of emit,
        // as throwing error in effect will clear listeners and cause all listeners to miss event
        const subscribers = Array.from(this.subscribers);
        for (const subscriber of subscribers) {
            subscriber.next?.(event);
        }
        while (this.#effects.length) {
            const event = this.#effects.shift();
            for (const subscriber of subscribers) {
                subscriber.next?.(event);
            }
        }
        this.#emitting = false;
    }
    /**
     * Subscribe to EventEmitter with callback or matcher.
     *
     * @example
     * ```ts
     * const events = new EventEmitter();
     *
     * const unsubscribe = events.subscribe(event => {
     *   // ...
     * });
     *
     * // Alternatively, use matcher
     * events.subscribe({
     *   'namespace:a'(event) {
     *     // ...
     *   }
     * });
     * ```
     */
    subscribe(listener, options) {
        const subscriber = isEventSubscriber(listener) ? listener : { next: (0, match_event_js_1.matchEvent)(listener) };
        this.subscribers.add(subscriber);
        return (0, unsubscribe_js_1.unsubscriber)(() => this.subscribers.delete(subscriber), options);
    }
    /**
     * Throw error in EventStream.
     *
     * (note: subscribers should also generally be notified with an "error" event)
     */
    error(error) {
        this.#closed = true;
        for (const subscriber of this.subscribers) {
            subscriber.error?.(error);
        }
        this.subscribers.clear();
        this.#controller.error(error);
    }
    /**
     * Close the EventStream and clear all listeners.
     */
    close() {
        /* v8 ignore next 1 */
        if (this.#closed)
            return;
        this.#closed = true;
        for (const subscriber of this.subscribers) {
            subscriber.complete?.();
        }
        this.subscribers.clear();
        this.#controller.close();
    }
    [Symbol.asyncIterator]() {
        return this.values({ preventCancel: false })[Symbol.asyncIterator]();
    }
    values(options) {
        return (0, streams_js_1.values)(this.#events, options);
    }
}
exports.EventStream = EventStream;
//# sourceMappingURL=event-stream.js.map