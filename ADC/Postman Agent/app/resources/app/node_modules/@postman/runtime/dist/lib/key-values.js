"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getValue = getValue;
exports.findKeyValue = findKeyValue;
exports.findIndexKeyValue = findIndexKeyValue;
exports.upsertKeyValue = upsertKeyValue;
exports.removeKeyValue = removeKeyValue;
exports.keyValuesToObject = keyValuesToObject;
exports.isKeyValue = isKeyValue;
const arrays_1 = require("./arrays");
/**
 * Helpers for working with key-values
 *
 * @module key-values
 */
/**
 * Get value from key-values for given key
 */
function getValue(keyValues, key, options = {}) {
    return findKeyValue(keyValues, key, options)?.value;
}
/**
 * Find first key-value for given key
 */
function findKeyValue(keyValues, key, options = {}) {
    const index = findIndexKeyValue(keyValues, key, options);
    return keyValues[index];
}
/**
 * Find index of first key-value for given key (-1 if not found)
 */
function findIndexKeyValue(keyValues, key, options = {}) {
    const { caseInsensitive = false } = options;
    const search = caseInsensitive ? key.toLowerCase() : key;
    return keyValues.findIndex((keyValue) => (caseInsensitive ? keyValue.key?.toLowerCase() : keyValue.key) === search);
}
/**
 * **Mutating**: Insert or update the given key-value
 */
function upsertKeyValue(keyValues, entry, options = {}) {
    // For NullableKeyValues and empty key, nothing to compare
    if (!entry.key) {
        keyValues.push(entry);
        return;
    }
    // Replace first instance of key
    const firstIndex = findIndexKeyValue(keyValues, entry.key, options);
    if (firstIndex === -1) {
        keyValues.push(entry);
    }
    else {
        keyValues[firstIndex] = entry;
        // Remove remaining instances of key
        (0, arrays_1.filter)(keyValues, (keyValue, index) => {
            if (index <= firstIndex)
                return true;
            return ((options.caseInsensitive ?
                keyValue.key?.toLowerCase()
                : keyValue.key) !== entry.key);
        });
    }
}
/**
 * **Mutating**: Remove all key-values with given key
 */
function removeKeyValue(keyValues, key, options = {}) {
    const { caseInsensitive = false } = options;
    const search = caseInsensitive ? key.toLowerCase() : key;
    (0, arrays_1.filter)(keyValues, (keyValue) => {
        if (!keyValue.key)
            return true;
        return ((caseInsensitive ? keyValue.key.toLowerCase() : keyValue.key) !== search);
    });
}
/**
 * Collect key-values array into an object, using the given approach
 *
 * `approach`:
 *
 * - `override` (default) - Last value wins
 * - `combine` - Multiple values are stored as Array
 * - `initial` - First value wins
 *
 * @example
 * ```ts
 * const keyValues = [
 *   { key: 'a', value: 1 },
 *   { key: 'b', value: 2 },
 *   { key: 'a', value: 3 },
 *   { key: 'B', value: 4 }
 * ];
 *
 * let result = keyValuesToObject(keyValues);
 * // { a: 3, b: 2, B: 4 }
 *
 * result = keyValuesToObject(keyValues, { approach: 'combine' });
 * // { a: [1, 3], b: 2, B: 4 }
 *
 * result = keyValuesToObject(keyValues, { approach: 'initial', caseInsensitive: true });
 * // { a: 1, b: 2 }
 * ```
 *
 * @param {KeyValues} keyValues
 * @param {object} [options]
 * @param {'override' | 'combine' | 'initial'} [options.approach = 'override']
 * @param {boolean} [options.caseInsensitive = false]
 * @returns
 */
function keyValuesToObject(keyValues, options = {}) {
    const { approach = 'override', caseInsensitive = false } = options;
    const values = {};
    for (const { key, value } of keyValues) {
        if (key == null)
            continue;
        const objectKey = caseInsensitive ? key.toLowerCase() : key;
        if (approach === 'combine' && objectKey in values) {
            if (!Array.isArray(values[objectKey])) {
                values[objectKey] = [values[objectKey]];
            }
            values[objectKey].push(value);
        }
        else if (approach === 'initial') {
            if (values[objectKey] !== undefined)
                continue;
            values[objectKey] = value;
        }
        else {
            values[objectKey] = value;
        }
    }
    return values;
}
/**
 * Check if given value is likely key-value
 */
function isKeyValue(value) {
    return (typeof value === 'object' &&
        value != null &&
        'key' in value &&
        typeof value.key === 'string');
}
//# sourceMappingURL=key-values.js.map