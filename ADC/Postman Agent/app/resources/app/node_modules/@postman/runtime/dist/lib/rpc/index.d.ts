import * as z from 'zod/v4-mini';
export interface ChannelController<TIncoming = unknown, TOutgoing = unknown> {
    incoming: ReadableStreamDefaultController<TIncoming> & {
        /**
         * Signals cancellation of readable stream
         */
        signal: AbortSignal;
    };
    outgoing: ReadableStream<TOutgoing>;
}
/**
 * Channel is a bi-directional stream of incoming and outgoing values.
 * It can represent values over a WebSocket, IPC, or other connections.
 * It's based on the design of [WebTransport][1] and other bidirection / duplex streams
 *
 * [1]: https://developer.mozilla.org/en-US/docs/Web/API/WebTransportBidirectionalStream
 *
 * @example
 * ```ts
 * function connect() {
 *   return new Channel(async ({ incoming, outgoing }) => {
 *     const socket = new WebSocket('...');
 *     socket.addEventListener('message', (data) => {
 *       incoming.enqueue(data);
 *     });
 *     socket.addEventListener('error', (error) => {
 *       incoming.error(error);
 *     });
 *     socket.addEventListener('close', () => {
 *       incoming.close();
 *     })
 *
 *     // Send all writes to socket
 *     for await (const message of outgoing) {
 *       socket.send(message);
 *     }
 *
 *     // Close socket when writer closes
 * 		 socket.close()
 *   });
 * }
 *
 * // Echo messages back to WebSocket
 * const channel = connect();
 * const writer = channel.writable.getWriter();
 * for await (const message of channel.readable) {
 *   if (message === 'quit') {
 *     writer.close();
 *     break;
 *   }
 *
 *   writer.write(message);
 * }
 * ```
 */
export declare class Channel<TIncoming = unknown, TOutgoing = unknown> {
    readable: ReadableStream<TIncoming>;
    writable: WritableStream<TOutgoing>;
    constructor(
    /**
     * Handler receives the "other end" of the channel,
     * with `incoming` writing to the channel's readable stream
     * and `outgoing` reading from the channel's writable stream
     */
    handler: (controller: ChannelController<TIncoming, TOutgoing>) => void | Promise<void>);
}
export interface Platform {
    [name: string]: ((...args: any[]) => Promise<Channel>) | undefined;
}
export interface NamespacedPlatform {
    [namespace: string]: Platform | undefined;
}
export declare const InvokeOptions: z.ZodMiniObject<{
    path: z.ZodMiniArray<z.ZodMiniString<string>>;
    args: z.ZodMiniArray<z.ZodMiniAny>;
}, z.z.core.$strip>;
export type InvokeOptions = z.infer<typeof InvokeOptions>;
export declare function invoke(platform: NamespacedPlatform, options: InvokeOptions): Promise<Channel>;
