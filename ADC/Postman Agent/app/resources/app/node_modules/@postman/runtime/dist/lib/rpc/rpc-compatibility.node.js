"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChannelEmitter = void 0;
exports.channelToProxy = channelToProxy;
const runtime_runtime_rpc_1 = require("@postman/runtime.runtime-rpc");
const node_events_1 = require("node:events");
const event_loop_1 = require("../event-loop");
const streams_1 = require("../streams");
class ChannelEmitter extends node_events_1.EventEmitter {
    #channel;
    #writer;
    #closed = false;
    get closed() {
        return this.#closed;
    }
    constructor(channel) {
        super();
        this.#channel = channel;
        const writer = (this.#writer = channel.writable.getWriter());
        (async () => {
            // Allow listeners to attach before starting to read
            await (0, event_loop_1.nextMicrotask)();
            for await (const data of (0, streams_1.iterate)(channel.readable)) {
                this.emit('data', data);
            }
            this.#closed = true;
            try {
                await writer.close();
            }
            catch (_error) {
                // (ignore ERR_INVALID_STATE issues)
            }
            this.emit('#close');
        })().catch((error) => {
            this.emit('#error', error);
            // For errors, channel has already closed readable/writable
            this.#closed = true;
            this.emit('#close');
        });
    }
    async write(data) {
        await this.#writer.write(data);
    }
    async cancel(reason) {
        await Promise.allSettled([
            this.#channel.readable.cancel(),
            this.#writer.abort(reason),
        ]);
    }
}
exports.ChannelEmitter = ChannelEmitter;
function channelToProxy(channel) {
    const emitter = new ChannelEmitter(channel);
    const result = new runtime_runtime_rpc_1.ProxyResult(emitter);
    emitter.on('#close', () => {
        result.disconnect();
    });
    result.onCleanup(() => {
        emitter.cancel();
    });
    return result;
}
//# sourceMappingURL=rpc-compatibility.node.js.map