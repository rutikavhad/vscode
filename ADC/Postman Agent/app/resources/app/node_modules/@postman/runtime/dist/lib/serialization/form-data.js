"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBoundary = getBoundary;
exports.serializeFormData = serializeFormData;
const file_system_1 = require("../file-system/file-system");
const FORM_DATA = /^multipart\/form-data;.*boundary=(?:"([^"]+)"|([^;]+))/;
function getBoundary(contentType) {
    const match = contentType?.match(FORM_DATA);
    const boundary = match?.[1] ?? match?.[2] ?? null;
    return boundary;
}
async function toFormData(keyValues, platform = {}) {
    const formData = new FormData();
    for (const field of keyValues) {
        if (field.disabled)
            continue;
        if (field.type === 'text') {
            const { key, value, contentType } = field;
            if (contentType) {
                formData.append(key, new Blob([value], { type: contentType }), '');
            }
            else {
                formData.append(key, value);
            }
        }
        else {
            if (!platform.fs) {
                throw new Error('Unable to append file field, filesystem not provided');
            }
            const { key, src, contentType } = field;
            const paths = Array.isArray(src) ? src : [src];
            for (const path of paths) {
                const data = await (0, file_system_1.fs)(platform.fs).readFile(path);
                const file = new File([data], path, { type: contentType });
                formData.append(key, file);
            }
        }
    }
    return formData;
}
async function serializeFormData(input, options = {}, platform = {}) {
    const formData = Array.isArray(input) ? await toFormData(input, platform) : input;
    const boundary = options.boundary ?? generateBoundary();
    const response = new Response(formData);
    let text = await response.text();
    // For consistency, ensure trailing newline
    if (!text.endsWith('\r\n'))
        text += '\r\n';
    // Replace generated boundary with user-defined or @postman/form-data approach
    const generatedBoundary = getBoundary(response.headers.get('content-type') ?? '');
    if (generatedBoundary) {
        text = text.replaceAll(generatedBoundary, boundary);
    }
    const data = new TextEncoder().encode(text);
    return { data, boundary };
}
/**
 * Generate a 50-character boundary similar to those used by Firefox,
 * that is optimized for boyer-moore parsing
 *
 * From @postman/form-data:
 * https://github.com/postmanlabs/form-data/blob/f1061fbc09ccea2fd4a1abfe70c52dd427a4d7c1/lib/form_data.js#L373-L382
 */
function generateBoundary() {
    // This generates a 50 character boundary similar to those used by Firefox.
    // They are optimized for boyer-moore parsing.
    var boundary = '--------------------------';
    for (var i = 0; i < 24; i++) {
        boundary += Math.floor(Math.random() * 10).toString(16);
    }
    return boundary;
}
//# sourceMappingURL=form-data.js.map