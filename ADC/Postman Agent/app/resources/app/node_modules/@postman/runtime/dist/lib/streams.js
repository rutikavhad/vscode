"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.iterate = iterate;
exports.values = values;
exports.done = done;
const promises_1 = require("./promises");
/**
 * Create an async iterator for a ReadableStream
 * https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream#async_iteration
 *
 * (built-in support is only available in some environments)
 *
 * @example
 * ```
 * for await (const value of iterate(stream)) {
 *   // ...
 * }
 * ```
 * @param {ReadableStream} stream
 */
function iterate(stream) {
    return values(stream, { preventCancel: false });
}
/**
 * Create a `values` async iterator for a ReadableStream
 * https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream#async_iteration
 *
 * (built-in support is only available in some environments)
 *
 * @example
 * ```
 * for await (const value of values(stream, { preventCancel: true })) {
 *   // ...
 * }
 * ```
 *
 * @param {ReadableStream} stream
 * @param {object} [options]
 * @param {boolean} [options.preventCancel = false] don't cancel stream when returning early from iteration
 */
function values(stream, options) {
    const preventCancel = options?.preventCancel ?? false;
    return {
        [Symbol.asyncIterator]() {
            const reader = stream.getReader();
            // Release stream with guards for invalid state from unlocked or releasing
            const released = (0, promises_1.promiseWithResolvers)();
            let readerReleased = false;
            const safeReleaseReader = () => {
                if (readerReleased || !stream.locked)
                    return;
                try {
                    // Note: need to resolve released before releasing,
                    // otherwise `.read()` errors from `.releaseLock()` before `released.promise` resolves
                    released.resolve({ value: undefined, done: true });
                    reader.releaseLock();
                }
                catch (_error) {
                    // (ignore invalid state errors - reader may have been released already)
                }
                finally {
                    readerReleased = true;
                }
            };
            // Cancel stream with guards for invalid state from cancelled or cancelling
            let cancelled = false;
            let cancelling;
            const safeStreamCancel = async () => {
                if (cancelled)
                    return;
                if (cancelling)
                    return cancelling;
                try {
                    await (cancelling = stream.cancel());
                }
                catch (_error) {
                    // (ignore cancellation errors during cleanup)
                }
                finally {
                    cancelled = true;
                }
            };
            options?.signal?.addEventListener('abort', () => {
                (async () => {
                    safeReleaseReader();
                    await safeStreamCancel();
                })().catch((_error) => {
                    // (ignore abort errors)
                });
            });
            return {
                async next() {
                    // Try to read from the stream as long as the reader has not been released
                    //
                    // Resolves:
                    //
                    // - Invalid state: Releasing reader
                    // - Invalid state: The reader is not attached to a stream
                    const { value, done } = await Promise.race([
                        reader.read(),
                        released.promise,
                    ]);
                    return !!done ?
                        { value: undefined, done: true }
                        : { value, done: false };
                },
                async return() {
                    safeReleaseReader();
                    if (!preventCancel)
                        await safeStreamCancel();
                    return { done: true, value: undefined };
                },
            };
        },
    };
}
/**
 * Wait for a stream to be done, successfully or not
 */
async function done(stream) {
    const reader = stream.getReader();
    try {
        while (true) {
            const { done } = await reader.read();
            if (done)
                break;
        }
    }
    finally {
        reader.releaseLock();
    }
}
//# sourceMappingURL=streams.js.map