"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isTypedArray = isTypedArray;
exports.toTypedArray = toTypedArray;
exports.combineInto = combineInto;
exports.limitLength = limitLength;
function isTypedArray(value) {
    return ArrayBuffer.isView(value) && !(value instanceof DataView);
}
/**
 * Ensure given value is a TypedArray, converted ArrayBuffer and DataView to Uint8Array
 */
function toTypedArray(buffer) {
    return (isTypedArray(buffer) ? buffer
        : buffer instanceof DataView ?
            new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength)
            : new Uint8Array(buffer));
}
/**
 * Combine a set of buffers (ArrayBuffer | TypedArray | DataView) into the given TypedArray
 *
 * @example
 * ```ts
 * const values = [
 *   new Uint8Array([97]),
 *   new Uint8Array([98]),
 *   new Uint8Array([99]),
 * ];
 * const result = combineInto(Uint8Array, values);
 * const text = new TextDecoder().decode(result); // 'abc'
 * ```
 */
function combineInto(Constructor, arrays) {
    const slices = arrays.map((array) => array instanceof DataView ?
        new Constructor(array.buffer, array.byteOffset, array.byteLength)
        : array instanceof ArrayBuffer ? new Constructor(array)
            : array);
    const length = slices.reduce((total, slice) => total + slice.length, 0);
    const result = new Constructor(length);
    let offset = 0;
    for (const slice of slices) {
        result.set(slice, offset);
        offset += slice.length;
    }
    return result;
}
/**
 * Limit the length of the given data, truncating if necessary
 */
function limitLength(data, length) {
    return data.byteLength > length ? data.slice(0, length) : data;
}
//# sourceMappingURL=typed-array.js.map