"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SECURE_PROTOCOLS = void 0;
exports.parseURL = parseURL;
exports.toHref = toHref;
exports.isSupportedProtocol = isSupportedProtocol;
exports.ensureProtocol = ensureProtocol;
exports.toProtocol = toProtocol;
exports.isProtocol = isProtocol;
exports.isTLS = isTLS;
exports.replacePathVariables = replacePathVariables;
exports.setQueryParameters = setQueryParameters;
exports.parseQueryParam = parseQueryParam;
const encoder_1 = require("postman-url-encoder/encoder");
const parser_1 = require("postman-url-encoder/parser");
const HAS_PROTOCOL = /^[a-z0-9+.-]+:\/\//i;
/**
 * Parse the given string as a URL, with optional default protocol and URL encoding
 *
 * @example
 * ```ts
 * const url = parseURL('username:password@localhost:3000/path/to/page?query=123&sort=asc#section2');
 * console.log(url);
 *
 * // Output:
 * // {
 * //   href: 'http://username:password@localhost:3000/path/to/page?query=123&sort=asc#section2',
 * //   origin: 'http://localhost:3000',
 * //   protocol: 'http:',
 * //   username: 'username'
 * //   password: 'password',
 * //   host: 'localhost:3000',
 * //   hostname: 'localhost',
 * //   port: '3000',
 * //   pathname: '/path/to/page',
 * //   search: '?query=123&sort=asc',
 * //   hash: '#section2',
 * // }
 * ```
 *
 * @param input - The URL string to parse
 * @param [options] - Options for parsing the URL
 * @params [options.defaultProtocol = 'http:']
 * @params [options.urlEncoding = true] - Perform URL-encoding
 * @returns Parsed URL object
 */
function parseURL(input, options = {}) {
    const { defaultProtocol = 'http:', urlEncoding = true } = options;
    input = ensureProtocol(input, defaultProtocol);
    try {
        const url = (0, parser_1.parse)(input);
        // Note: hostname is always encoded
        const protocol = `${url.protocol}:`;
        const hostname = (0, encoder_1.encodeHost)(url.host?.join('.').toLowerCase() ?? '');
        let [username = '', password = ''] = url.auth ?? [];
        let port = url.port ?? '';
        let pathname = `/${url.path?.join('/') ?? ''}`;
        let search = url.query ? `?${url.query.join('&')}` : '';
        let hash = url.hash ? `#${url.hash}` : '';
        if (urlEncoding) {
            username = (0, encoder_1.encodeUserInfo)(username);
            password = (0, encoder_1.encodeUserInfo)(password);
            pathname = (0, encoder_1.encodePath)(pathname);
            search = (0, encoder_1.encodeQueryParam)(search);
            hash = (0, encoder_1.encodeFragment)(hash);
        }
        const host = port ? `${hostname}:${port}` : hostname;
        const origin = `${protocol}//${host}`;
        const href = toHref({
            protocol,
            username,
            password,
            host,
            pathname,
            search,
            hash,
        });
        return {
            href,
            origin,
            protocol,
            username,
            password,
            host,
            hostname,
            port,
            pathname,
            search,
            hash,
        };
        /* v8 ignore next 3 */
    }
    catch (_) {
        throw new Error(`Invalid URL: ${input}`);
    }
}
/**
 * Combine a parsed URL back into a string
 */
function toHref(url) {
    const { protocol, username = '', password = '', host, pathname = '', search = '', hash = '', } = url;
    const auth = (username && password) || password ? `${username}:${password}@`
        : username ? `${username}@`
            : '';
    return `${protocol}//${auth}${host}${pathname}${search}${hash}`;
}
//
// #region Protocols
//
function isSupportedProtocol(url, supportedProtocols) {
    return supportedProtocols.map(toProtocol).includes(toProtocol(url.protocol));
}
/**
 * Ensure the given URL has a protocol, adding the default protocol if not
 */
function ensureProtocol(input, defaultProtocol = 'http:') {
    if (HAS_PROTOCOL.test(input))
        return input;
    return `${toProtocol(defaultProtocol)}//${input}`;
}
function toProtocol(input) {
    return isProtocol(input) ? input : `${input}:`;
}
function isProtocol(input) {
    return input.endsWith(':');
}
//
// #region TLS
//
exports.SECURE_PROTOCOLS = ['https:', 'wss:', 'mqtts:', 'alis:', 'ssl:'];
function isTLS(url) {
    return exports.SECURE_PROTOCOLS.includes(toProtocol(url.protocol));
}
//
// #region Path
//
/**
 * Replace path variables (`:{key}`) in given pathname (`/a/:b/c`)
 *
 * @example
 * ```ts
 * const pathVariables = [
 *   { key: 'a', value: 'aaa' },
 *   { key: 'b', value: 'bbb', disabled: true }
 *   { key: ':c', value: 'ccc' }
 * ];
 * const pathname = replacePathVariables('/:a/:b/::c/:d', pathVariables);
 *
 * // pathname = '/aaa/:b/ccc/:d'
 * ```
 */
function replacePathVariables(pathname, pathVariables) {
    const byKey = {};
    for (const pathVariable of pathVariables) {
        byKey[pathVariable.key] = pathVariable;
    }
    const replaced = pathname
        .split('/')
        .map((segment) => {
        if (!segment.startsWith(':')) {
            return segment;
        }
        const key = segment.slice(1);
        const pathVariable = byKey[key];
        if (pathVariable &&
            (!('disabled' in pathVariable) || !pathVariable.disabled) &&
            pathVariable.value) {
            return pathVariable.value;
        }
        return segment;
    })
        .join('/');
    return replaced;
}
//
// #region Query Params
//
/**
 * Add query parameters to given search string, overwriting existing keys that match
 *
 * @example
 * ```ts
 * const queryParams = [{ key: 'a', value: 'aaa' }, { key: 'b', value: null }];
 * const search = addQueryParameters('?a=1e=5', queryParams);
 *
 * // search = ?e=5&a=aaa&b
 * ```
 */
function setQueryParameters(search, queryParams, options = {}) {
    const { urlEncoding = true } = options;
    // In the Postman UI, the URL and queryParams are synchronized,
    // but when sending a request with runtime, these values may not match
    // (e.g. enable a query parameter in a script or add a query parameter in auth)
    //
    // Reference: in postman-runtime, url is string or parsed URL that includes separate query field
    //
    // (contrary to the new approach where information is stored in url _and_ queryParams)
    //
    // Approach:
    //
    // Any keys in `queryParams` "win" and override `url` query parameters,
    // otherwise existing `url` query parameters remain.
    //
    // There are cases where `queryParams` could be _in addition_ to values in `url`,
    // e.g. `url = 'localhost:9000?a=1'` and `queryParams = [{key: 'a', value: '2'}]`,
    // but based on how Postman builds the URL, assume `url` is generally derived from `queryParams`
    // and should override instead of append
    // 1. Parse existing search string
    const existingQueryParams = (0, parser_1.parse)(`http://localhost${search}`).query?.map(parseQueryParam) ?? [];
    // 2. Combine with query parameters, overriding existing with the same key
    const overrideKeys = new Set(queryParams.map((keyValue) => keyValue.key).filter(Boolean));
    const combinedQueryParams = existingQueryParams
        .filter((keyValue) => !keyValue.key || !overrideKeys.has(keyValue.key))
        .concat(queryParams)
        .filter((keyValue) => keyValue.key != null);
    if (!combinedQueryParams.length)
        return '';
    // 3. Concat and encode into search string
    const encodedQueryParams = combinedQueryParams
        .map((keyValue) => keyValue.value == null ?
        keyValue.key
        : `${keyValue.key}=${keyValue.value}`)
        .map((queryParam) => urlEncoding ? (0, encoder_1.encodeQueryParam)(queryParam) : queryParam);
    return `?${encodedQueryParams.join('&')}`;
}
/**
 * Parse the given string into a query parameter key-value
 */
function parseQueryParam(queryParam) {
    if (!queryParam.includes('=')) {
        return { key: queryParam, value: null };
    }
    const [key, ...parts] = queryParam.split('=');
    const value = parts.join('=');
    return { key, value };
}
//# sourceMappingURL=urls.js.map