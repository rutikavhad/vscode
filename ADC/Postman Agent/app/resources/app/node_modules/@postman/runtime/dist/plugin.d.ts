import type { GraphQLRequest } from '@postman/runtime.models';
import type { AnyEvent, BuiltInEvent, InternalEvent, RuntimeEvent } from './events.js';
import type { AnyItem, BuiltInItem } from './items.js';
import { EventSubscriber } from './lib/event-stream.js';
import type { EventMatcher } from './lib/match-event.js';
import type { Run } from './run.js';
export type ItemOptions = Record<string, unknown>;
export type AnyItemWithOptions = [AnyItem, ItemOptions];
export type InferItem<TItem extends AnyItem | AnyItemWithOptions> = TItem extends [infer TItemWithOptions, any] ? TItemWithOptions : TItem;
export type InferItemOptions<TAdditionalItem extends AnyItem | AnyItemWithOptions, TSpecificItem extends BuiltInItem | InferItem<TAdditionalItem> = BuiltInItem | InferItem<TAdditionalItem>> = TSpecificItem extends GraphQLRequest ? {
    operationName?: string;
} : TAdditionalItem extends [TSpecificItem, infer TOptions] ? TOptions : never;
/**
 * Define a new Plugin, with optional additional events/items to support
 *
 * @example
 * ```ts
 * type ExampleEvent = { type: 'example:request', payload: unknown };
 * type ExampleItem = { type: 'example-item', payload: Record<string, unknown> };
 *
 * export const example: Plugin<ExampleEvent, ExampleItem> = {
 *   name: 'example',
 *
 *   items: {
 *     ['example-item'](item, run) {
 *       run.enqueue({
 *         type: 'example:request',
 *         payload: {}
 *       });
 *     }
 *   }
 *
 *   execute: {
 *     example: {
 *       request(event, run) {
 *         // ...
 *       }
 *     }
 *   }
 * }
 * ```
 */
export interface Plugin<TAdditionalEvent extends AnyEvent = never, TAdditionalItem extends AnyItem | AnyItemWithOptions = never> {
    name: string;
    items?: {
        [Type in (BuiltInItem | InferItem<TAdditionalItem>)['type']]?: ItemHandler<TAdditionalEvent, TAdditionalItem, Extract<BuiltInItem | InferItem<TAdditionalItem>, {
            type: Type;
        }>>;
    };
    prepare?: EventProcessor<TAdditionalEvent, TAdditionalItem>;
    prepared?: EventProcessor<TAdditionalEvent, TAdditionalItem>;
    script?: EventProcessor<TAdditionalEvent, TAdditionalItem>;
    scripted?: EventProcessor<TAdditionalEvent, TAdditionalItem>;
    resolve?: EventProcessor<TAdditionalEvent, TAdditionalItem>;
    resolved?: EventProcessor<TAdditionalEvent, TAdditionalItem>;
    execute?: EventProcessor<TAdditionalEvent, TAdditionalItem>;
    subscribe?: EventMatcher<RuntimeEvent<InternalEvent | BuiltInEvent | TAdditionalEvent>> | EventSubscriber<RuntimeEvent<InternalEvent | BuiltInEvent | TAdditionalEvent>>;
}
export interface PluginConstructor<TAdditionalEvent extends AnyEvent = never, TAdditionalItem extends AnyItem | AnyItemWithOptions = never> {
    new (): Plugin<TAdditionalEvent, TAdditionalItem>;
}
/**
 * Namespaced event matchers with run information for processing runtime events
 */
export type EventProcessor<TAdditionalEvent extends AnyEvent = never, TAdditionalItem extends AnyItem | AnyItemWithOptions = never> = EventMatcher<RuntimeEvent<InternalEvent | BuiltInEvent | TAdditionalEvent>, [
    Run<TAdditionalEvent, TAdditionalItem>
], void | Promise<void>>;
/**
 * Plugin item handlers for executing an item by "type"
 */
export type ItemHandler<TAdditionalEvent extends AnyEvent = never, TAdditionalItem extends AnyItem | AnyItemWithOptions = never, TMatchedItem extends BuiltInItem | InferItem<TAdditionalItem> = BuiltInItem | InferItem<TAdditionalItem>> = (item: TMatchedItem, run: Run<TAdditionalEvent, TAdditionalItem, TMatchedItem>) => void | Promise<void>;
export declare function isPlugin(input: unknown): input is Plugin;
