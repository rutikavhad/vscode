"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.digestAuth = exports.DigestAuthConfig = void 0;
const runtime_models_1 = require("@postman/runtime.models");
const z = __importStar(require("zod/v4-mini"));
const http_body_1 = require("../../../items/http/http-body");
const arrays_1 = require("../../../lib/arrays");
const randomness_1 = require("../../../lib/crypto/randomness");
const key_values_1 = require("../../../lib/key-values");
const objects_1 = require("../../../lib/objects");
const urls_1 = require("../../../lib/urls");
const auth_1 = require("../auth");
const digest_1 = require("./digest");
const DIGEST_CONTEXT = Symbol('digest');
exports.DigestAuthConfig = z.object({
    algorithm: z.optional(digest_1.DigestAlgorithm),
    username: z.string(),
    password: z.string(),
    nonce: z.optional(z.string()),
    realm: z.optional(z.string()),
    qop: z.optional(z.string()),
    opaque: z.optional(z.string()),
    nonceCount: z.optional(z.string()),
    clientNonce: z.optional(z.string()),
});
exports.digestAuth = {
    name: 'digest-auth',
    prepared: {
        async 'http:received-response-start'(event, run) {
            if (!runtime_models_1.HTTPRequest.is(run.item))
                return;
            const auth = (0, auth_1.resolveAuth)(run, 'digest');
            if (!auth)
                return;
            const context = run.context[DIGEST_CONTEXT];
            if (!context)
                return;
            const incrementNonceCount = () => {
                run.patch((context) => {
                    const digest = context[DIGEST_CONTEXT];
                    if (!digest)
                        return;
                    const nonceCount = (0, digest_1.parseNonceCount)(digest.params.nonceCount);
                    digest.params.nonceCount = (0, digest_1.formatNonceCount)(nonceCount + 1);
                });
            };
            // If authorized, no need to authenticate,
            // but increase nonce count to avoid replay attacks
            if (event.payload.statusCode !== 401 &&
                event.payload.statusCode !== 403) {
                return incrementNonceCount();
            }
            const result = exports.DigestAuthConfig.safeParse((0, key_values_1.keyValuesToObject)(auth.digest ?? []));
            if (!result.success)
                return;
            const config = result.data;
            let { algorithm } = config;
            // Check for www-authenticate header on response
            const challenge = (0, digest_1.findDigestChallenge)(event.payload.headers, algorithm);
            if (!challenge) {
                return incrementNonceCount();
            }
            // Extract and prepare Digest parameters
            const existing = context?.params;
            const params = { ...(0, digest_1.parseDigestChallenge)(challenge) };
            if (params.qop || existing?.qop) {
                params.clientNonce = (0, randomness_1.randomASCII)(8);
                params.nonceCount = (0, digest_1.formatNonceCount)(1);
            }
            // If nothing is changing when re-authenticating, do try again
            if ((0, objects_1.isShallowEqual)(existing, params)) {
                return;
            }
            run.patch((context) => {
                context[DIGEST_CONTEXT] = { params };
            });
            run.stopPropagation(event);
            return await run.retry();
        },
    },
    resolved: {
        async 'http:send-request'(event, run) {
            if (!runtime_models_1.HTTPRequest.is(run.item))
                return;
            const auth = (0, auth_1.resolveAuth)(run, 'digest');
            if (!auth)
                return;
            // If not authenticating, initialize and allow request to proceed
            const context = run.context[DIGEST_CONTEXT];
            if (!context) {
                return;
            }
            const result = exports.DigestAuthConfig.safeParse((0, key_values_1.keyValuesToObject)(auth.digest ?? []));
            if (!result.success)
                return;
            const config = result.data;
            let { algorithm, username, password, nonce = context.params.nonce, realm = context.params.realm, qop = context.params.qop, opaque = context.params.opaque, clientNonce = context.params.clientNonce, nonceCount = context.params.nonceCount, } = config;
            if (!username || !realm) {
                return;
            }
            const url = (0, urls_1.parseURL)(event.payload.url);
            const authorization = await (0, digest_1.generateDigestAuthorization)({
                algorithm,
                username,
                password,
                nonce,
                realm,
                qop,
                opaque,
                clientNonce,
                nonceCount,
                method: event.payload.method,
                uri: `${url.pathname}${url.search}`,
                async body(hashAlgorithm) {
                    return await (0, http_body_1.computeBodyHash)(event.payload, hashAlgorithm, 'hex', run.runtime.platform);
                },
            });
            run.patch(event, (payload) => {
                (0, arrays_1.filter)(payload.headers, (header) => header.key.toLowerCase() !== 'authorization');
                payload.headers.push({
                    key: 'authorization',
                    value: authorization,
                    system: true,
                });
            });
        },
    },
};
//# sourceMappingURL=digest-auth-plugin.js.map