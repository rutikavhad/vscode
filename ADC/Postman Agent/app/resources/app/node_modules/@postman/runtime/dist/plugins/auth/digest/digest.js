"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.DigestAlgorithm = void 0;
exports.generateDigestAuthorization = generateDigestAuthorization;
exports.findDigestChallenge = findDigestChallenge;
exports.parseDigestChallenge = parseDigestChallenge;
exports.parseNonceCount = parseNonceCount;
exports.formatNonceCount = formatNonceCount;
const z = __importStar(require("zod/v4-mini"));
const hashing_1 = require("../../../lib/crypto/hashing");
exports.DigestAlgorithm = z.literal([
    'MD5',
    'MD5-sess',
    'SHA-256',
    'SHA-256-sess',
    'SHA-512-256',
    'SHA-512-256-sess',
]);
/**
 * Generate a Digest authorization header
 *
 * https://datatracker.ietf.org/doc/html/rfc2617#section-3.2.2
 */
async function generateDigestAuthorization(params) {
    const { algorithm, username, password, nonce, realm, qop, opaque, clientNonce, nonceCount, method, uri, body, } = params;
    const hashAlgorithm = algorithm?.startsWith('SHA-512') ? 'SHA-512'
        : algorithm?.startsWith('SHA-256') ? 'SHA-256'
            : 'MD5';
    const isDigestAccessAuth = algorithm?.endsWith('-sess') ?? false;
    // https://datatracker.ietf.org/doc/html/rfc2617#section-3.2.2
    // TODO when given qop="auth,auth-int", need to pick one instead of using both
    const isUsingQualityOfProtection = qop?.includes('auth') || qop?.includes('auth-int');
    const isUsingIntegrityProtection = qop?.includes('auth-int');
    // A1: https://datatracker.ietf.org/doc/html/rfc2617#section-3.2.2.2
    //
    // If the "algorithm" directive's value is "MD5" or is unspecified, then
    // A1 is:
    //
    //    A1       = unq(username-value) ":" unq(realm-value) ":" passwd
    //
    // ...
    //
    // If the "algorithm" directive's value is "MD5-sess", ...:
    //
    //    A1       = H( unq(username-value) ":" unq(realm-value)
    //                   ":" passwd )
    //                   ":" unq(nonce-value) ":" unq(cnonce-value)
    let A1;
    if (isDigestAccessAuth) {
        const A0 = await (0, hashing_1.computeHash)(`${username}:${realm}:${password}`, hashAlgorithm, 'hex');
        A1 = `${A0}:${nonce}:${clientNonce}`;
    }
    else {
        A1 = `${username}:${realm}:${password}`;
    }
    // A2: https://datatracker.ietf.org/doc/html/rfc2617#section-3.2.2.3
    //
    // If the "qop" directive's value is "auth" or is unspecified, then A2
    //  is:
    //
    //     A2       = Method ":" digest-uri-value
    //
    //  If the "qop" value is "auth-int", then A2 is:
    //
    //     A2       = Method ":" digest-uri-value ":" H(entity-body)
    const bodyHash = isUsingIntegrityProtection ? await body?.(hashAlgorithm) : undefined;
    const A2 = isUsingIntegrityProtection ?
        `${method}:${uri}:${bodyHash}`
        : `${method}:${uri}`;
    const [A1Digest, A2Digest] = await Promise.all([
        (0, hashing_1.computeHash)(A1, hashAlgorithm, 'hex'),
        (0, hashing_1.computeHash)(A2, hashAlgorithm, 'hex'),
    ]);
    // Request-Digest: https://datatracker.ietf.org/doc/html/rfc2617#section-3.2.2.1
    //
    // If the "qop" value is "auth" or "auth-int":
    //
    //    request-digest  = <"> < KD ( H(A1),     unq(nonce-value)
    //                                        ":" nc-value
    //                                        ":" unq(cnonce-value)
    //                                        ":" unq(qop-value)
    //                                        ":" H(A2)
    //                                ) <">
    //
    // If the "qop" directive is not present (this construction is for
    // compatibility with RFC 2069):
    //
    //    request-digest  =
    //               <"> < KD ( H(A1), unq(nonce-value) ":" H(A2) ) >
    // <">
    //
    // From https://datatracker.ietf.org/doc/html/rfc2617#section-3.2.1:
    //
    // KD(secret, data) = H(concat(secret, ":", data))
    const request = isUsingQualityOfProtection ?
        `${A1Digest}:${nonce}:${nonceCount}:${clientNonce}:${qop}:${A2Digest}`
        : `${A1Digest}:${nonce}:${A2Digest}`;
    const requestDigest = await (0, hashing_1.computeHash)(request, hashAlgorithm, 'hex');
    // Finally, build header from parameters
    //
    // From https://datatracker.ietf.org/doc/html/rfc2617#section-3.2.2
    //
    // credentials      = "Digest" digest-response
    // digest-response  = 1#( username | realm | nonce | digest-uri
    //                 | response | [ algorithm ] | [cnonce] |
    //                 [opaque] | [message-qop] |
    //                     [nonce-count]  | [auth-param] )
    //
    // username         = "username" "=" username-value
    // username-value   = quoted-string
    // digest-uri       = "uri" "=" digest-uri-value
    // digest-uri-value = request-uri   ; As specified by HTTP/1.1
    // message-qop      = "qop" "=" qop-value
    // cnonce           = "cnonce" "=" cnonce-value
    // cnonce-value     = nonce-value
    // nonce-count      = "nc" "=" nc-value
    // nc-value         = 8LHEX
    // response         = "response" "=" request-digest
    // request-digest = <"> 32LHEX <">
    // LHEX             =  "0" | "1" | "2" | "3" |
    //                     "4" | "5" | "6" | "7" |
    //                     "8" | "9" | "a" | "b" |
    //                     "c" | "d" | "e" | "f"
    const headerEntries = [
        ['username', `"${username}"`],
        ['realm', `"${realm}"`],
        ['nonce', `"${nonce}"`],
        ['uri', `"${uri}"`],
    ];
    if (algorithm) {
        headerEntries.push(['algorithm', `"${algorithm}"`]);
    }
    if (isUsingQualityOfProtection) {
        headerEntries.push(['qop', qop]);
    }
    if (isUsingQualityOfProtection || isDigestAccessAuth) {
        if (nonceCount) {
            headerEntries.push(['nc', nonceCount]);
        }
        headerEntries.push(['cnonce', `"${clientNonce}"`]);
    }
    headerEntries.push(['response', `"${requestDigest}"`]);
    if (opaque) {
        headerEntries.push(['opaque', `"${opaque}"`]);
    }
    const digestParameters = headerEntries
        .map(([key, value]) => `${key}=${value}`)
        .join(', ');
    return `Digest ${digestParameters}`;
}
/**
 * Find the www-authenticate header (matching the given algorithm) in the given headers
 *
 * @param headers key-value headers
 * @param {DigestAlgorithm} [algorithm]
 * @returns
 */
function findDigestChallenge(headers, algorithm) {
    const digestHeaders = headers
        .filter((header) => header.key.toLowerCase() === 'www-authenticate' &&
        header.value.toLowerCase().startsWith('digest'))
        .map((header) => ({
        key: header.key.toLowerCase(),
        value: header.value,
        lowercase: header.value.toLowerCase(),
    }));
    if (!algorithm) {
        return digestHeaders[0]?.value ?? null;
    }
    // Uses MD5 by default. If no algorithm specified, match MD5
    // https://datatracker.ietf.org/doc/html/rfc7616
    const search = algorithm.toLowerCase();
    const matching = digestHeaders.find((header) => !header.lowercase.includes('algorithm=') ?
        search === 'md5'
        : header.lowercase.includes(`algorithm="${search}"`));
    return matching?.value ?? null;
}
/**
 * Decode Digest authentication parameters from www-authenticate header
 */
function parseDigestChallenge(header) {
    const nonce = header.match(/nonce="([^"]*)"/i)?.[1] ?? '';
    const realm = header.match(/realm="([^"]*)"/i)?.[1] ?? '';
    const qop = header.match(/qop="([^"]*)"/i)?.[1] ?? '';
    const opaque = header.match(/opaque="([^"]*)"/i)?.[1] ?? '';
    return { nonce, realm, qop, opaque };
}
//
// #region Nonce
//
function parseNonceCount(value = '') {
    const count = parseInt(value, 10);
    return isNaN(count) ? 0 : count;
}
function formatNonceCount(value) {
    return String(value).padStart(8, '0');
}
//# sourceMappingURL=digest.js.map