"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.edgegridAuth = exports.EdgeGridAuthConfig = void 0;
const runtime_models_1 = require("@postman/runtime.models");
const z = __importStar(require("zod/v4-mini"));
const http_body_1 = require("../../../items/http/http-body");
const arrays_1 = require("../../../lib/arrays");
const hashing_1 = require("../../../lib/crypto/hashing");
const key_values_1 = require("../../../lib/key-values");
const sizes_1 = require("../../../lib/sizes");
const typed_array_1 = require("../../../lib/typed-array");
const urls_1 = require("../../../lib/urls");
const auth_1 = require("../auth");
const edgegrid_1 = require("./edgegrid");
exports.EdgeGridAuthConfig = z.object({
    accessToken: z.string(),
    clientToken: z.string(),
    clientSecret: z.string(),
    maxBodySize: z.optional(z.number()),
    baseURL: z.optional(z.string()),
    nonce: z.optional(z.string()),
    timestamp: z.optional(z.string()),
    headersToSign: z.optional(z.string()),
});
exports.edgegridAuth = {
    name: 'edgegrid-auth',
    resolved: {
        async 'http:send-request'(event, run) {
            if (!runtime_models_1.HTTPRequest.is(run.item))
                return;
            const auth = (0, auth_1.resolveAuth)(run, 'edgegrid');
            if (!auth)
                return;
            const result = exports.EdgeGridAuthConfig.safeParse((0, key_values_1.keyValuesToObject)(auth.edgegrid ?? []));
            if (!result.success)
                return;
            const config = result.data;
            const { accessToken, clientToken, clientSecret, maxBodySize = 128 * sizes_1.KiB, nonce = crypto.randomUUID(), timestamp = (0, edgegrid_1.formatTimestamp)(new Date()), } = config;
            const baseURL = config.baseURL ? (0, urls_1.parseURL)(config.baseURL).host : undefined;
            const url = (0, urls_1.parseURL)(event.payload.url);
            const headers = (0, key_values_1.keyValuesToObject)(event.payload.headers.map((header) => ({
                ...header,
                key: header.key.toLowerCase(),
            })));
            const headersToSign = Array.isArray(config.headersToSign) ? config.headersToSign
                : typeof config.headersToSign === 'string' ?
                    config.headersToSign.split(',').map((part) => part.trim())
                    : [];
            const bodyHash = event.payload.method === 'POST' ?
                await (0, hashing_1.computeHash)((0, typed_array_1.limitLength)(await (0, http_body_1.readBody)(event.payload, run.runtime.platform), maxBodySize), 'SHA-256', 'base64')
                : undefined;
            const authorization = await (0, edgegrid_1.generateEdgeGridAuthorization)({
                accessToken,
                clientToken,
                clientSecret,
                nonce,
                timestamp,
                headers,
                headersToSign,
                bodyHash,
                method: event.payload.method,
                baseURL,
                url: {
                    protocol: url.protocol,
                    host: url.host,
                    path: `${url.pathname}${url.search}`,
                },
            });
            run.patch(event, (payload) => {
                (0, arrays_1.filter)(payload.headers, (header) => header.key.toLowerCase() !== 'authorization');
                payload.headers.push({
                    key: 'authorization',
                    value: authorization,
                    system: true,
                });
            });
        },
    },
};
//# sourceMappingURL=edgegrid-auth-plugin.js.map