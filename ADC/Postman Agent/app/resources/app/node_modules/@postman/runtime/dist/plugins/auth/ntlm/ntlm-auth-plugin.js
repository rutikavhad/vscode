"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ntlmAuth = exports.NTLMAuthConfig = void 0;
const runtime_models_1 = require("@postman/runtime.models");
const z = __importStar(require("zod/v4-mini"));
const http_headers_1 = require("../../../items/http/http-headers");
const functions_1 = require("../../../lib/functions");
const key_values_1 = require("../../../lib/key-values");
const auth_1 = require("../auth");
const ntlm = __importStar(require("./ntlm"));
const NTLM_CONTEXT = Symbol('ntlm');
exports.NTLMAuthConfig = z.object({
    domain: z.optional(z.string()),
    workstation: z.optional(z.string()),
    username: z.optional(z.string()),
    password: z.optional(z.string()),
});
exports.ntlmAuth = {
    name: 'ntlm',
    prepared: {
        'http:send-request'(event, run) {
            if (!runtime_models_1.HTTPRequest.is(run.item))
                return;
            const auth = (0, auth_1.resolveAuth)(run, 'ntlm');
            if (!auth)
                return;
            if (run.context[NTLM_CONTEXT]) {
                const { header } = run.context[NTLM_CONTEXT];
                if (!header)
                    return;
                run.patch(event, (payload) => {
                    payload.headers.push({
                        key: 'Authorization',
                        value: header,
                        system: true,
                    });
                });
            }
            else {
                run.patch((context) => {
                    context[NTLM_CONTEXT] = {
                        state: 'initialized',
                        header: undefined,
                    };
                });
            }
        },
        async 'http:received-response-start'(event, run) {
            if (!runtime_models_1.HTTPRequest.is(run.item))
                return;
            const auth = (0, auth_1.resolveAuth)(run, 'ntlm');
            if (!auth)
                return;
            const context = run.context[NTLM_CONTEXT];
            if (!context)
                return;
            const done = () => {
                run.patch((context) => {
                    context[NTLM_CONTEXT] = {
                        state: 'done',
                        header: undefined,
                    };
                });
            };
            // Should be unauthorized to start NTLM authorization process
            if (event.payload.statusCode !== 401 &&
                event.payload.statusCode !== 403) {
                return done();
            }
            const result = exports.NTLMAuthConfig.safeParse((0, key_values_1.keyValuesToObject)(auth.ntlm));
            if (!result.success)
                return;
            const config = result.data;
            let { domain = '', workstation = '', username = '', password = '', } = config;
            if (!domain) {
                ({ username, domain } = parseParametersFromUsername(username));
            }
            if (context.state === 'initialized') {
                if (!hasNTLMChallenge(event.payload.headers)) {
                    return done();
                }
                const negotiateMessage = ntlm.createType1Message({
                    domain,
                    workstation,
                });
                run.patch((context) => {
                    context[NTLM_CONTEXT] = {
                        state: 't1-message-created',
                        header: negotiateMessage,
                    };
                });
                run.stopPropagation(event);
                return await run.retry();
            }
            if (context.state === 't1-message-created') {
                // Type 1 message was sent to the server
                // There can be multiple headers present with key `www-authenticate`.
                // Iterate to get the one which has the NTLM hash, using the first found.
                const ntlmType2Header = event.payload.headers.find(function (header) {
                    return (String(header.key).toLowerCase() === 'www-authenticate' &&
                        header.value.startsWith('NTLM '));
                });
                if (!ntlmType2Header) {
                    throw new Error('ntlm auth: server did not send NTLM type 2 message');
                }
                const challengeMessage = ntlm.parseType2Message(ntlmType2Header.value, functions_1.noop);
                if (!challengeMessage) {
                    throw new Error('ntlm auth: server did not correctly process authentication request');
                }
                const authenticateMessage = await ntlm.createType3Message(challengeMessage, {
                    domain,
                    workstation,
                    username,
                    password,
                });
                run.patch((context) => {
                    context[NTLM_CONTEXT] = {
                        state: 't3-message-created',
                        header: authenticateMessage,
                    };
                });
                run.stopPropagation(event);
                return await run.retry();
            }
            if (context.state === 't3-message-created') {
                // Means we have tried to authenticate, nothing more to be done
            }
            // Unrecognized state or no action taken, reset and continue
            return done();
        },
    },
};
//
// #region General
//
/**
 * Check if `WWW-Authenticate` header has NTLM challenge.
 */
function hasNTLMChallenge(headers) {
    // Case 1: multiple headers
    // - WWW-Authenticate: NTLM
    // - WWW-Authenticate: Negotiate
    if ((0, http_headers_1.hasHeader)(headers, 'www-authenticate', 'ntlm') ||
        (0, http_headers_1.hasHeader)(headers, 'www-authenticate', 'negotiate')) {
        return true;
    }
    // Case 2: single header
    // - WWW-Authenticate: Negotiate, NTLM
    return String((0, http_headers_1.getHeader)(headers, 'www-authenticate')?.value)
        .toLowerCase()
        .includes('ntlm');
}
/**
 * Parses the username to separate username and domain. It can handle two formats:
 *   - Down-Level Logon name format `DOMAIN\USERNAME`
 *   - User Principal Name format `USERNAME@DOMAIN`
 */
function parseParametersFromUsername(username) {
    if (!(username && typeof username === 'string')) {
        return {
            username: '',
            domain: '',
        };
    }
    const downlevelLogonParams = username.split('\\');
    const userPrincipleParams = username.split('@');
    // Username should be either of the two formats, not both
    if (downlevelLogonParams.length > 1 && userPrincipleParams.length > 1) {
        return {
            username,
            domain: '',
        };
    }
    // Try to parse from "down-level logon" format
    if (downlevelLogonParams.length === 2 &&
        downlevelLogonParams[0] &&
        downlevelLogonParams[1]) {
        return {
            username: downlevelLogonParams[1],
            domain: downlevelLogonParams[0],
        };
    }
    // Try to parse from "user principal name" format
    if (userPrincipleParams.length === 2 &&
        userPrincipleParams[0] &&
        userPrincipleParams[1]) {
        return {
            username: userPrincipleParams[0],
            domain: userPrincipleParams[1],
        };
    }
    return {
        username,
        domain: '',
    };
}
//# sourceMappingURL=ntlm-auth-plugin.js.map