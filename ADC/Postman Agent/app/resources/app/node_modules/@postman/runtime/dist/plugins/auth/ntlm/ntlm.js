"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createType1Message = createType1Message;
exports.parseType2Message = parseType2Message;
exports.createType3Message = createType3Message;
const des_js_1 = __importDefault(require("des.js"));
const character_encoding_1 = require("../../../lib/character-encoding");
const hashing_1 = require("../../../lib/crypto/hashing");
const md4_1 = require("../../../lib/crypto/md4");
const md5_1 = require("../../../lib/crypto/md5");
const randomness_1 = require("../../../lib/crypto/randomness");
const dates_1 = require("../../../lib/dates");
const typed_array_1 = require("../../../lib/typed-array");
const flags = {
    NTLM_NegotiateUnicode: 0x00000001,
    NTLM_NegotiateOEM: 0x00000002,
    NTLM_RequestTarget: 0x00000004,
    NTLM_Unknown9: 0x00000008,
    NTLM_NegotiateSign: 0x00000010,
    NTLM_NegotiateSeal: 0x00000020,
    NTLM_NegotiateDatagram: 0x00000040,
    NTLM_NegotiateLanManagerKey: 0x00000080,
    NTLM_Unknown8: 0x00000100,
    NTLM_NegotiateNTLM: 0x00000200,
    NTLM_NegotiateNTOnly: 0x00000400,
    NTLM_Anonymous: 0x00000800,
    NTLM_NegotiateOemDomainSupplied: 0x00001000,
    NTLM_NegotiateOemWorkstationSupplied: 0x00002000,
    NTLM_Unknown6: 0x00004000,
    NTLM_NegotiateAlwaysSign: 0x00008000,
    NTLM_TargetTypeDomain: 0x00010000,
    NTLM_TargetTypeServer: 0x00020000,
    NTLM_TargetTypeShare: 0x00040000,
    NTLM_NegotiateExtendedSecurity: 0x00080000,
    NTLM_NegotiateIdentify: 0x00100000,
    NTLM_Unknown5: 0x00200000,
    NTLM_RequestNonNTSessionKey: 0x00400000,
    NTLM_NegotiateTargetInfo: 0x00800000,
    NTLM_Unknown4: 0x01000000,
    NTLM_NegotiateVersion: 0x02000000,
    NTLM_Unknown3: 0x04000000,
    NTLM_Unknown2: 0x08000000,
    NTLM_Unknown1: 0x10000000,
    NTLM_Negotiate128: 0x20000000,
    NTLM_NegotiateKeyExchange: 0x40000000,
    NTLM_Negotiate56: 0x80000000,
};
const typeflags = {
    NTLM_TYPE1_FLAGS: flags.NTLM_NegotiateUnicode +
        flags.NTLM_NegotiateOEM +
        flags.NTLM_RequestTarget +
        flags.NTLM_NegotiateNTLM +
        flags.NTLM_NegotiateOemDomainSupplied +
        flags.NTLM_NegotiateOemWorkstationSupplied +
        flags.NTLM_NegotiateAlwaysSign +
        flags.NTLM_NegotiateExtendedSecurity +
        flags.NTLM_NegotiateVersion +
        flags.NTLM_Negotiate128 +
        flags.NTLM_Negotiate56,
    NTLM_TYPE2_FLAGS: flags.NTLM_NegotiateUnicode +
        flags.NTLM_RequestTarget +
        flags.NTLM_NegotiateNTLM +
        flags.NTLM_NegotiateAlwaysSign +
        flags.NTLM_NegotiateExtendedSecurity +
        flags.NTLM_NegotiateTargetInfo +
        flags.NTLM_NegotiateVersion +
        flags.NTLM_Negotiate128 +
        flags.NTLM_Negotiate56,
};
/**
 * Generate an NTLM type 1 message (negotiate)
 * https://davenport.sourceforge.net/ntlm.html#theType1Message
 */
function createType1Message(options) {
    if (!options.domain)
        options.domain = '';
    if (!options.workstation)
        options.workstation = '';
    const domain = options.domain.toUpperCase();
    const workstation = options.workstation.toUpperCase();
    const protocol = 'NTLMSSP\0';
    const BODY_LENGTH = 40;
    let type1flags = typeflags.NTLM_TYPE1_FLAGS;
    if (!domain || domain === '') {
        type1flags = type1flags - flags.NTLM_NegotiateOemDomainSupplied;
    }
    let position = 0;
    const buffer = new Uint8Array(BODY_LENGTH + domain.length + workstation.length);
    const view = new DataView(buffer.buffer);
    for (let i = 0; i < protocol.length; i++) {
        buffer[position++] = protocol.charCodeAt(i);
    }
    view.setUint32(position, 1, true);
    position += 4; // type 1
    view.setUint32(position, type1flags >>> 0, true);
    position += 4; // TYPE1 flag
    view.setUint16(position, domain.length, true);
    position += 2; // domain length
    view.setUint16(position, domain.length, true);
    position += 2; // domain max length
    view.setUint32(position, BODY_LENGTH + workstation.length, true);
    position += 4; // domain buffer offset
    view.setUint16(position, workstation.length, true);
    position += 2; // workstation length
    view.setUint16(position, workstation.length, true);
    position += 2; // workstation max length
    view.setUint32(position, BODY_LENGTH, true);
    position += 4; // workstation buffer offset
    buffer[position++] = 5; // ProductMajorVersion
    buffer[position++] = 1; // ProductMinorVersion
    view.setUint16(position, 2600, true);
    position += 2; // ProductBuild
    buffer[position++] = 0; // VersionReserved1
    buffer[position++] = 0; // VersionReserved2
    buffer[position++] = 0; // VersionReserved3
    buffer[position++] = 15; // NTLMRevisionCurrent
    if (workstation.length != 0) {
        const workstationBytes = character_encoding_1.ASCII.encode(workstation);
        buffer.set(workstationBytes, position);
        position += workstationBytes.length;
    }
    if (domain.length != 0) {
        const domainBytes = character_encoding_1.ASCII.encode(domain);
        buffer.set(domainBytes, position);
        position += domainBytes.length;
    }
    return `NTLM ${character_encoding_1.Base64.decode(buffer)}`;
}
/**
 * Parse an NTLM type 2 message (negotiate)
 * https://davenport.sourceforge.net/ntlm.html#theType2Message
 */
function parseType2Message(rawmsg, callback) {
    const match = rawmsg.match(/NTLM (.+)?/);
    if (!match || !match[1]) {
        callback(new Error("Couldn't find NTLM in the message type2 coming from the server"));
        return null;
    }
    const buffer = character_encoding_1.Base64.encode(match[1]);
    const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    const message = {};
    message.signature = buffer.slice(0, 8);
    message.type = view.getInt16(8, true);
    if (message.type != 2) {
        callback(new Error("Server didn't return a type 2 message"));
        return null;
    }
    message.targetNameLen = view.getInt16(12, true);
    message.targetNameMaxLen = view.getInt16(14, true);
    message.targetNameOffset = view.getInt32(16, true);
    message.targetName = buffer.slice(message.targetNameOffset, message.targetNameOffset + message.targetNameMaxLen);
    message.negotiateFlags = view.getInt32(20, true);
    message.serverChallenge = buffer.slice(24, 32);
    message.reserved = buffer.slice(32, 40);
    if (message.negotiateFlags & flags.NTLM_NegotiateTargetInfo) {
        message.targetInfoLen = view.getInt16(40, true);
        message.targetInfoMaxLen = view.getInt16(42, true);
        message.targetInfoOffset = view.getInt32(44, true);
        message.targetInfo = buffer.slice(message.targetInfoOffset, message.targetInfoOffset + message.targetInfoLen);
    }
    return message;
}
/**
 * Create an NTLM type 3 message (authenticate)
 */
async function createType3Message(message2, options) {
    if (!options.domain)
        options.domain = '';
    if (!options.workstation)
        options.workstation = '';
    if (!options.username)
        options.username = '';
    if (!options.password)
        options.password = '';
    const nonce = message2.serverChallenge;
    const username = options.username;
    const password = options.password;
    const lm_password = options.lm_password;
    const nt_password = options.nt_password;
    const negotiateFlags = message2.negotiateFlags;
    const isUnicode = negotiateFlags & flags.NTLM_NegotiateUnicode;
    const isNegotiateExtendedSecurity = negotiateFlags & flags.NTLM_NegotiateExtendedSecurity;
    const BODY_LENGTH = 72;
    const domainName = options.domain.toUpperCase();
    const workstation = options.workstation.toUpperCase();
    let workstationBytes, domainNameBytes, usernameBytes, encryptedRandomSessionKeyBytes;
    const encryptedRandomSessionKey = '';
    if (isUnicode) {
        workstationBytes = character_encoding_1.UTF16LE.encode(workstation);
        domainNameBytes = character_encoding_1.UTF16LE.encode(domainName);
        usernameBytes = character_encoding_1.UTF16LE.encode(username);
        encryptedRandomSessionKeyBytes = character_encoding_1.UTF16LE.encode(encryptedRandomSessionKey);
    }
    else {
        workstationBytes = character_encoding_1.ASCII.encode(workstation);
        domainNameBytes = character_encoding_1.ASCII.encode(domainName);
        usernameBytes = character_encoding_1.ASCII.encode(username);
        encryptedRandomSessionKeyBytes = character_encoding_1.ASCII.encode(encryptedRandomSessionKey);
    }
    let lmChallengeResponse = calc_resp(lm_password != null ? lm_password : create_LM_hashed_password_v1(password), nonce);
    let ntChallengeResponse = calc_resp(nt_password != null ? nt_password : create_NT_hashed_password_v1(password), nonce);
    if (isNegotiateExtendedSecurity) {
        /*
         * NTLMv2 extended security is enabled. While this technically can mean NTLMv2 extended security with NTLMv1 protocol,
         * servers that support extended security likely also support NTLMv2, so use NTLMv2.
         * This is also how curl implements NTLMv2 "detection".
         * By using NTLMv2, this supports communication with servers that forbid the use of NTLMv1 (e.g. via windows policies)
         *
         * However, the target info is needed to construct the NTLMv2 response so if it can't be negotiated,
         * fall back to NTLMv1 with NTLMv2 extended security.
         */
        const pwhash = nt_password != null ? nt_password : (create_NT_hashed_password_v1(password));
        const clientChallengeBytes = (0, randomness_1.randomValues)(8);
        const challenges = message2.targetInfo ?
            await calc_ntlmv2_resp(pwhash, username, domainName, message2.targetInfo, nonce, clientChallengeBytes)
            : await ntlm2sr_calc_resp(pwhash, nonce, clientChallengeBytes);
        lmChallengeResponse = challenges.lmChallengeResponse;
        ntChallengeResponse = challenges.ntChallengeResponse;
    }
    const signature = 'NTLMSSP\0';
    let position = 0;
    const totalLength = BODY_LENGTH +
        domainNameBytes.length +
        usernameBytes.length +
        workstationBytes.length +
        lmChallengeResponse.length +
        ntChallengeResponse.length +
        encryptedRandomSessionKeyBytes.length;
    const buffer = new Uint8Array(totalLength);
    const view = new DataView(buffer.buffer);
    for (let i = 0; i < signature.length; i++) {
        buffer[position++] = signature.charCodeAt(i);
    }
    view.setUint32(position, 3, true);
    position += 4; // type 3
    view.setUint16(position, lmChallengeResponse.length, true);
    position += 2; // LmChallengeResponseLen
    view.setUint16(position, lmChallengeResponse.length, true);
    position += 2; // LmChallengeResponseMaxLen
    view.setUint32(position, BODY_LENGTH +
        domainNameBytes.length +
        usernameBytes.length +
        workstationBytes.length, true);
    position += 4; // LmChallengeResponseOffset
    view.setUint16(position, ntChallengeResponse.length, true);
    position += 2; // NtChallengeResponseLen
    view.setUint16(position, ntChallengeResponse.length, true);
    position += 2; // NtChallengeResponseMaxLen
    view.setUint32(position, BODY_LENGTH +
        domainNameBytes.length +
        usernameBytes.length +
        workstationBytes.length +
        lmChallengeResponse.length, true);
    position += 4; // NtChallengeResponseOffset
    view.setUint16(position, domainNameBytes.length, true);
    position += 2; // DomainNameLen
    view.setUint16(position, domainNameBytes.length, true);
    position += 2; // DomainNameMaxLen
    view.setUint32(position, BODY_LENGTH, true);
    position += 4; // DomainNameOffset
    view.setUint16(position, usernameBytes.length, true);
    position += 2; // UserNameLen
    view.setUint16(position, usernameBytes.length, true);
    position += 2; // UserNameMaxLen
    view.setUint32(position, BODY_LENGTH + domainNameBytes.length, true);
    position += 4; // UserNameOffset
    view.setUint16(position, workstationBytes.length, true);
    position += 2; // WorkstationLen
    view.setUint16(position, workstationBytes.length, true);
    position += 2; // WorkstationMaxLen
    view.setUint32(position, BODY_LENGTH + domainNameBytes.length + usernameBytes.length, true);
    position += 4; // WorkstationOffset
    view.setUint16(position, encryptedRandomSessionKeyBytes.length, true);
    position += 2; // EncryptedRandomSessionKeyLen
    view.setUint16(position, encryptedRandomSessionKeyBytes.length, true);
    position += 2; // EncryptedRandomSessionKeyMaxLen
    view.setUint32(position, BODY_LENGTH +
        domainNameBytes.length +
        usernameBytes.length +
        workstationBytes.length +
        lmChallengeResponse.length +
        ntChallengeResponse.length, true);
    position += 4; // EncryptedRandomSessionKeyOffset
    const flagsToWrite = isUnicode ?
        typeflags.NTLM_TYPE2_FLAGS
        : typeflags.NTLM_TYPE2_FLAGS - flags.NTLM_NegotiateUnicode;
    view.setUint32(position, flagsToWrite >>> 0, true);
    position += 4; // NegotiateFlags
    buffer[position++] = 5; // ProductMajorVersion
    buffer[position++] = 1; // ProductMinorVersion
    view.setUint16(position, 2600, true);
    position += 2; // ProductBuild
    buffer[position++] = 0; // VersionReserved1
    buffer[position++] = 0; // VersionReserved2
    buffer[position++] = 0; // VersionReserved3
    buffer[position++] = 15; // NTLMRevisionCurrent
    buffer.set(domainNameBytes, position);
    position += domainNameBytes.length;
    buffer.set(usernameBytes, position);
    position += usernameBytes.length;
    buffer.set(workstationBytes, position);
    position += workstationBytes.length;
    buffer.set(lmChallengeResponse, position);
    position += lmChallengeResponse.length;
    buffer.set(ntChallengeResponse, position);
    position += ntChallengeResponse.length;
    buffer.set(encryptedRandomSessionKeyBytes, position);
    position += encryptedRandomSessionKeyBytes.length;
    return `NTLM ${character_encoding_1.Base64.decode(buffer)}`;
}
//
// #region Utilities
//
function create_LM_hashed_password_v1(password) {
    // fix the password length to 14 bytes
    password = password.toUpperCase();
    const passwordBytes = character_encoding_1.ASCII.encode(password);
    const passwordBytesPadded = new Uint8Array(14);
    const sourceEnd = Math.min(14, passwordBytes.length);
    passwordBytesPadded.set(passwordBytes.subarray(0, sourceEnd));
    // split into 2 parts of 7 bytes:
    const firstPart = passwordBytesPadded.slice(0, 7);
    const secondPart = passwordBytesPadded.slice(7);
    const magicKey = character_encoding_1.ASCII.encode('KGS!@#$%'); // page 57 in [MS-NLMP]
    const firstPartEncrypted = encryptWithDES(insertZerosEvery7Bits(firstPart), magicKey);
    const secondPartEncrypted = encryptWithDES(insertZerosEvery7Bits(secondPart), magicKey);
    return (0, typed_array_1.combineInto)(Uint8Array, [firstPartEncrypted, secondPartEncrypted]);
}
function insertZerosEvery7Bits(buffer) {
    const binaryArray = bytes2binaryArray(buffer);
    const newBinaryArray = [];
    for (let i = 0; i < binaryArray.length; i++) {
        newBinaryArray.push(binaryArray[i]);
        if ((i + 1) % 7 === 0) {
            newBinaryArray.push(0);
        }
    }
    return binaryArray2bytes(newBinaryArray);
}
function create_NT_hashed_password_v1(password) {
    const buffer = character_encoding_1.UTF16LE.encode(password);
    const out = (0, md4_1.md4Digest)(buffer);
    return out;
}
function calc_resp(password_hash, server_challenge) {
    // padding with zeros to make the hash 21 bytes long
    const passHashPadded = new Uint8Array(21);
    passHashPadded.set(password_hash.subarray(0, Math.min(21, password_hash.length)));
    const resArray = [
        encryptWithDES(insertZerosEvery7Bits(passHashPadded.slice(0, 7)), server_challenge.slice(0, 8)),
        encryptWithDES(insertZerosEvery7Bits(passHashPadded.slice(7, 14)), server_challenge.slice(0, 8)),
        encryptWithDES(insertZerosEvery7Bits(passHashPadded.slice(14, 21)), server_challenge.slice(0, 8)),
    ];
    return (0, typed_array_1.combineInto)(Uint8Array, resArray);
}
async function hmac_md5(key, data) {
    return new Uint8Array(await (0, hashing_1.computeSignedHash)(key, data, 'MD5'));
}
async function ntlm2sr_calc_resp(responseKeyNT, serverChallenge, clientChallenge) {
    // padding with zeros to make the hash 16 bytes longer
    const lmChallengeResponse = new Uint8Array(clientChallenge.length + 16);
    lmChallengeResponse.set(clientChallenge);
    const buffer = (0, typed_array_1.combineInto)(Uint8Array, [serverChallenge, clientChallenge]);
    const sess = new Uint8Array((0, md5_1.md5Digest)(buffer));
    const ntChallengeResponse = await calc_resp(responseKeyNT, sess.slice(0, 8));
    return {
        lmChallengeResponse: lmChallengeResponse,
        ntChallengeResponse: ntChallengeResponse,
    };
}
async function calc_ntlmv2_resp(pwhash, username, domain, targetInfo, serverChallenge, clientChallenge) {
    const responseKeyNTLM = await NTOWFv2(pwhash, username, domain);
    const lmV2ChallengeResponse = (0, typed_array_1.combineInto)(Uint8Array, [
        await hmac_md5(responseKeyNTLM, (0, typed_array_1.combineInto)(Uint8Array, [serverChallenge, clientChallenge])),
        clientChallenge,
    ]);
    const timestampBuffer = (0, dates_1.getNTTimestamp)(Date.now());
    const zero32Bit = new Uint8Array(4);
    const temp = (0, typed_array_1.combineInto)(Uint8Array, [
        // Version
        new Uint8Array([0x01, 0x01, 0x00, 0x00]),
        zero32Bit,
        timestampBuffer,
        clientChallenge,
        zero32Bit,
        targetInfo,
        zero32Bit,
    ]);
    const proofString = await hmac_md5(responseKeyNTLM, (0, typed_array_1.combineInto)(Uint8Array, [serverChallenge, temp]));
    const ntV2ChallengeResponse = (0, typed_array_1.combineInto)(Uint8Array, [proofString, temp]);
    return {
        lmChallengeResponse: lmV2ChallengeResponse,
        ntChallengeResponse: ntV2ChallengeResponse,
    };
}
async function NTOWFv2(pwhash, user, domain) {
    return await hmac_md5(pwhash, character_encoding_1.UTF16LE.encode(user.toUpperCase() + domain));
}
function encryptWithDES(key, data) {
    // Use des.js since DES is not supported by crypto.subtle
    const des = des_js_1.default.DES.create({ type: 'encrypt', key: key });
    return new Uint8Array(des.update(data));
}
function bytes2binaryArray(buffer) {
    const array = [];
    for (let i = 0; i < buffer.length; i++) {
        const byte = buffer[i];
        for (let bit = 7; bit >= 0; bit--)
            array.push((byte >> bit) & 1);
    }
    return array;
}
function binaryArray2bytes(array) {
    const bytesLength = Math.floor(array.length / 8);
    const out = new Uint8Array(bytesLength);
    for (let i = 0; i < bytesLength; i++) {
        let value = 0;
        for (let b = 0; b < 8; b++)
            value = (value << 1) | (array[i * 8 + b] & 1);
        out[i] = value;
    }
    return out;
}
//# sourceMappingURL=ntlm.js.map