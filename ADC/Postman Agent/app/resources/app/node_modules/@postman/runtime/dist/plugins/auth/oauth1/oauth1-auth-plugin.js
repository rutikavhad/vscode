"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.oauth1Auth = exports.OAuth1AuthConfig = void 0;
const runtime_models_1 = require("@postman/runtime.models");
const z = __importStar(require("zod/v4-mini"));
const http_body_1 = require("../../../items/http/http-body");
const arrays_1 = require("../../../lib/arrays");
const hashing_1 = require("../../../lib/crypto/hashing");
const randomness_1 = require("../../../lib/crypto/randomness");
const dates_1 = require("../../../lib/dates");
const key_values_1 = require("../../../lib/key-values");
const urls_1 = require("../../../lib/urls");
const auth_1 = require("../auth");
const oauth1_1 = require("./oauth1");
exports.OAuth1AuthConfig = z.object({
    consumerKey: z.string(),
    consumerSecret: z.optional(z.string()),
    token: z._default(z.string(), ''),
    tokenSecret: z._default(z.string(), ''),
    privateKey: z.optional(z.string()),
    signatureMethod: z._default(z.string(), ''),
    callback: z.optional(z.string()),
    verifier: z.optional(z.string()),
    // TODO is string correct?
    timestamp: z._default(z.string(), () => String((0, dates_1.getTimestampInSeconds)(new Date()))),
    nonce: z._default(z.string(), () => (0, randomness_1.randomASCII)(11)),
    version: z._default(z.string(), ''),
    realm: z.optional(z.string()),
    includeBodyHash: z.optional(z.boolean()),
    addParamsToHeader: z.optional(z.boolean()),
    addEmptyParamsToSign: z.optional(z.boolean()),
    disableHeaderEncoding: z.optional(z.boolean()),
});
const OAUTH1_QUERY_PARAMS = [
    'oauth_consumer_key',
    'oauth_token',
    'oauth_signature_method',
    'oauth_timestamp',
    'oauth_nonce',
    'oauth_version',
    'oauth_signature',
    'oauth_callback',
    'oauth_verifier',
    'oauth_body_hash',
];
exports.oauth1Auth = {
    name: 'oauth1-auth',
    resolved: {
        async 'http:send-request'(event, run) {
            if (!runtime_models_1.HTTPRequest.is(run.item))
                return;
            const auth = (0, auth_1.resolveAuth)(run, 'oauth1');
            if (!auth)
                return;
            const result = exports.OAuth1AuthConfig.safeParse((0, key_values_1.keyValuesToObject)(auth.oauth1 ?? []));
            if (!result.success)
                return;
            const config = result.data;
            const { realm = '', addParamsToHeader, disableHeaderEncoding } = config;
            // Add signature params to the request.
            //
            // The [OAuth specification][1] says that we should add parameters in the following order of preference:
            //
            // 1. Auth Header
            // 2. Body parameters
            // 3. Query parameters
            //
            // [1]: http://oauth.net/core/1.0/#consumer_req_param
            await run.patch(event, async (payload) => {
                // Assumption: This plugin takes control of the authorization flow,
                // remove user-defined Authorization header, body parameters, and query parameters
                (0, key_values_1.removeKeyValue)(payload.headers, 'authorization', {
                    caseInsensitive: true,
                });
                if (payload.body.type === 'urlencoded') {
                    (0, arrays_1.filter)(payload.body.content, (param) => !OAUTH1_QUERY_PARAMS.includes(param.key));
                }
                (0, arrays_1.filter)(payload.queryParams, (param) => !param.key || !OAUTH1_QUERY_PARAMS.includes(param.key));
                const signatureParams = await signRequest(payload, config, run.runtime.platform);
                if (addParamsToHeader) {
                    const authorization = (0, oauth1_1.generateOAuth1Authorization)(realm, signatureParams, { disableHeaderEncoding });
                    payload.headers.push({
                        key: 'Authorization',
                        value: authorization,
                        system: true,
                    });
                }
                else if (payload.body.type === 'urlencoded') {
                    for (const [key, value] of signatureParams) {
                        payload.body.content.push({
                            key,
                            value,
                        });
                    }
                }
                else {
                    for (const [key, value] of signatureParams) {
                        payload.queryParams.push({ key, value });
                    }
                }
            });
        },
    },
};
async function signRequest(request, config, platform) {
    const parts = config.signatureMethod.split('-');
    const signatureAlgorithm = parts[0]?.toUpperCase();
    const hashResult = parts[1] ? hashing_1.HashAlgorithm.safeParse(parts[1]) : undefined;
    const hashAlgorithm = hashResult?.success ? hashResult.data : undefined;
    if (!config.consumerKey ||
        (signatureAlgorithm !== 'RSA' && !config.consumerSecret) ||
        (signatureAlgorithm === 'RSA' && !config.privateKey)) {
        throw new Error('Invalid OAuth 1 configuration, missing "consumerKey", "consumerSecret", or "privateKey"');
    }
    const signatureParams = [
        ['oauth_consumer_key', config.consumerKey],
        ['oauth_token', config.token],
        ['oauth_signature_method', config.signatureMethod],
        ['oauth_timestamp', config.timestamp],
        ['oauth_nonce', config.nonce],
        ['oauth_version', config.version],
    ];
    // `oauth_body_hash`, `coauth_allback` and `oauth_verifier` parameters are part of extensions of the original OAuth 1 spec.
    // We only include those in signature if they are non-empty, ignoring the `addEmptyParamsToSign` setting.
    // Otherwise it causes problem for servers that don't support the respective OAuth1 extensions.
    //
    // Issue: https://github.com/postmanlabs/postman-app-support/issues/8737
    // Don't include body hash as defined in specification
    // @see: https://tools.ietf.org/id/draft-eaton-oauth-bodyhash-00.html#when_to_include
    if (request.body.type !== 'urlencoded' &&
        config.includeBodyHash &&
        hashAlgorithm) {
        const bodyHash = await (0, http_body_1.computeBodyHash)(request, hashAlgorithm, 'base64', platform);
        signatureParams.push(['oauth_body_hash', bodyHash]);
    }
    if (config.callback) {
        signatureParams.push(['oauth_callback', config.callback]);
    }
    if (config.verifier) {
        signatureParams.push(['oauth_verifier', config.verifier]);
    }
    // Filter empty signature parameters (unless otherwise configured)
    const includedSignatureParams = signatureParams.filter((param) => config.addEmptyParamsToSign || param[1]);
    // Body parameters only need to be included if the are URL-encoded
    // http://oauth.net/core/1.0a/#anchor13
    const bodyParams = request.body.type === 'urlencoded' ?
        request.body.content
            .filter((param) => !param.disabled)
            .map((param) => [param.key, param.value])
        : [];
    const message = {
        action: getBaseURL(request.url),
        method: request.method,
        parameters: [...includedSignatureParams, ...bodyParams],
    };
    const signature = await (0, oauth1_1.generateOAuth1Signature)(message, {
        consumerSecret: config.consumerSecret ?? '',
        tokenSecret: config.tokenSecret,
        privateKey: config.privateKey ?? '',
    });
    includedSignatureParams.push(['oauth_signature', signature]);
    return includedSignatureParams;
}
function getBaseURL(url) {
    const parts = (0, urls_1.parseURL)(url);
    // Use port-less host (i.e. hostname) for standard http/https ports
    const host = parts.port === '80' || parts.port === '443' ? parts.hostname : parts.host;
    // Remove extraneous / sensitive info from base URL (hash and auth)
    const href = (0, urls_1.toHref)({
        protocol: parts.protocol,
        host,
        pathname: parts.pathname,
        search: parts.search,
    });
    return href;
}
//# sourceMappingURL=oauth1-auth-plugin.js.map