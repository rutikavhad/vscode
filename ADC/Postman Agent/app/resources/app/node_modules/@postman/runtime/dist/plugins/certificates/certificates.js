"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadCertificate = loadCertificate;
const postman_collection_1 = require("postman-collection");
const file_system_1 = require("../../lib/file-system/file-system");
async function loadCertificate(platform, context, url) {
    const withMatches = (context.definitions ?? []).map(({ match, ...remaining }) => ({
        matches: match ? matchToMatches(match) : undefined,
        ...remaining,
    }));
    const list = new postman_collection_1.CertificateList({}, withMatches);
    const withoutProtocol = url.replace(/^([a-z0-9+.-]+):\/\//i, '');
    let match = list.resolveOne(`https://${withoutProtocol}`);
    if (match?.disabled) {
        match = undefined;
    }
    if (!match && !context.ca) {
        return { certificate: null, ca: null };
    }
    if (!platform.fs) {
        throw new Error('Unable to load certificate, filesystem not provided');
    }
    const [cert, key, pfx, ca] = await Promise.all([
        match?.cert?.src ? (0, file_system_1.fs)(platform.fs).readFile(match.cert.src) : undefined,
        match?.key?.src ? (0, file_system_1.fs)(platform.fs).readFile(match.key.src) : undefined,
        match?.pfx?.src ? (0, file_system_1.fs)(platform.fs).readFile(match.pfx.src) : undefined,
        context.ca?.src ? (0, file_system_1.fs)(platform.fs).readFile(context.ca.src) : null,
    ]);
    return {
        certificate: match ?
            {
                cert,
                key,
                pfx,
                passphrase: match?.passphrase,
            }
            : null,
        ca,
    };
}
function matchToMatches(match) {
    if (typeof match === 'object' && !Array.isArray(match)) {
        match = match.pattern;
    }
    if (Array.isArray(match))
        return match;
    return [match];
}
//# sourceMappingURL=certificates.js.map