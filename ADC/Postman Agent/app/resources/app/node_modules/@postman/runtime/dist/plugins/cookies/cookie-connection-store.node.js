"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CookieConnectionStore = void 0;
const postman_request_1 = __importDefault(require("postman-request"));
const promises_1 = require("../../lib/promises");
const streams_1 = require("../../lib/streams");
/*
Issue: CookieJar is in runtime's context (local), but may need the jar on the platform side (remote)
(specifically for postman-request and supporting cookies as part of redirects)

Solution: Add RPC connection between local CookieJar store and remote store.

Local:

```ts
const example = {
  name: 'example',

  execute: {
    'example:send-request'(event, run) {
      const channel = platform.send({ ... });

      const readable = channel.readable.pipeThrough(
        new CookieConnectionTransform(run.context.cookies, channel.writable)
      );

      for await (const event of values(readable)) {
        // ...
      }
    }
  }
}
```

Remote:

```ts
export function send() {
  return new Channel(({ incoming, outgoing }) => {
    const jar = request.jar(
        new CookieConnectionStore({ incoming, outgoing })
    );

    // ...

    incoming.close();
  })
}
```
*/
/**
 * CookieStore that handles incoming/outoing cookie events on behalf of the given channel controller
 *
 * @example
 * ```ts
 * const channel = new Channel(controller => {
 *   const jar = request.jar(new CookieConnectionStore(controller));
 * })
 * ```
 */
class CookieConnectionStore {
    #incoming;
    #pending = {};
    constructor(controller) {
        this.#incoming = controller.incoming;
        controller.incoming.signal.addEventListener('abort', () => {
            this.#close();
        });
        (async () => {
            for await (const event of (0, streams_1.values)(controller.outgoing)) {
                if ('id' in event &&
                    typeof event.id === 'string' &&
                    event.id in this.#pending &&
                    this.#pending[event.id].type === event.type) {
                    const subscription = this.#pending[event.id];
                    delete this.#pending[event.id];
                    subscription.continuation(event);
                }
            }
        })()
            .catch(() => {
            // Ignore errors from outgoing / subscriptions
        })
            .finally(() => {
            this.#close();
        });
    }
    #rpc = async (request, type) => {
        const id = crypto.randomUUID();
        const result = (0, promises_1.promiseWithResolvers)();
        const continuation = (event) => {
            if ('error' in event.payload) {
                result.reject(event.payload.error);
            }
            else {
                result.resolve(('result' in event.payload ?
                    event.payload.result
                    : undefined));
            }
        };
        this.#pending[id] = { type, id, continuation, result };
        this.#incoming.enqueue({ id, ...request });
        return result.promise;
    };
    #close = () => {
        for (const [id, subscription] of Object.entries(this.#pending)) {
            subscription.result.reject(new Error('[ConnectedCookieStore] channel closed while waiting for response'));
            delete this.#pending[id];
        }
    };
    findCookie(domain, path, key, callback) {
        function findMatchingCookie(error, cookies) {
            if (error)
                return callback(error, null);
            const match = cookies.find((cookie) => cookie.key === key) ?? null;
            callback(null, match);
        }
        this.findCookies(domain, path, undefined, findMatchingCookie);
    }
    findCookies(domain, path, allowSpecialUseDomain, callback) {
        (async () => {
            const rawCookies = await this.#rpc({
                type: 'cookies:find-cookies.request',
                payload: { domain, path, allowSpecialUseDomain },
            }, 'cookies:find-cookies.response');
            // Need to hydrate as Cookie, use request.cookie(value) and then assign
            const cookies = rawCookies.map((rawCookie) => {
                const { key, name, value } = rawCookie;
                const cookie = postman_request_1.default.cookie(`${key ?? name}=${value}`);
                Object.assign(cookie, {
                    domain: rawCookie.domain,
                    expires: (rawCookie.expires > 0 &&
                        rawCookie.expires < Infinity) ?
                        new Date(rawCookie.expires)
                        : cookie.expires,
                    extensions: rawCookie.extensions,
                    hostOnly: rawCookie.hostOnly,
                    httpOnly: rawCookie.httpOnly,
                    sameSite: rawCookie.sameSite,
                    maxAge: rawCookie.maxAge ?? cookie.maxAge,
                    path: rawCookie.path,
                    secure: rawCookie.secure ?? cookie.secure,
                    session: rawCookie.session ?? cookie.session,
                });
                return cookie;
            });
            callback(null, cookies);
        })().catch((error) => {
            callback(error, []);
        });
    }
    putCookie(cookie, callback) {
        (async () => {
            await this.#rpc({
                type: 'cookies:put-cookie.request',
                payload: { cookie },
            }, 'cookies:put-cookie.response');
            callback(null, undefined);
        })().catch((error) => {
            callback(error, undefined);
        });
    }
}
exports.CookieConnectionStore = CookieConnectionStore;
//# sourceMappingURL=cookie-connection-store.node.js.map