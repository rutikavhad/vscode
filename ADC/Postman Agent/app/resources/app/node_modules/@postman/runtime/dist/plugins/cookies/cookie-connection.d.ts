import type { Cookie } from 'postman-request';
import type { AnyEvent } from '../../events';
import type { CookieJar } from './cookie-jar';
export declare namespace CookieEvent {
    interface FindCookiesRequest {
        type: 'cookies:find-cookies.request';
        id: string;
        payload: {
            domain: string;
            path: string | null;
            allowSpecialUseDomain: boolean | undefined;
        };
    }
    interface FindCookiesResponse {
        type: 'cookies:find-cookies.response';
        id: string;
        payload: {
            result: Cookie[];
        } | {
            error: unknown;
        };
    }
    interface PutCookieRequest {
        type: 'cookies:put-cookie.request';
        id: string;
        payload: {
            cookie: Cookie;
        };
    }
    interface PutCookieResponse {
        type: 'cookies:put-cookie.response';
        id: string;
        payload: {
            result: undefined;
        } | {
            error: unknown;
        };
    }
}
export type CookieEvent = CookieEvent.FindCookiesRequest | CookieEvent.FindCookiesResponse | CookieEvent.PutCookieRequest | CookieEvent.PutCookieResponse;
/**
 * Transform an event channel's readable stream to handle cookie events,
 * replying on the given writable stream
 *
 * @example
 * ```ts
 * const channel = platform.send({ ... });
 *
 * const readable = channel.readable.pipeThrough(
 * 	new CookieConnectionTransform(run.context.cookies, channel.writable)
 * );
 *
 * // (cookie events are "consumed" and not present in readable)
 * for await (const event of values(readable)) {
 * 	// ...
 * }
 * ```
 */
export declare class CookieConnectionTransform<TOutput extends AnyEvent, TInput extends TOutput | CookieEvent.FindCookiesRequest | CookieEvent.PutCookieRequest, TOutgoing extends TOutput | CookieEvent.FindCookiesResponse | CookieEvent.PutCookieResponse> extends TransformStream<TInput, TOutput> {
    constructor(jar: CookieJar, writable: WritableStream<TOutgoing>);
}
