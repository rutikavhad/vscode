"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.attachDefaultEventListeners = attachDefaultEventListeners;
exports.collectEventHandlers = collectEventHandlers;
exports.defaultExecuteOptions = defaultExecuteOptions;
const postman_collection_1 = require("postman-collection");
const http_1 = require("../../../items/http");
const character_encoding_1 = require("../../../lib/character-encoding");
async function transformResponseToPM(response) {
    const responseBytes = new Uint8Array(await response.arrayBuffer());
    const responseText = new TextDecoder().decode(responseBytes);
    const pmResponse = {
        code: response.status,
        header: response.headers,
        stream: {
            data: character_encoding_1.Base64.decode(responseBytes),
            type: 'Base64',
        },
        body: responseText,
        responseTime: response.responseTime ?? 0,
        downloadedBytes: response.downloadedBytes,
    };
    return new postman_collection_1.Response(pmResponse);
}
function sendRequestProvider(r) {
    return async (request) => {
        let body = { type: 'none' };
        if (request.body?.mode) {
            switch (request.body.mode) {
                case 'raw':
                    body = {
                        content: request.body.raw ?? '',
                        type: 'text',
                    };
                    break;
                case 'formdata':
                    body = {
                        content: (request.body.formdata ?? []).map((formData) => ({
                            ...formData,
                            key: formData.key ?? '',
                            value: formData.value ?? '',
                            type: formData.type ?? 'text',
                        })),
                        type: 'formdata',
                    };
                    break;
                case 'urlencoded':
                    if (!Array.isArray(request.body.urlencoded)) {
                        break;
                    }
                    body = {
                        content: request.body.urlencoded.map((data) => ({
                            key: data.key ?? '',
                            value: data.value ?? '',
                        })),
                        type: 'urlencoded',
                    };
                    break;
                case 'file':
                    if (!request.body.file) {
                        break;
                    }
                    if (typeof request.body.file === 'string') {
                        body = {
                            type: 'file',
                            content: {
                                src: request.body.file ?? '',
                            },
                        };
                        break;
                    }
                    else {
                        body = {
                            content: request.body.file ?? '',
                            type: 'file',
                        };
                    }
                    break;
                default:
                    body = {
                        type: 'none',
                    };
                    break;
            }
        }
        const pmRequest = {
            type: 'http-request',
            payload: {
                url: new postman_collection_1.Url(request.url).toString(),
                method: request.method || 'GET',
                headers: request.header?.map((header) => ({
                    key: header.key ?? '',
                    value: header.value ?? '',
                })),
                body: body,
            },
        };
        const run = r.execute(pmRequest);
        const response = await http_1.Response.from(run);
        if (!response)
            return;
        const pmResponse = await transformResponseToPM(response);
        if (!pmResponse)
            return;
        return pmResponse;
    };
}
function attachDefaultEventListeners(run, execution, signal) {
    execution.addEventListener('scripting:execute', (event) => {
        run.emit({
            type: 'scripting:execute',
            payload: {
                source: event.payload.source,
            },
        });
    }, { signal });
    execution.addEventListener('scripting:complete', async (event) => {
        // TODO: Check what happens auto compact is false
        const globalVarMutations = Object.values(event.payload.result?.globals.mutations?.compacted ?? {}).map(async ([key, value]) => {
            await run.context.variables?.workspace?.setValue?.(key, value);
        });
        const collectionVarMutations = Object.values(event.payload.result?.collectionVariables.mutations?.compacted ?? {}).map(async ([key, value]) => {
            await run.context.variables?.collection?.setValue?.(key, value);
        });
        const environmentVarMutations = Object.values(event.payload.result?.environment.mutations?.compacted ?? {}).map(async ([key, value]) => {
            await run.context.variables?.environment?.setValue?.(key, value);
        });
        const localVarMutations = Object.values(event.payload.result?._variables.mutations?.compacted ?? {}).map(async ([key, value]) => {
            await run.context.variables?.local?.setValue?.(key, value);
        });
        await Promise.all([
            ...globalVarMutations,
            ...collectionVarMutations,
            ...environmentVarMutations,
            ...localVarMutations,
        ]);
        const visualizerData = event.payload.result?.return?.visualizer;
        if (visualizerData) {
            run.emit({
                type: 'scripting:visualization',
                payload: {
                    source: event.payload.source,
                    template: visualizerData.template,
                    data: visualizerData.data,
                    compileOptions: visualizerData.options,
                },
            });
        }
        run.emit({
            type: 'scripting:complete',
            payload: {
                source: event.payload.source,
                result: event.payload?.result,
            },
        });
    }, { signal });
    execution.addEventListener('scripting:error', (event) => {
        run.emit({
            type: 'scripting:error',
            payload: {
                source: event.payload.source,
                error: event.payload.error,
            },
        });
    }, { signal });
    execution.addEventListener('scripting:console', (event) => {
        const { source, ...details } = event.payload;
        run.emit({
            type: 'scripting:console',
            payload: {
                source,
                ...details,
            },
        });
    }, { signal });
    execution.addEventListener('scripting:assertion', (event) => {
        run.emit({
            type: 'scripting:assertion',
            payload: {
                source: event.payload.source,
                assertions: event.payload.assertions,
            },
        });
    }, { signal });
}
function getVariableProvider(run) {
    return async () => {
        const [globals = [], collectionVariables = [], environmentVariables = [], localVariables = [],] = await Promise.all([
            run.context.variables?.workspace?.values(),
            run.context.variables?.collection?.values(),
            run.context.variables?.environment?.values(),
            run.context.variables?.local?.values(),
        ]);
        return {
            _variables: {
                values: localVariables
                    .filter(({ disabled }) => !disabled)
                    .map(({ key, value }) => ({ key, value })),
            },
            collectionVariables: {
                values: collectionVariables
                    .filter(({ disabled }) => !disabled)
                    .map(({ key, value }) => ({ key, value })),
            },
            environment: {
                values: environmentVariables
                    .filter(({ disabled }) => !disabled)
                    .map(({ key, value }) => ({ key, value })),
            },
            globals: {
                values: globals
                    .filter(({ disabled }) => !disabled)
                    .map(({ key, value }) => ({ key, value })),
            },
        };
    };
}
function collectEventHandlers(run, listen) {
    const itemHandler = run.item?.extensions?.events?.find((event) => event.listen === listen.item);
    const itemHandlerWithOwner = itemHandler ? { ...itemHandler, owner: run.item?.id } : undefined;
    const { collection, folders = [] } = run.context;
    const ancestors = [collection, ...folders].filter(Boolean);
    const ancestorHandlersWithOwner = ancestors.map((ancestor) => {
        const handler = ancestor?.extensions?.events?.find((event) => event.listen === listen.ancestor);
        return handler ? { ...handler, owner: ancestor.id } : undefined;
    });
    const handlers = [...ancestorHandlersWithOwner, itemHandlerWithOwner].filter((handler) => !!handler?.script && handler.script.exec.trim().length > 0);
    return handlers;
}
function defaultExecuteOptions(run) {
    return {
        variableProvider: getVariableProvider(run),
        sendRequestProvider: sendRequestProvider(run),
        vault: run.context.vault,
        packageProvider: ({ packages, }) => (run.context.scripting?.packageResolver ?? run.context.packageResolver)?.({ packages }) ?? Promise.resolve({}),
    };
}
//# sourceMappingURL=base.js.map