"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GraphQLScripts = void 0;
const runtime_models_1 = require("@postman/runtime.models");
const sandbox_1 = require("../sandbox");
const base_1 = require("./base");
class GraphQLScripts {
    #request;
    #responseStart;
    #responseEnd;
    name = 'graphql-scripts';
    script = {
        'graphql:send-request': async (event, run) => {
            if (run.context.scripting?.disabled)
                return;
            (0, runtime_models_1.assertResourceType)(runtime_models_1.GraphQLRequest, run.item);
            this.#request = event;
            run.subscribe({
                'http:received-response-start': (event) => {
                    this.#responseStart = event;
                },
                'http:received-response-end': (event) => {
                    this.#responseEnd = event;
                },
            });
            const eventHandlers = (0, base_1.collectEventHandlers)(run, {
                item: 'beforeQuery',
                ancestor: 'graphql:beforeQuery',
            });
            if (!eventHandlers.length)
                return;
            const controller = new AbortController();
            const unsubscribe = run.subscribe({
                'run:cancel'() {
                    controller.abort();
                },
            });
            const sandboxExecutor = (0, sandbox_1.getSandboxFleetExecutorForRun)(run);
            for (const handler of eventHandlers) {
                const execution = await sandboxExecutor.execute({
                    templateName: run.item.type,
                    event: handler,
                    signal: controller.signal,
                    itemContext: {
                        request: {
                            url: event.payload.url,
                            headers: event.payload.headers,
                            auth: run.item.extensions?.auth,
                            query: event.payload.query,
                            variables: run.item.payload.variables,
                        },
                    },
                    disabledAPIs: ['visualizer'],
                    ...(0, base_1.defaultExecuteOptions)(run),
                });
                const errors = [];
                execution.addEventListener('scripting:error', (event) => {
                    errors.push(event.payload.error);
                });
                execution.addEventListener('scripting:complete', (_event) => {
                    // TODO patch context
                });
                (0, base_1.attachDefaultEventListeners)(run, execution, controller.signal);
                try {
                    await execution.completed;
                }
                catch (cause) {
                    run.error({
                        type: 'graphql:error',
                        payload: {
                            error: new Error("Couldn't evaluate the Before query script", {
                                cause,
                            }),
                        },
                    });
                }
                finally {
                    execution.offAll();
                }
                // Explicitly stop execution on before query failure
                if (errors.length) {
                    run.error({
                        type: 'graphql:error',
                        payload: {
                            error: new AggregateError(errors, "Couldn't evaluate the Before query script"),
                        },
                    });
                }
            }
            unsubscribe();
        },
        'graphql:received-response': async (event, run) => {
            if (run.context.scripting?.disabled)
                return;
            (0, runtime_models_1.assertResourceType)(runtime_models_1.GraphQLRequest, run.item);
            const eventHandlers = (0, base_1.collectEventHandlers)(run, {
                item: 'afterResponse',
                ancestor: 'graphql:afterResponse',
            });
            if (!eventHandlers.length)
                return;
            const controller = new AbortController();
            run.subscribe({
                'run:cancel'() {
                    controller.abort();
                },
            });
            const request = this.#request;
            const httpResponseStart = this.#responseStart;
            const httpResponseEnd = this.#responseEnd;
            const sandboxExecutor = (0, sandbox_1.getSandboxFleetExecutorForRun)(run);
            for (const handler of eventHandlers) {
                const execution = await sandboxExecutor.execute({
                    templateName: run.item.type,
                    event: handler,
                    signal: controller.signal,
                    itemContext: {
                        request: {
                            url: request?.payload.url,
                            headers: request?.payload.headers,
                            auth: run.item.extensions?.auth,
                            query: request?.payload.query,
                            variables: run.item.payload.variables,
                        },
                        response: {
                            data: event.payload.data,
                            errors: event.payload.errors,
                            responseTime: httpResponseEnd?.payload.timings.total,
                            responseSize: httpResponseEnd ?
                                httpResponseEnd.payload.sizes.body +
                                    httpResponseEnd.payload.sizes.headers
                                : undefined,
                            transport: httpResponseStart ?
                                {
                                    http: {
                                        statusCode: httpResponseStart.payload.statusCode,
                                        headers: httpResponseStart.payload.headers,
                                    },
                                }
                                : undefined,
                        },
                    },
                    disabledAPIs: ['visualizer'],
                    ...(0, base_1.defaultExecuteOptions)(run),
                });
                execution.addEventListener('scripting:complete', (_event) => {
                    // TODO patch context
                });
                (0, base_1.attachDefaultEventListeners)(run, execution, controller.signal);
                run.waitUntil(async () => {
                    try {
                        await execution.completed;
                    }
                    catch (error) {
                        run.emit({
                            type: 'scripting:error',
                            payload: {
                                error,
                                source: {
                                    executionId: execution.id,
                                    eventName: handler.listen,
                                    owner: handler.owner,
                                },
                            },
                        });
                    }
                    execution.offAll();
                });
            }
        },
    };
}
exports.GraphQLScripts = GraphQLScripts;
const template = `const Ajv = require('ajv');
const _ = require('lodash');
const {
  Property,
  RequestAuth,
  Url,
  HeaderList,
} = require('postman-collection');

function prepareHeaders(headers) {
  if (!_.isArray(headers)) {
    return [];
  }

  return new HeaderList(null, headers);
}

class Request extends Property {
  constructor(options = {}) {
    super(options);

    this.url = new Url(options.url);
    this.headers = prepareHeaders(options.headers);
    this.auth = new RequestAuth(options.auth);
    this.query = options.query;
    this.variables = options.variables;
  }

  static isRequest(obj) {
    return obj instanceof Request;
  }
}

class Response extends Property {
  constructor(options = {}) {
    super(options);

    this.data = options.data;
    this.errors = options.errors;
    this.responseTime = options.responseTime;
    this.responseSize = options.responseSize;

    const { http: httpTransport } = options.transport || {};

    this.transport = options.transport
      ? {
          http: httpTransport
            ? {
                statusCode: httpTransport.statusCode,
                headers: prepareHeaders(httpTransport.headers),
              }
            : undefined,
        }
      : undefined;
  }

  static isResponse(obj) {
    return obj instanceof Response;
  }
}

function initializeExecution(target, context) {
  switch (target) {
    case 'beforeQuery':
      return {
        request: new Request(context.request),
      };

    case 'afterResponse':
      return {
        request: new Request(context.request),
        response: new Response(context.response),
      };
  }
}

function chaiPlugin(chai) {
  const Assertion = chai.Assertion;

  Assertion.addProperty('postmanRequest', function () {
    this.assert(
      Request.isRequest(this._obj),
      'expecting a postman request object but got #{this}',
      'not expecting a postman request object'
    );
  });

  Assertion.addProperty('postmanResponse', function () {
    this.assert(
      Response.isResponse(this._obj),
      'expecting a postman response object but got #{this}',
      'not expecting a postman response object'
    );
  });

  Assertion.addProperty('postmanRequestOrResponse', function () {
    this.assert(
      Response.isResponse(this._obj) || Request.isRequest(this._obj),
      'expecting a postman request or response object but got #{this}',
      'not expecting a postman request or response object'
    );
  });

  Assertion.addProperty('ok', function () {
    // If asserted object is not response, use underlying \`ok\`
    if (!Response.isResponse(this._obj)) {
      this.assert(
        chai.util.flag(this, 'object'),
        'expected #{this} to be truthy',
        'expected #{this} to be falsy'
      );

      return;
    }

    const errorsCount = _.size(this._obj.errors);

    this.assert(
      errorsCount === 0,
      'expected response to have no errors but got #{act}',
      'expected response to not have errors #{act}',
      null,
      errorsCount
    );
  });

  Assertion.addMethod('statusCode', function (statusCode) {
    new Assertion(this._obj).to.be.postmanResponse;

    const actualHTTPStatusCode = this._obj.transport?.http?.statusCode;

    this.assert(
      actualHTTPStatusCode === statusCode,
      'expected response to have status code #{exp} but got #{act}',
      'expected response to not have status code #{act}',
      statusCode,
      actualHTTPStatusCode
    );
  });

  Assertion.addMethod('header', function (hKey, hValue) {
    new Assertion(this._obj).to.be.postmanRequestOrResponse;

    const ror = Request.isRequest(this._obj) ? 'request' : 'response';
    const headers =
      ror === 'response'
        ? this._obj.transport?.http?.headers
        : this._obj.headers;

    this.assert(
      HeaderList.isHeaderList(headers),
      'expecting a postman header list but got #{this}',
      'not expecting a postman header list'
    );

    this.assert(
      headers.has(hKey),
      \`expected \${ror} to have header with key '\${hKey}'\`,
      \`expected \${ror} to not have header with key '\${hKey}'\`,
      true,
      headers.has(hKey)
    );

    // In case no check is done on value
    if (arguments.length < 2) {
      return;
    }

    this.assert(
      headers.one(hKey).value === hValue,
      \`expected '\${hKey}' \${ror} header to be #{exp} but got #{act}\`,
      \`expected '\${hKey}' \${ror} header to not be #{act}\`,
      hValue,
      headers.one(hKey).value
    );
  });

  Assertion.addChainableMethod(
    'responseTime',
    function (value) {
      const actualTime = chai.util.flag(this, 'number');

      new Assertion(actualTime).to.be.a('number');

      arguments.length &&
        this.assert(
          actualTime === value,
          'expected response time to be #{exp} but got #{act}',
          'expected response time to not be #{act}',
          value,
          actualTime
        );
    },
    function () {
      new Assertion(this._obj).to.be.postmanResponse;
      new Assertion(this._obj).to.have.property('responseTime').a('number');

      chai.util.flag(this, 'number', this._obj.responseTime);
      this._obj = this._obj.responseTime;
    }
  );

  Assertion.addMethod('jsonSchema', function (schema, options) {
    new Assertion(schema).to.be.an('object');
    new Assertion(this._obj).to.be.postmanResponse;

    const ajvOptions = {
      allErrors: true,
      logger: false,
      ...options,
    };

    const ajv = new Ajv(ajvOptions);
    const valid = ajv.validate(schema, this._obj.data);

    this.assert(
      valid && !ajv.errors,
      \`expected data to satisfy the schema but found following errors: \n\${ajv.errorsText()}\`,
      'expected data to not satisfy the schema',
      true,
      valid
    );
  });
}

module.exports = {
  initializeExecution,
  chaiPlugin,
};
`;
sandbox_1.SandboxFleetExecutor.registerItemType('graphql-request', template);
//# sourceMappingURL=graphql-scripts.js.map