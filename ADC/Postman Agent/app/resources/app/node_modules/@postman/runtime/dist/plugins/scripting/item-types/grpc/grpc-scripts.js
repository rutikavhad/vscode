"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.grpcScripts = void 0;
const runtime_models_1 = require("@postman/runtime.models");
const sandbox_1 = require("../../sandbox");
const base_1 = require("../base");
const execution_context_1 = __importDefault(require("./execution-context"));
const sandbox_template_1 = __importDefault(require("./sandbox-template"));
const GRPC_CONTEXTS = new WeakMap();
sandbox_1.SandboxFleetExecutor.registerItemType('grpc-request', sandbox_template_1.default);
exports.grpcScripts = {
    name: 'grpc-scripts',
    script: {
        async 'grpc:invoke'(event, run) {
            if (run.context.scripting?.disabled)
                return;
            (0, runtime_models_1.assertResourceType)(runtime_models_1.GRPCRequest, run.item);
            const context = (0, execution_context_1.default)(GRPC_CONTEXTS.get(run), run.item, event);
            GRPC_CONTEXTS.set(run, context);
            const eventHandlers = (0, base_1.collectEventHandlers)(run, {
                item: 'beforeInvoke',
                ancestor: 'grpc:beforeInvoke',
            });
            if (!eventHandlers.length)
                return;
            const controller = new AbortController();
            const unsubscribe = run.subscribe({
                'run:cancel'() {
                    controller.abort();
                },
            });
            const sandboxExecutor = (0, sandbox_1.getSandboxFleetExecutorForRun)(run);
            for (const handler of eventHandlers) {
                const execution = await sandboxExecutor.execute({
                    templateName: run.item.type,
                    event: handler,
                    signal: controller.signal,
                    itemContext: context,
                    disabledAPIs: ['visualizer'],
                    ...(0, base_1.defaultExecuteOptions)(run),
                });
                (0, base_1.attachDefaultEventListeners)(run, execution, controller.signal);
                const bailOut = async () => {
                    // For beforeInvoke errors, cancel the entire run as there might be data
                    // that has to be set but isn't and it's safer to bail out entirely.
                    run.cancel();
                };
                execution.addEventListener('scripting:error', bailOut, {
                    signal: controller.signal,
                });
                try {
                    await execution.completed;
                }
                catch (error) {
                    run.emit({
                        type: 'scripting:error',
                        payload: {
                            error,
                            source: {
                                executionId: execution.id,
                                eventName: handler.listen,
                                owner: handler.owner,
                            },
                        },
                    });
                    await bailOut();
                }
                execution.offAll();
            }
            unsubscribe();
        },
        async 'grpc:sent-request-header'(event, run) {
            if (run.context.scripting?.disabled)
                return;
            (0, runtime_models_1.assertResourceType)(runtime_models_1.GRPCRequest, run.item);
            const prevContext = GRPC_CONTEXTS.get(run);
            const newContext = (0, execution_context_1.default)(prevContext, run.item, event);
            GRPC_CONTEXTS.set(run, newContext);
        },
        async 'grpc:sent-request-data'(event, run) {
            if (run.context.scripting?.disabled)
                return;
            (0, runtime_models_1.assertResourceType)(runtime_models_1.GRPCRequest, run.item);
            const prevContext = GRPC_CONTEXTS.get(run);
            const newContext = (0, execution_context_1.default)(prevContext, run.item, event);
            GRPC_CONTEXTS.set(run, newContext);
        },
        async 'grpc:received-response-header'(event, run) {
            if (run.context.scripting?.disabled)
                return;
            (0, runtime_models_1.assertResourceType)(runtime_models_1.GRPCRequest, run.item);
            const prevContext = GRPC_CONTEXTS.get(run);
            const newContext = (0, execution_context_1.default)(prevContext, run.item, event);
            GRPC_CONTEXTS.set(run, newContext);
        },
        async 'grpc:received-response-data'(event, run) {
            if (run.context.scripting?.disabled)
                return;
            (0, runtime_models_1.assertResourceType)(runtime_models_1.GRPCRequest, run.item);
            const prevContext = GRPC_CONTEXTS.get(run);
            const newContext = (0, execution_context_1.default)(prevContext, run.item, event);
            GRPC_CONTEXTS.set(run, newContext);
            const eventHandlers = (0, base_1.collectEventHandlers)(run, {
                item: 'onIncomingMessage',
                ancestor: 'grpc:onIncomingMessage',
            });
            if (!eventHandlers.length)
                return;
            const controller = new AbortController();
            run.subscribe({
                'run:cancel'() {
                    controller.abort();
                },
            });
            const sandboxExecutor = await (0, sandbox_1.getSandboxFleetExecutorForRun)(run);
            for (const handler of eventHandlers) {
                const execution = await sandboxExecutor.execute({
                    templateName: run.item.type,
                    event: handler,
                    signal: controller.signal,
                    itemContext: newContext,
                    disabledAPIs: ['visualizer'],
                    ...(0, base_1.defaultExecuteOptions)(run),
                });
                (0, base_1.attachDefaultEventListeners)(run, execution, controller.signal);
                run.waitUntil(async () => {
                    try {
                        await execution.completed;
                    }
                    catch (error) {
                        run.emit({
                            type: 'scripting:error',
                            payload: {
                                error,
                                source: {
                                    executionId: execution.id,
                                    eventName: handler.listen,
                                    owner: handler.owner,
                                },
                            },
                        });
                    }
                    execution.offAll();
                });
            }
        },
        async 'grpc:status'(event, run) {
            if (run.context.scripting?.disabled)
                return;
            (0, runtime_models_1.assertResourceType)(runtime_models_1.GRPCRequest, run.item);
            const prevContext = GRPC_CONTEXTS.get(run);
            const newContext = (0, execution_context_1.default)(prevContext, run.item, event);
            GRPC_CONTEXTS.set(run, newContext);
            const eventHandlers = (0, base_1.collectEventHandlers)(run, {
                item: 'afterResponse',
                ancestor: 'grpc:afterResponse',
            });
            if (!eventHandlers.length)
                return;
            const controller = new AbortController();
            run.subscribe({
                'run:cancel'() {
                    controller.abort();
                },
            });
            const sandboxExecutor = (0, sandbox_1.getSandboxFleetExecutorForRun)(run);
            for (const handler of eventHandlers) {
                const execution = await sandboxExecutor.execute({
                    templateName: run.item.type,
                    event: handler,
                    signal: controller.signal,
                    itemContext: newContext,
                    ...(0, base_1.defaultExecuteOptions)(run),
                });
                (0, base_1.attachDefaultEventListeners)(run, execution, controller.signal);
                run.waitUntil(async () => {
                    try {
                        await execution.completed;
                    }
                    catch (error) {
                        run.emit({
                            type: 'scripting:error',
                            payload: {
                                error,
                                source: {
                                    executionId: execution.id,
                                    eventName: handler.listen,
                                    owner: handler.owner,
                                },
                            },
                        });
                    }
                    execution.offAll();
                });
            }
        },
    },
};
//# sourceMappingURL=grpc-scripts.js.map