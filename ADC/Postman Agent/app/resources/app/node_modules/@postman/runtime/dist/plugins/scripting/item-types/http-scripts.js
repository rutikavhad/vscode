"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.httpScripts = void 0;
const runtime_models_1 = require("@postman/runtime.models");
const postman_collection_1 = require("postman-collection");
const character_encoding_1 = require("../../../lib/character-encoding");
const match_event_1 = require("../../../lib/match-event");
const typed_array_1 = require("../../../lib/typed-array");
const sandbox_1 = require("../sandbox");
const transformer_1 = require("../utils/transformer");
const base_1 = require("./base");
const RESPONSES = new WeakMap();
const BUFFERS = new WeakMap();
sandbox_1.SandboxFleetExecutor.registerItemType('http-request', '');
exports.httpScripts = {
    name: 'http-scripts',
    script: {
        async 'http:send-request'(event, run) {
            if (run.context.scripting?.disabled)
                return;
            (0, runtime_models_1.assertResourceType)(runtime_models_1.HTTPRequest, run.item);
            const eventHandlers = (0, base_1.collectEventHandlers)(run, {
                item: 'beforeRequest',
                ancestor: 'http:beforeRequest',
            });
            if (!eventHandlers.length)
                return;
            const controller = new AbortController();
            const unsubscribe = run.subscribe({
                'run:cancel'() {
                    controller.abort();
                },
            });
            const sandboxExecutor = (0, sandbox_1.getSandboxFleetExecutorForRun)(run);
            let skipped = false;
            for (const eventHandler of eventHandlers) {
                if (controller.signal.aborted)
                    break;
                // Get a new item every time to avoid mutation issues
                const request = (0, transformer_1.transformToPostmanRequest)(run.item);
                const execution = await sandboxExecutor.execute({
                    event: eventHandler,
                    signal: controller.signal,
                    itemContext: {
                        request,
                    },
                    templateName: run.item.type,
                    ...(0, base_1.defaultExecuteOptions)(run),
                });
                execution.addEventListener('scripting:complete', (completeEvent) => {
                    const request = completeEvent.payload.result?.request;
                    if (!request) {
                        return;
                    }
                    const pmRequest = postman_collection_1.Request.isRequest(request) ?
                        request
                        : new postman_collection_1.Request(request);
                    run.patch(event, (payload) => {
                        payload.headers = pmRequest.headers.toJSON();
                        payload.url = pmRequest.url.toString();
                        payload.method = pmRequest.method;
                        if (pmRequest.body) {
                            payload.body = (0, transformer_1.transformBodyFromPMRequest)(request.body);
                        }
                        // TODO: Mutate auth, extensions not available in payload yet
                    });
                });
                (0, base_1.attachDefaultEventListeners)(run, execution, controller.signal);
                execution.addEventListener('extension:events:skip-request', () => {
                    skipped = true;
                    controller.abort();
                }, { signal: controller.signal });
                try {
                    await execution.completed;
                }
                catch (error) {
                    run.emit({
                        type: 'scripting:error',
                        payload: {
                            error,
                            source: {
                                executionId: execution.id,
                                eventName: eventHandler.listen,
                                owner: eventHandler.owner,
                            },
                        },
                    });
                }
                execution.offAll();
            }
            unsubscribe();
            if (skipped) {
                run.cancel();
            }
        },
        'http:received-response-start'(event, run) {
            if (run.context.scripting?.disabled)
                return;
            // Skip always persisting a response
            const scripts = (0, base_1.collectEventHandlers)(run, {
                item: 'afterResponse',
                ancestor: 'http:afterResponse',
            });
            if (!scripts.length)
                return;
            if (!RESPONSES.has(run)) {
                RESPONSES.set(run, {});
            }
            const response = RESPONSES.get(run);
            response.code = event.payload.statusCode;
            response.header = event.payload.headers;
        },
        'http:received-response-data'(event, run) {
            if (run.context.scripting?.disabled)
                return;
            // Skip always persisting a response
            const scripts = (0, base_1.collectEventHandlers)(run, {
                item: 'afterResponse',
                ancestor: 'http:afterResponse',
            });
            if (!scripts.length)
                return;
            if (!BUFFERS.has(run)) {
                BUFFERS.set(run, []);
            }
            BUFFERS.get(run).push(event.payload.data);
        },
        async 'http:received-response-end'(event, run) {
            if (run.context.scripting?.disabled)
                return;
            (0, runtime_models_1.assertResourceType)(runtime_models_1.HTTPRequest, run.item);
            const data = (0, typed_array_1.combineInto)(Uint8Array, BUFFERS.get(run) ?? []);
            const body = new TextDecoder().decode(data);
            const stream = character_encoding_1.Base64.decode(data);
            const controller = new AbortController();
            const unsubscribe = run.subscribe((0, match_event_1.matchEvent)({
                'run:cancel'() {
                    controller.abort();
                },
            }));
            const scripts = (0, base_1.collectEventHandlers)(run, {
                item: 'afterResponse',
                ancestor: 'http:afterResponse',
            });
            const sandboxExecutor = (0, sandbox_1.getSandboxFleetExecutorForRun)(run);
            let skipped = false;
            for (const script of scripts) {
                if (controller.signal.aborted || skipped)
                    break;
                // Get a new item every time to avoid mutation issues
                const request = (0, transformer_1.transformToPostmanRequest)(run.item);
                const response = RESPONSES.get(run) ?? {};
                const execution = await sandboxExecutor.execute({
                    event: script,
                    templateName: run.item.type,
                    signal: controller.signal,
                    itemContext: {
                        request,
                        // @ts-expect-error - `response` is ill-typed
                        response: new postman_collection_1.Response({
                            ...response,
                            body,
                            stream: {
                                data: stream,
                                type: 'Base64',
                            },
                            responseTime: event.payload.timings.total,
                            downloadedBytes: event.payload.sizes.resourceBytes,
                        }),
                    },
                    ...(0, base_1.defaultExecuteOptions)(run),
                });
                (0, base_1.attachDefaultEventListeners)(run, execution, controller.signal);
                try {
                    await execution.completed;
                }
                catch (error) {
                    run.emit({
                        type: 'scripting:error',
                        payload: {
                            error,
                            source: {
                                executionId: execution.id,
                                eventName: script.listen,
                                owner: script.owner,
                            },
                        },
                    });
                }
                execution.offAll();
            }
            unsubscribe();
        },
    },
};
//# sourceMappingURL=http-scripts.js.map