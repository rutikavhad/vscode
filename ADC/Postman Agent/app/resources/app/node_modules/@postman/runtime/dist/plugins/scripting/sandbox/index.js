"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SandboxFleetExecutor = void 0;
exports.getSandboxFleetExecutorForRun = getSandboxFleetExecutorForRun;
const postman_sandbox_1 = __importDefault(require("postman-sandbox"));
const errors_1 = require("../../../lib/errors");
const promises_1 = require("../../../lib/promises");
const event_emitter_1 = require("../utils/event-emitter");
const async_task_queue_1 = __importDefault(require("./async-task-queue"));
const auto_increment_id_1 = __importDefault(require("./auto-increment-id"));
class Execution extends event_emitter_1.EventEmitter {
    id = crypto.randomUUID();
    completionPromise;
    signal;
    variableProvider;
    sendRequestProvider;
    disabledAPIs;
    event;
    cleanups = [];
    itemContext;
    vault;
    packageProvider;
    constructor(opts) {
        super();
        this.completionPromise = (0, promises_1.promiseWithResolvers)();
        this.signal = opts?.signal;
        this.event = opts.event;
        this.itemContext = opts.itemContext;
        this.variableProvider = opts.variableProvider;
        this.sendRequestProvider = opts.sendRequestProvider;
        this.vault = opts.vault;
        this.packageProvider = opts.packageProvider;
        this.disabledAPIs = opts.disabledAPIs ?? [];
        this.signal?.addEventListener('abort', this.dispose.bind(this));
    }
    get completed() {
        return this.completionPromise.promise;
    }
    dispose() {
        this.completionPromise.resolve();
        this.cleanups.forEach((cleanup) => cleanup());
    }
    async getVariablesSnapshot() {
        if (!this.variableProvider) {
            return {
                collectionVariables: { values: [] },
                _variables: { values: [] },
                globals: { values: [] },
                environment: { values: [] },
            };
        }
        const variables = await this.variableProvider();
        return {
            collectionVariables: variables.collectionVariables ?? { values: [] },
            _variables: variables._variables ?? { values: [] },
            globals: variables.globals ?? { values: [] },
            environment: variables.environment ?? { values: [] },
        };
    }
    async execute(sandboxContext, eventId) {
        if (this.signal?.aborted) {
            return;
        }
        const variables = await this.getVariablesSnapshot();
        const executionContext = {
            ...this.itemContext,
            ...variables,
        };
        this.attachEventListeners(sandboxContext, eventId);
        this.emit('scripting:execute', {
            payload: {
                source: {
                    executionId: this.id,
                    eventId,
                    eventName: this.event.listen,
                    owner: this.event.owner,
                },
            },
        });
        let result;
        try {
            const resolvedPackages = await this.retrievePackages(this.event.script?.packages);
            result = await (0, promises_1.promisify)(sandboxContext.execute.bind(sandboxContext))(this.event, {
                id: eventId,
                target: this.event.listen,
                context: executionContext,
                disabledAPIs: this.disabledAPIs,
                resolvedPackages,
                legacy: {
                    _itemId: this.itemContext?.request?.id,
                    _itemName: this.itemContext?.request?.name,
                    // TODO: populate these values
                    _itemPath: undefined,
                    _eventItemName: undefined,
                },
            });
        }
        catch (error) {
            this.emit('scripting:error', {
                payload: {
                    error: error instanceof Error ? error : new Error(String(error)),
                    source: {
                        executionId: this.id,
                        eventId,
                        eventName: this.event.listen,
                        owner: this.event.owner,
                    },
                },
            });
        }
        this.emit('scripting:complete', {
            payload: {
                source: {
                    executionId: this.id,
                    eventId,
                    eventName: this.event.listen,
                    owner: this.event.owner,
                },
                result,
            },
        });
        this.dispose();
    }
    attachEventListeners(sandboxContext, eventId) {
        const assertionEvent = `execution.assertion.${eventId}`;
        sandboxContext.on(assertionEvent, (_, assertions) => {
            this.emit('scripting:assertion', {
                payload: {
                    source: {
                        executionId: this.id,
                        eventId,
                        eventName: this.event.listen,
                        owner: this.event.owner,
                    },
                    assertions,
                },
            });
        });
        this.cleanups.push(() => sandboxContext.removeAllListeners(assertionEvent));
        const consoleEvent = 'console';
        sandboxContext.on(consoleEvent, (_, level, messages) => {
            this.emit('scripting:console', {
                payload: {
                    source: {
                        executionId: this.id,
                        eventId,
                        eventName: this.event.listen,
                        owner: this.event.owner,
                    },
                    level,
                    messages,
                },
            });
        });
        this.cleanups.push(() => sandboxContext.removeAllListeners(consoleEvent));
        const errorEvent = `execution.error.${eventId}`;
        sandboxContext.once(errorEvent, (_, error) => {
            this.emit('scripting:error', {
                payload: {
                    error: (0, errors_1.toError)(error),
                    source: {
                        executionId: this.id,
                        eventId,
                        eventName: this.event.listen,
                        owner: this.event.owner,
                    },
                },
            });
            this.dispose();
        });
        this.cleanups.push(() => sandboxContext.removeAllListeners(errorEvent));
        const skipRequestEvent = `execution.skipRequest.${eventId}`;
        sandboxContext.on(skipRequestEvent, () => {
            this.emit('extension:events:skip-request', {
                payload: {
                    source: {
                        executionId: this.id,
                        eventId,
                        eventName: this.event.listen,
                        owner: this.event.owner,
                    },
                },
            });
        });
        this.cleanups.push(() => sandboxContext.removeAllListeners(skipRequestEvent));
        const httpRequest = `execution.request.${eventId}`;
        sandboxContext.on(httpRequest, async (_, _id, _eventId, request) => {
            let response, error;
            try {
                response = await this.onHttpRequest(request);
            }
            catch (e) {
                error = e;
            }
            sandboxContext.dispatch(`execution.response.${eventId}`, _eventId, error, response);
        });
        this.cleanups.push(() => sandboxContext.removeAllListeners(httpRequest));
        const vaultEvent = `execution.vault.${eventId}`;
        sandboxContext.on(vaultEvent, async (id, cmd, ...args) => {
            if (!['get', 'set', 'unset'].includes(cmd)) {
                sandboxContext.dispatch(`execution.vault.${eventId}`, id, new Error(`Invalid vault command: ${cmd}`));
            }
            const dispatchError = (e) => {
                sandboxContext.dispatch(`execution.vault.${eventId}`, id, e instanceof Error ? e.message : e);
            };
            if (cmd === 'get') {
                const key = args.at(0);
                try {
                    const value = await this.vault?.values();
                    sandboxContext.dispatch(`execution.vault.${eventId}`, id, null, value?.filter((item) => item.key === key && !item.disabled)?.[0]
                        ?.value);
                }
                catch (error) {
                    dispatchError(error);
                }
            }
            if (cmd === 'set' || cmd === 'unset') {
                const key = args.at(0);
                const value = args.at(1);
                try {
                    let resp;
                    if (cmd === 'set') {
                        resp = await this.vault?.setValue?.(key, value);
                    }
                    else {
                        resp = await this.vault?.setValue?.(key, undefined);
                    }
                    sandboxContext.dispatch(`execution.vault.${eventId}`, id, null, resp);
                }
                catch (error) {
                    dispatchError(error);
                }
            }
        });
        this.cleanups.push(() => sandboxContext.removeAllListeners(vaultEvent));
    }
    onHttpRequest(request) {
        return this.sendRequestProvider(request);
    }
    retrievePackages(packages) {
        if (!packages)
            return Promise.resolve({});
        return this.packageProvider?.({ packages }) ?? Promise.resolve({});
    }
}
/**
 * This class is responsible for creating a sandbox fleet and executing scripts in it.
 */
class SandboxFleetExecutor {
    static disabledAPIs = ['cookies', 'info'];
    sandboxFleet;
    queue = new async_task_queue_1.default();
    idGenerator = new auto_increment_id_1.default();
    static templateMap = new Map();
    static registerItemType(itemType, template) {
        this.templateMap.set(itemType, template ?? '');
    }
    async init() {
        const registry = {};
        for (const [key, value] of SandboxFleetExecutor.templateMap.entries()) {
            registry[key] = value;
        }
        this.sandboxFleet = await (0, promises_1.promisify)(postman_sandbox_1.default.createContextFleet)(registry, { disabledAPIs: SandboxFleetExecutor.disabledAPIs }, { serializeLogs: true });
    }
    async enqueue(execution, templateName) {
        if (!execution.event.script?.exec?.trim()) {
            return;
        }
        const task = async () => {
            const eventId = this.idGenerator.generateID();
            const sandbox = await this.getSandbox(templateName);
            await execution.execute(sandbox, eventId);
        };
        this.queue.push(task, () => { });
        return;
    }
    async getSandbox(templateName) {
        if (!this.sandboxFleet) {
            await this.init();
        }
        return await (0, promises_1.promisify)(this.sandboxFleet.getContext.bind(this.sandboxFleet))(templateName);
    }
    async execute({ signal, variableProvider, event, itemContext, disabledAPIs, sendRequestProvider, vault, packageProvider, templateName, }) {
        const execution = new Execution({
            signal,
            variableProvider,
            event,
            itemContext,
            sendRequestProvider,
            vault,
            packageProvider,
            disabledAPIs: SandboxFleetExecutor.disabledAPIs.concat(disabledAPIs ?? []),
        });
        await this.enqueue(execution, templateName);
        return execution;
    }
    async drainAllExecutions() {
        await this.queue.drain();
    }
    async dispose(force = false) {
        if (force) {
            this.queue.kill();
        }
        else {
            await this.queue.drain();
        }
        this.sandboxFleet?.disposeAll();
    }
}
exports.SandboxFleetExecutor = SandboxFleetExecutor;
const EXECUTOR_MAP = new WeakMap();
function getSandboxFleetExecutorForRun(run) {
    if (EXECUTOR_MAP.has(run)) {
        return EXECUTOR_MAP.get(run);
    }
    const executor = new SandboxFleetExecutor();
    EXECUTOR_MAP.set(run, executor);
    run.using({
        [Symbol.asyncDispose]: async () => {
            EXECUTOR_MAP.delete(run);
            await executor.dispose(true);
        },
    });
    return executor;
}
//# sourceMappingURL=index.js.map