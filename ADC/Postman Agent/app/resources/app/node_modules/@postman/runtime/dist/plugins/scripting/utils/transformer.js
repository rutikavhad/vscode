"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformToPostmanRequest = transformToPostmanRequest;
exports.transformBodyFromPMRequest = transformBodyFromPMRequest;
const postman_collection_1 = require("postman-collection");
/**
 * TODO: This is temporary code to transform HTTP request models for sandbox. Should be replaced once the generic transformers are implemented.
 * ⛔️ CAUTION: This code is not production-ready and may not cover all edge cases. Generated by AI
 * Transforms an HTTP request model from the new format to a Postman Collection SDK Request object.
 *
 * This function handles the conversion of all aspects of an HTTP request:
 * - URL (converted to a Url object from postman-collection)
 * - Query parameters with their description and disabled state
 * - Path variables with their description and disabled state
 * - HTTP method
 * - Headers with descriptions and disabled state
 * - Request body (none, formdata, urlencoded, raw text/json/xml/html/javascript, file)
 * - Authentication parameters
 * - Request settings (protocol version, SSL, redirects, etc.)
 *
 * The transformation preserves all metadata and ensures compatibility with the older
 * Postman Collection SDK format as defined in:
 * https://www.postmanlabs.com/postman-collection/Request.html
 *
 * Note: The URL is converted to a Url object from postman-collection, and both query parameters
 * and path variables are added with their description and disabled state. Events are not passed to the SDK.
 *
 * @param httpRequest - The HTTP request model in the new format to transform
 * @returns A Postman Collection SDK Request object that can be used with the older SDK
 *
 * @example
 * // Transform a simple GET request with query parameters and path variables
 * const sdkRequest = transformToPostmanRequest({
 *   type: 'http-request',
 *   payload: {
 *     url: 'https://api.example.com/users/:userId',
 *     method: 'GET',
 *     headers: [{ key: 'Accept', value: 'application/json' }],
 *     queryParams: [
 *       { key: 'page', value: '1', description: 'Page number', disabled: false },
 *       { key: 'limit', value: '10', description: 'Results per page', disabled: true }
 *     ],
 *     pathVariables: [
 *       { key: 'userId', value: '123', description: 'User ID', disabled: false }
 *     ]
 *   }
 * });
 */
function transformToPostmanRequest(httpRequest) {
    // Import the Request class dynamically to avoid issues with circular dependencies
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    // Create the request object with basic properties
    // The Postman Collection SDK Request constructor accepts an object with properties
    // that match the structure defined in the SDK
    // Create a Url instance directly from the URL string so the SDK parses it internally
    const url = postman_collection_1.Url.parse(httpRequest.payload.url);
    // Add query parameters with their description and disabled state
    if (httpRequest.payload.queryParams &&
        httpRequest.payload.queryParams.length > 0) {
        // Replace existing query params with the provided ones
        url.query = httpRequest.payload.queryParams.map((param) => ({
            key: param.key,
            value: param.value,
            description: param.description || '',
            disabled: param.disabled || false,
        }));
    }
    else {
        // Ensure no stray SDK-internal properties leak into query serialization
        url.query = [];
    }
    // Add path variables with their description and disabled state
    if (httpRequest.payload.pathVariables &&
        httpRequest.payload.pathVariables.length > 0) {
        // Add each path variable with its metadata
        url.variable = httpRequest.payload.pathVariables.map((variable) => ({
            key: variable.key,
            value: variable.value,
        }));
    }
    const requestObj = {
        url,
        method: httpRequest.payload.method,
        header: [],
        // Map documentation content to description if available
        ...(httpRequest.extensions?.documentation?.content && {
            description: httpRequest.extensions.documentation.content,
        }),
        // @ts-expect-error - The SDK expects an object, but we can safely use an empty object here
        body: {},
    };
    // Handle headers
    // Headers are represented as an array of key-value pairs with metadata
    if (httpRequest.payload.headers && httpRequest.payload.headers.length > 0) {
        const headers = httpRequest.payload.headers.map((header) => ({
            key: header.key,
            value: header.value,
            description: header.description,
            disabled: header.disabled,
        }));
        requestObj.header = headers;
    }
    // Handle body based on type
    // The Postman Collection SDK supports different body modes: none, formdata, urlencoded, raw, file
    if (httpRequest.payload.body) {
        const { type } = httpRequest.payload.body;
        switch (type) {
            case 'none':
                // No body, do nothing
                // The SDK will handle this case automatically
                break;
            case 'formdata':
                // Form data can contain both text fields and file attachments
                requestObj.body = {
                    mode: 'formdata',
                    formdata: httpRequest.payload.body.content
                        .map((item) => {
                        // TODO: Flatten the file src type
                        if (item.type === 'text') {
                            // Text form field
                            return {
                                key: item.key,
                                value: item.value,
                                type: 'text',
                                contentType: item.contentType, // Optional MIME type for the value
                                description: item.description,
                                disabled: !!item.disabled,
                            };
                        }
                        else if (item.type === 'file') {
                            if (Array.isArray(item.src)) {
                                return item.src.map((src) => ({
                                    key: item.key,
                                    src,
                                    type: 'file',
                                    contentType: item.contentType,
                                    description: item.description,
                                    disabled: !!item.disabled,
                                }));
                            }
                            // File attachment
                            return {
                                key: item.key,
                                // Handle both single file and multiple files
                                src: item.src,
                                type: 'file',
                                contentType: item.contentType, // Optional MIME type for the file
                                description: item.description,
                                disabled: !!item.disabled,
                            };
                        }
                        return undefined;
                    })
                        .flat()
                        .filter((param) => !!param), // Remove any null entries
                };
                break;
            case 'urlencoded':
                // URL-encoded form data (application/x-www-form-urlencoded)
                requestObj.body = {
                    mode: 'urlencoded',
                    urlencoded: httpRequest.payload.body.content.map((param) => ({
                        key: param.key,
                        value: param.value,
                        description: param.description,
                        disabled: param.disabled,
                    })),
                };
                break;
            case 'text':
            case 'json':
            case 'xml':
            case 'html':
            case 'javascript':
                // Raw body with different content types
                // In the SDK, all these are represented as 'raw' mode with language option
                requestObj.body = {
                    mode: 'raw',
                    raw: httpRequest.payload.body.content,
                };
                break;
            case 'file':
                // Binary file content
                requestObj.body = {
                    mode: 'file',
                    file: {
                        src: httpRequest.payload.body.content.src, // Path or identifier of the file
                    },
                };
                break;
            default:
                // Unknown body type, do nothing
                // This ensures backward compatibility if new body types are added
                break;
        }
    }
    // Handle authentication
    // The Postman Collection SDK supports various auth types like basic, oauth2, apikey, etc.
    if (httpRequest.extensions?.auth) {
        const authData = httpRequest.extensions.auth;
        // Won't support multi-auth in sandbox for now
        if ('type' in authData && authData.type !== 'noauth') {
            // In the SDK, auth is an object with a 'type' property and a property named after the auth type
            // that contains the auth parameters
            // @ts-expect-error - @types/postman-collection is not complete
            requestObj.auth = authData;
        }
    }
    // Create and return the Request object
    // The Request constructor from the Postman Collection SDK takes the request object
    // we've built and creates a full-featured Request instance with all the methods
    // and properties defined in the SDK
    return new postman_collection_1.Request(requestObj);
}
function transformBodyFromPMRequest(body) {
    if (!body || !body.mode) {
        return { type: 'none' };
    }
    switch (body.mode) {
        case 'raw':
            // Raw body content - map to text type in new format
            return {
                type: 'text',
                content: body.raw ?? '',
            };
        case 'formdata':
            // Form data with text fields and file attachments
            if (!body.formdata || !Array.isArray(body.formdata)) {
                return {
                    type: 'formdata',
                    content: [],
                };
            }
            const formdataContent = body.formdata.map((field) => {
                // Handle both FormParamDefinition objects and FormParam instances
                const key = field.key ?? '';
                const value = field.value ?? '';
                const description = 'description' in field ? field.description : undefined;
                const disabled = 'disabled' in field ? field.disabled : false;
                const contentType = 'contentType' in field ? field.contentType : undefined;
                const type = 'type' in field ? field.type : 'text';
                const src = 'src' in field ? field.src : undefined;
                // Ensure description is a string or undefined
                const normalizedDescription = typeof description === 'string' ? description : undefined;
                if (type === 'file' && src) {
                    // File field - ensure src is string or string[]
                    const normalizedSrc = Array.isArray(src) ? src : String(src);
                    return {
                        type: 'file',
                        key,
                        src: normalizedSrc,
                        contentType,
                        description: normalizedDescription,
                        disabled: !!disabled,
                    };
                }
                else {
                    // Text field
                    return {
                        type: 'text',
                        key,
                        value,
                        contentType,
                        description: normalizedDescription,
                        disabled: !!disabled,
                    };
                }
            });
            return {
                type: 'formdata',
                content: formdataContent,
            };
        case 'urlencoded':
            // URL-encoded form data
            if (!body.urlencoded) {
                return {
                    type: 'urlencoded',
                    content: [],
                };
            }
            // Handle both array and PropertyList, and string format
            let urlencodedData = [];
            if (typeof body.urlencoded === 'string') {
                // Parse string format if needed
                try {
                    const params = new URLSearchParams(body.urlencoded);
                    urlencodedData = Array.from(params.entries()).map(([key, value]) => ({
                        key,
                        value,
                    }));
                }
                catch {
                    // If parsing fails, return empty content
                    urlencodedData = [];
                }
            }
            else if (Array.isArray(body.urlencoded)) {
                urlencodedData = body.urlencoded;
            }
            else if (body.urlencoded &&
                typeof body.urlencoded === 'object' &&
                'members' in body.urlencoded) {
                // PropertyList format - safely access members
                const propertyList = body.urlencoded;
                urlencodedData =
                    Array.isArray(propertyList.members) ? propertyList.members : [];
            }
            const urlencodedContent = urlencodedData.map((param) => ({
                key: param.key ?? '',
                value: param.value ?? '',
                description: param.description,
                disabled: !!param.disabled,
            }));
            return {
                type: 'urlencoded',
                content: urlencodedContent,
            };
        case 'file':
            // Binary file content
            const fileSrc = typeof body.file === 'string' ? body.file : body.file?.src;
            return {
                type: 'file',
                content: {
                    src: fileSrc || '',
                },
            };
        default:
            // Unknown mode, default to none
            return { type: 'none' };
    }
}
//# sourceMappingURL=transformer.js.map