"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.variables = void 0;
const grpc_event_1 = require("../../items/grpc/grpc-event");
const mcp_event_1 = require("../../items/mcp/mcp-event/mcp-event");
const urls_1 = require("../../lib/urls");
const variables_1 = require("./variables");
function itemHasURL(item) {
    return (typeof item === 'object' &&
        item !== null &&
        'payload' in item &&
        typeof item.payload === 'object' &&
        item.payload !== null &&
        'url' in item.payload);
}
exports.variables = {
    name: 'variables',
    async resolve(event, run) {
        // For now, all events handle variables the same (other than where the URL is read).
        // The remainder of the function treats them that way, interpolating variables across the event, collection etc.
        //
        // If we start handling variables with more variation,
        // we can use this guard to fork off to a dedicated handler rather than returning early.
        if (!supportsVariables(event.type)) {
            return;
        }
        // Based on event type, read URL (if present)
        let url;
        const runItem = run.context.item;
        // Check context item and the event payload to extract the URL
        if (itemHasURL(runItem)) {
            url = runItem.payload.url;
        }
        else if (itemHasURL(event)) {
            url = event.payload.url;
        }
        const variables = await resolveVariables(run.context, url);
        // Replace variables in item, folders, collection, etc.
        run.patch((context) => {
            (0, variables_1.replaceVariables)(variables, context);
        });
        // Replace variables in event
        run.patch(event, (payload) => {
            (0, variables_1.replaceVariables)(variables, payload);
        });
    },
};
const SUPPORTS_VARIABLES_EVENT_TYPES = new Set([
    'websocket:open',
    'websocket:send-message',
    'http:send-request',
    'graphql:send-request',
    ...grpc_event_1.OUTGOING_GRPC_EVENT_TYPES,
    ...mcp_event_1.MCPEvent.mcpOutgoingEventTypes,
]);
function supportsVariables(eventType) {
    return SUPPORTS_VARIABLES_EVENT_TYPES.has(eventType);
}
//
// #region Resolution
//
async function resolveVariables(context, url) {
    const { variables, vault } = context;
    if (!variables && !vault)
        return [];
    const variableValues = variables ? await (0, variables_1.getVariablesSnapshot)(variables) : [];
    let vaultValues = [];
    if (vault && url) {
        // 1. For vault, get snapshot with initial (un-replaced) URL and resolve URL
        let snapshotURL = (0, urls_1.ensureProtocol)(url);
        vaultValues = await vault.values({ url: snapshotURL });
        const resolvedURL = (0, variables_1.toReplacedVariables)([...variableValues, ...vaultValues], url);
        // 2. If URL has changed, reload vault snapshot and replace all variables in event payload
        if (resolvedURL !== url) {
            snapshotURL = (0, urls_1.ensureProtocol)(resolvedURL);
            vaultValues = await vault.values({ url: snapshotURL });
        }
    }
    else if (vault) {
        // If no URL, get global vault values without URL scoping
        vaultValues = await vault.values({});
    }
    return [...variableValues, ...vaultValues];
}
//# sourceMappingURL=variables-plugin.js.map