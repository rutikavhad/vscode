"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRemoteRuntime = createRemoteRuntime;
const runtime_collection_1 = __importDefault(require("@postman/runtime.collection"));
const runtime_folder_1 = __importDefault(require("@postman/runtime.folder"));
const runtime_grpc_request_1 = __importDefault(require("@postman/runtime.grpc-request"));
const runtime_mqtt_request_1 = __importDefault(require("@postman/runtime.mqtt-request"));
const runtime_socket_io_request_1 = __importDefault(require("@postman/runtime.socket.io-request"));
const runtime_websocket_request_1 = __importDefault(require("@postman/runtime.websocket-request"));
const complete_runtime_1 = __importDefault(require("./complete-runtime"));
const rpc_compatibility_1 = require("./lib/rpc/rpc-compatibility");
const next_1 = require("./next");
function createRemoteRuntime({ client, grpcRequest, ...nextConfig }) {
    const platform = (0, rpc_compatibility_1.proxy)(client);
    const next = new next_1.Runtime({ ...nextConfig, platform });
    const runtime = Object.assign(new complete_runtime_1.default(), {
        next,
        execute(item, context = {}) {
            return next.execute(item, context);
        },
    });
    runtime.registerType(runtime_folder_1.default.use());
    runtime.registerType(runtime_collection_1.default.use());
    runtime.registerExecutableType(runtime_grpc_request_1.default.use().implement({
        async invoke(options) {
            const { remote } = await client.invoke('grpc-request.invoke', options);
            remote.onCleanup((err) => err && remote.events.emit('error', err));
            return remote.toProxy(['end', 'cancel'], ['write']);
        },
        resolveSchema: grpcRequest?.resolveSchema || (() => { }),
    }));
    runtime.registerExecutableType(runtime_mqtt_request_1.default.use().implement({
        async connect(options) {
            const { remote } = await client.invoke('mqtt-request.connect', options);
            remote.onCleanup((err) => err && remote.events.emit('error', err));
            return remote.toProxy(['disconnect', 'cancel', 'publish', 'subscribe', 'unsubscribe'], []);
        },
    }));
    runtime.registerExecutableType(runtime_websocket_request_1.default.use().implement({
        async connect(options) {
            const { remote } = await client.invoke('websocket-request.connect', options);
            remote.onCleanup((err) => err && remote.events.emit('error', err));
            return remote.toProxy(['close', 'send'], []);
        },
    }));
    runtime.registerExecutableType(runtime_socket_io_request_1.default.use().implement({
        async connect(options) {
            const { remote } = await client.invoke('socketio-request.connect', options);
            remote.onCleanup((err) => err && remote.events.emit('error', err));
            return remote.toProxy(['disconnect', 'publish', 'subscribe', 'unsubscribe'], []);
        },
    }));
    return runtime;
}
//# sourceMappingURL=remote-runtime.js.map