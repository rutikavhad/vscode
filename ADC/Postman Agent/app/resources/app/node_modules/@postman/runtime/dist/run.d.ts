import { Collection, Folder } from '@postman/runtime.models';
import { type Draft } from 'mutative';
import { type AnyEvent, type BuiltInEvent, ErrorEvent, type InternalEvent, type RuntimeEvent } from './events.js';
import type { AnyItem, BuiltInItem } from './items.js';
import { type Continuation } from './lib/auto-queue.js';
import { MaybeDisposable } from './lib/disposables.js';
import { EventSubscriber } from './lib/event-stream.js';
import { EventMatcher } from './lib/match-event.js';
import { type MaybePromise } from './lib/promises.js';
import { type Resource } from './lib/resources.js';
import { Unsubscribe } from './lib/unsubscribe';
import { type AnyItemWithOptions, type InferItem, type InferItemOptions } from './plugin.js';
import { CertificateContext } from './plugins/certificates/certificates-plugin.js';
import { CookiesContext } from './plugins/cookies/cookies-plugin.js';
import { ProxyContext } from './plugins/proxy/index.js';
import { Variables, Vault } from './plugins/variables/index.js';
import type { Runtime, RuntimeEnvironment } from './runtime.js';
/**
 * `RunContext` generally maps to `EventContext`, with instances instead of links
 */
export interface RunContext<TAdditionalItem extends AnyItem | AnyItemWithOptions = never, TSpecificItem extends BuiltInItem | InferItem<TAdditionalItem> = BuiltInItem | InferItem<TAdditionalItem>> {
    /**
     * Reserved for options for executing the given item
     */
    options?: InferItemOptions<TAdditionalItem, TSpecificItem>;
    item?: Pick<Resource, 'id'> & TSpecificItem;
    collection?: Collection & {
        id: string;
    };
    /**
     * Chain of folders, from farthest-to-closest
     */
    folders?: Array<Folder & {
        id: string;
    }>;
    workspace?: WorkspaceInfo;
    environment?: EnvironmentInfo;
    execution?: {
        dryRun?: boolean;
    };
    variables?: Variables;
    vault?: Vault;
    proxy?: ProxyContext;
    certificates?: CertificateContext;
    cookies?: CookiesContext;
    http?: {
        requestTimeoutMs?: number;
        followRedirects?: boolean;
    };
    tls?: {
        strict?: boolean;
        keyLog?: {
            src: string;
        };
    };
    scripting?: {
        disabled?: boolean;
        packageResolver?: (options: {
            packages: Record<string, {
                id: string;
            }>;
        }) => Promise<Record<string, {
            data: string;
        }>>;
    };
    /**
     * @deprecated Prefer scripting.packageResolver
     */
    packageResolver?: (options: {
        packages: Record<string, {
            id: string;
        }>;
    }) => Promise<Record<string, {
        data: string;
    }>>;
    [key: PropertyKey]: unknown;
}
interface WorkspaceInfo {
    type: 'workspace';
    id: string;
    payload: Record<string, unknown>;
}
interface EnvironmentInfo {
    type: 'environment';
    id: string;
    payload: Record<string, unknown>;
}
/**
 * Interact with run's executing in Postman Runtime
 *
 * @example
 * ```ts
 * const runtime = new Runtime();
 * const run = runtime.execute({
 *   type: 'grpc-request',
 *   payload: { ... }
 * });
 *
 * // Enqueue events for the run to process
 * run.enqueue({ type: 'grpc:message', payload: { ... } });
 * run.enqueue({ type: 'grpc:message', payload: { ... } });
 * run.enqueue({ type: 'grpc:message', payload: { ... } });
 *
 * // Close run (stop accepting new events and process remaining)
 * run.close();
 *
 * // Cancel run (throwing out queued events)
 * run.cancel();
 *
 * // Stop run with error (throwing out queued events and emitting error)
 * run.error(new Error('Something went wrong'));
 *
 * // Subscribe to run
 * run.subscribe((event) => {
 *  console.log(event);
 * });
 *
 * // Iterate through run
 * for await (const event of run) {
 *   console.log(event);
 * }
 * ```
 *
 * Additionally, there are methods that are helpful for plugins:
 *
 * @example
 * ```ts
 * // Dispose of resources when the run is complete
 * run.using({
 *   [Symbol.dispose]() {
 *     // cleanup...
 *   }
 * });
 *
 * // Keep the run open until at least the given promise or continuation settles
 * run.waitUntil(async () => {
 *   // waiting...
 * });
 * ```
 */
export declare class Run<TAdditionalEvent extends AnyEvent = never, TAdditionalItem extends AnyItem | AnyItemWithOptions = never, TSpecificItem extends BuiltInItem | InferItem<TAdditionalItem> = BuiltInItem | InferItem<TAdditionalItem>> {
    #private;
    get id(): string;
    get runtime(): Runtime<TAdditionalEvent, TAdditionalItem>;
    get environment(): RuntimeEnvironment<TAdditionalEvent, TAdditionalItem>;
    get item(): (Pick<Resource, 'id'> & TSpecificItem) | undefined;
    get context(): RunContext<TAdditionalItem, TSpecificItem>;
    get complete(): Promise<void>;
    constructor(runtime: Runtime<TAdditionalEvent, TAdditionalItem>, item: TSpecificItem | undefined, context?: RunContext<TAdditionalItem, TSpecificItem>, 
    /**
     * Process chain, from root-to-closest
     *
     * @internal
     */
    processes?: Run<TAdditionalEvent, TAdditionalItem>[]);
    /**
     * Add an event to the queue to be processed.
     * Returns a promise that resolves when the event has been processed
     * or rejects with the error that occurred during processing.
     */
    enqueue<TEvent extends InternalEvent | BuiltInEvent | TAdditionalEvent>(event: TEvent): Promise<void>;
    /**
     * Emit the given event immediately (without processing)
     */
    emit(event: InternalEvent | BuiltInEvent | TAdditionalEvent): void;
    /**
     * Subscribe to all events processed or emitted
     */
    subscribe(handler: EventMatcher<RuntimeEvent<InternalEvent | BuiltInEvent | TAdditionalEvent>> | EventSubscriber<RuntimeEvent<InternalEvent | BuiltInEvent | TAdditionalEvent>>, options?: {
        signal?: AbortSignal;
    }): Unsubscribe;
    /**
     * Convert the given event to a RuntimeEvent
     *
     * @internal
     */
    toRuntimeEvent<TEvent extends InternalEvent | BuiltInEvent | TAdditionalEvent>(event: TEvent): RuntimeEvent<TEvent>;
    /**
     * Mutate run context or event payload, synchronously or asynchronously
     *
     * @example
     * ```ts
     * const variables: Plugin = {
     *   name: 'variables',
     *
     *   prepare: {
     *     run: {
     *       execute(_event, run) {
     *         service.subscribe(variables => {
     *           // Patch run context with updated variables
     *           // (emits run:patch event)
     *           run.patch(context => {
     *             context.variables = variables;
     *           })
     *         });
     *       }
     *     }
     *   },
     *
     *   resolve: {
     *     async 'http:request'(event, run) {
     *       // Patch event with updated payload
     *       // - adds to inversePatches of event if not emitted
     *       // - emits run:patch event if event was emitted
     *       await run.patch(event, async payload => {
     *         payload.url = await replaceVariables(run.context.variables, payload.url);
     *       })
     *     }
     *   }
     * };
     * ```
     */
    patch(mutate: (context: Draft<RunContext<TAdditionalItem, TSpecificItem>>) => RunContext<TAdditionalItem, TSpecificItem> | void): void;
    patch(mutate: (context: Draft<RunContext<TAdditionalItem, TSpecificItem>>) => Promise<RunContext<TAdditionalItem, TSpecificItem> | void>): Promise<void>;
    patch<TEvent extends InternalEvent | BuiltInEvent | TAdditionalEvent>(event: RuntimeEvent<TEvent>, mutate: (payload: Draft<TEvent['payload']>) => TEvent['payload'] | void): void;
    patch<TEvent extends InternalEvent | BuiltInEvent | TAdditionalEvent>(event: RuntimeEvent<TEvent>, mutate: (payload: Draft<TEvent['payload']>) => Promise<TEvent['payload'] | void>): Promise<void>;
    /**
     * Process an event through the runtime pipeline (without emitting)
     *
     * @internal
     */
    processEvent<TEvent extends InternalEvent | BuiltInEvent | TAdditionalEvent>(event: RuntimeEvent<TEvent>): Promise<void>;
    stopPropagation<TEvent extends InternalEvent | BuiltInEvent | TAdditionalEvent>(event: RuntimeEvent<TEvent>): void;
    /**
     * Reject event, stopping processing and propagation and rejecting enqueue call
     */
    rejectEvent<TEvent extends InternalEvent | BuiltInEvent | TAdditionalEvent>(event: RuntimeEvent<TEvent>, error: Error): void;
    /**
     * Execute the given item in a child process of the current run
     *
     * @example
     * ```ts
     * const example: Plugin = {
     *   execute: {
     * 		example: {
     * 		  async request(event, run) {
     * 				const httpRequest = {
     * 				  type: 'http-request',
     * 				  payload: { ... }
     * 				}
     *
     * 				for await (const subevent of run.execute(httpRequest)) {
     * 				  if (subevent.type === 'http:response') {
     * 					  run.enqueue({
     * 							type: 'example:response',
     * 							payload: { ... }
     * 						});
     * 					}
     * 				}
     * 			}
     * 		}
     * 	}
     * }
     * ```
     */
    execute<TSpecificItem extends BuiltInItem | InferItem<TAdditionalItem>>(item: TSpecificItem, context?: RunContext<TAdditionalItem, TSpecificItem>): Run<TAdditionalEvent, TAdditionalItem, TSpecificItem>;
    close(): void;
    /**
     * Clear enqueued events and notify plugins that the run has been cancelled
     * (note: it's up to plugins to perform cancellation as-needed)
     */
    cancel(): void;
    /**
     * Forcefully cancel run, clearing all queued events and disposing
     */
    abort(): Promise<void>;
    /**
     * Cancel and retry the run, clearing all queued events,
     * but allowing the current event to finish processing
     */
    retry(): Promise<void>;
    error(error: ErrorEvent | unknown): void;
    [Symbol.asyncIterator](): AsyncIterator<RuntimeEvent<InternalEvent | BuiltInEvent | TAdditionalEvent>>;
    values(options?: {
        preventCancel?: boolean;
    }): AsyncIterable<RuntimeEvent<InternalEvent | BuiltInEvent | TAdditionalEvent>>;
    /**
     * Add a Disposable / AsyncDisposable to be disposed when the run completes
     *
     * See [AsyncDisposableStack](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncDisposableStack) for context
     */
    using(disposable: MaybeDisposable): void;
    /**
     * Register a callback that is called and await when the stack is disposed.
     */
    defer(onDispose: () => MaybePromise<any>): void;
    /**
     * Keep the run open until at least the continuation is settled
     */
    waitUntil(continuation: Continuation): void;
    disposeAsync(): Promise<void>;
    [Symbol.asyncDispose](): Promise<void>;
}
export {};
