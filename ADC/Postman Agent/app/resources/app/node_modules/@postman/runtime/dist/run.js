"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Run = void 0;
const mutative_1 = require("mutative");
const events_js_1 = require("./events.js");
const auto_queue_js_1 = require("./lib/auto-queue.js");
const disposables_js_1 = require("./lib/disposables.js");
const event_loop_js_1 = require("./lib/event-loop.js");
const event_stream_js_1 = require("./lib/event-stream.js");
const promises_js_1 = require("./lib/promises.js");
const resources_js_1 = require("./lib/resources.js");
let index = 1;
/**
 * Interact with run's executing in Postman Runtime
 *
 * @example
 * ```ts
 * const runtime = new Runtime();
 * const run = runtime.execute({
 *   type: 'grpc-request',
 *   payload: { ... }
 * });
 *
 * // Enqueue events for the run to process
 * run.enqueue({ type: 'grpc:message', payload: { ... } });
 * run.enqueue({ type: 'grpc:message', payload: { ... } });
 * run.enqueue({ type: 'grpc:message', payload: { ... } });
 *
 * // Close run (stop accepting new events and process remaining)
 * run.close();
 *
 * // Cancel run (throwing out queued events)
 * run.cancel();
 *
 * // Stop run with error (throwing out queued events and emitting error)
 * run.error(new Error('Something went wrong'));
 *
 * // Subscribe to run
 * run.subscribe((event) => {
 *  console.log(event);
 * });
 *
 * // Iterate through run
 * for await (const event of run) {
 *   console.log(event);
 * }
 * ```
 *
 * Additionally, there are methods that are helpful for plugins:
 *
 * @example
 * ```ts
 * // Dispose of resources when the run is complete
 * run.using({
 *   [Symbol.dispose]() {
 *     // cleanup...
 *   }
 * });
 *
 * // Keep the run open until at least the given promise or continuation settles
 * run.waitUntil(async () => {
 *   // waiting...
 * });
 * ```
 */
class Run {
    #id = crypto.randomUUID();
    #runtime;
    #environment;
    #context;
    #processes;
    #disposables = new Set();
    #queue = new auto_queue_js_1.AutoQueue();
    #events = new event_stream_js_1.EventStream();
    #scopes = new Map();
    #complete = (0, promises_js_1.promiseWithResolvers)();
    #emitted = new WeakSet();
    #stopped = new Set();
    #rejected = new Map();
    #enqueued = new Map();
    get id() {
        return this.#id;
    }
    get runtime() {
        return this.#runtime;
    }
    get environment() {
        return this.#environment;
    }
    get item() {
        return this.context.item;
    }
    get context() {
        return this.#context;
    }
    get complete() {
        return this.#complete.promise;
    }
    constructor(runtime, item, context = {}, 
    /**
     * Process chain, from root-to-closest
     *
     * @internal
     */
    processes = []) {
        this.#runtime = runtime;
        this.#environment = runtime.prepareEnvironment();
        this.#context = {
            ...context,
            item: item ?
                {
                    ...item,
                    id: item.id ?? crypto.randomUUID(),
                }
                : undefined,
        };
        this.#processes = processes;
        for (const plugin of this.#environment.plugins) {
            this.#scopes.set(plugin, scopedRun(this, plugin));
            this.using(plugin);
        }
        for (const subscription of this.#environment.subscriptions) {
            this.subscribe(subscription);
        }
        // Store emitted events (weakly) to track how patches should be applied
        this.subscribe((event) => {
            this.#emitted.add(event);
        });
        this.waitUntil(async () => {
            // Wait to start work until the next microtask to allow event handlers to register
            await (0, event_loop_js_1.nextMicrotask)();
            try {
                // Handle item and enqueue events
                await this.#execute();
                // Kick off event processing
                this.#process();
            }
            catch (error) {
                this.error(error);
            }
        });
    }
    /**
     * Add an event to the queue to be processed.
     * Returns a promise that resolves when the event has been processed
     * or rejects with the error that occurred during processing.
     */
    enqueue(event) {
        const runtimeEvent = this.toRuntimeEvent(event);
        const enqueued = (0, promises_js_1.promiseWithResolvers)();
        enqueued.promise.catch((_error) => {
            // (explicitly catch and ignore error to avoid unhandled exception)
        });
        this.#enqueued.set(runtimeEvent.id, enqueued);
        this.#queue.enqueue(runtimeEvent);
        return enqueued.promise;
    }
    /**
     * Emit the given event immediately (without processing)
     */
    emit(event) {
        this.#events.emit(this.toRuntimeEvent(event));
    }
    /**
     * Subscribe to all events processed or emitted
     */
    subscribe(handler, options) {
        const unsubscribe = this.#events.subscribe(handler, options);
        // Unsubscribe automatically once the run is disposed
        // (shouldn't technically be necessary, but just to be safe)
        this.using(unsubscribe);
        return unsubscribe;
    }
    /**
     * Convert the given event to a RuntimeEvent
     *
     * @internal
     */
    toRuntimeEvent(event) {
        if ((0, events_js_1.isRuntimeEvent)(event))
            return event;
        return {
            ...event,
            id: 'id' in event ? String(event.id) : crypto.randomUUID(),
            context: {
                timestamp: new Date().toISOString(),
                source: activeScope.get(this)?.name ?? 'external',
                item: this.item ? (0, resources_js_1.link)(this.item) : null,
                collection: this.context.collection ? (0, resources_js_1.link)(this.context.collection) : null,
                folders: this.context.folders?.map(resources_js_1.link) ?? [],
                workspace: this.context.workspace ? (0, resources_js_1.link)(this.context.workspace) : null,
                environment: this.context.environment ? (0, resources_js_1.link)(this.context.environment) : null,
                run: (0, resources_js_1.link)({
                    type: 'run:execute',
                    id: this.#processes[0]?.id ?? this.id,
                }),
                process: [...this.#processes, this].map((run) => (0, resources_js_1.link)({ type: 'run:execute', id: run.id })),
            },
        };
    }
    patch(eventOrMutate, maybeMutate) {
        // Active scope is set synchronously, but is lost when this function awaits.
        // Store it here and then set after await has resolved
        // (so that emit contains originating scope)
        const scope = activeScope.get(this);
        if (typeof eventOrMutate === 'function') {
            // Mutating run context
            // (explicitly pick non-async, mutative has no ts override that is async + non-async)
            const mutate = eventOrMutate;
            const result = (0, mutative_1.create)(this.#context, (draft) => mutate(draft), {
                enablePatches: true,
            });
            const patchedRun = (result) => {
                const [nextContext, patches] = result;
                if (!patches.length)
                    return;
                this.#context = nextContext;
                runWithScope(this, scope, () => {
                    this.emit({
                        type: 'run:patch',
                        payload: {
                            link: `run:execute#${this.#id}`,
                            patches,
                        },
                    });
                });
            };
            if (Array.isArray(result)) {
                return patchedRun(result);
            }
            else {
                return result.then((value) => patchedRun(value));
            }
        }
        // Mutating event payload
        // (explicitly pick non-async, mutative has no ts override that is async + non-async)
        const event = eventOrMutate;
        const mutate = maybeMutate;
        const result = (0, mutative_1.create)(event.payload, (draft) => mutate(draft), { enablePatches: true });
        const patchedEvent = (result) => {
            const [nextPayload, patches, inversePatches] = result;
            if (nextPayload === event.payload)
                return;
            event.payload = nextPayload;
            runWithScope(this, scope, () => {
                if (this.#emitted.has(event)) {
                    this.emit({
                        type: 'run:patch',
                        payload: {
                            link: (0, resources_js_1.link)(event),
                            patches,
                        },
                    });
                }
                else {
                    event.revisions = [
                        ...(event.revisions ?? []),
                        {
                            source: activeScope.get(this)?.name ?? 'external',
                            inversePatches,
                        },
                    ];
                }
            });
        };
        if (Array.isArray(result)) {
            return patchedEvent(result);
        }
        else {
            return result.then((value) => patchedEvent(value));
        }
    }
    /**
     * Process an event through the runtime pipeline (without emitting)
     *
     * @internal
     */
    async processEvent(event) {
        this.runtime.xray?.log?.(`# ${index++}. ${event.type}\n`);
        this.runtime.xray?.log?.('```js');
        this.runtime.xray?.log?.({ ...event, context: {} });
        this.runtime.xray?.log?.('```\n');
        for (const { plugin, phase, handler } of this.#environment.pipeline) {
            if (this.#stopped.has(event)) {
                this.runtime.xray?.log?.(`- [ ] ${plugin.name}: ${phase} (stopped)`);
                break;
            }
            const scope = this.#scopes.get(plugin);
            if (!scope) {
                throw new Error(`No scope found for plugin "${plugin.name}"`);
            }
            const start = this.runtime.xray ? performance.now() : undefined;
            await handler(event, scope);
            this.runtime.xray?.log?.(`- [x] ${plugin.name}: ${phase}${time(performance.now() - start)}`);
        }
        if (this.runtime.xray) {
            const queue = this.#queue.__postman_runtime_xray__;
            this.runtime.xray.log?.(`\n(queue: length = ${queue.length}, continuations = ${queue.continuations})`);
        }
        this.runtime.xray?.log?.('\n-----\n');
    }
    stopPropagation(event) {
        this.runtime.xray?.log?.(`**stopPropagation**\n`);
        this.rejectEvent(event, new DOMException('Event stopped', 'AbortError'));
    }
    /**
     * Reject event, stopping processing and propagation and rejecting enqueue call
     */
    rejectEvent(event, error) {
        this.#stopped.add(event);
        this.#rejected.set(event.id, error);
        this.#enqueued.get(event.id)?.reject(error);
    }
    //
    // #region Process
    //
    /**
     * Execute the given item in a child process of the current run
     *
     * @example
     * ```ts
     * const example: Plugin = {
     *   execute: {
     * 		example: {
     * 		  async request(event, run) {
     * 				const httpRequest = {
     * 				  type: 'http-request',
     * 				  payload: { ... }
     * 				}
     *
     * 				for await (const subevent of run.execute(httpRequest)) {
     * 				  if (subevent.type === 'http:response') {
     * 					  run.enqueue({
     * 							type: 'example:response',
     * 							payload: { ... }
     * 						});
     * 					}
     * 				}
     * 			}
     * 		}
     * 	}
     * }
     * ```
     */
    execute(item, context = {}) {
        // Transfer everything except for item/options since they are item-specific
        const transferrableContext = {
            ...this.context,
            item: undefined,
            options: undefined,
        };
        const subprocess = new Run(this.runtime, item, {
            ...transferrableContext,
            ...context,
        }, [...this.#processes, this]);
        // Forward all events for subprocess as effects (already been processed)
        subprocess.subscribe((event) => {
            this.emit(event);
        });
        // Don't close the parent run while the subprocess is running
        this.waitUntil(subprocess.complete);
        return subprocess;
    }
    #execute = async () => {
        if (!this.item)
            return;
        const supported = this.#environment.supported[this.item.type];
        if (!supported) {
            throw new Error(`Unsupported item type "${this.item.type}"`);
        }
        const scope = this.#scopes.get(supported.plugin);
        if (!scope) {
            throw new Error(`No scope found for plugin "${supported.plugin.name}"`);
        }
        // Handle the item with the registered plugin
        await supported.handler(this.item, scope);
    };
    #process = () => {
        (async () => {
            for await (const event of this.#queue) {
                const enqueuedEvent = this.#enqueued.get(event.id);
                try {
                    const processing = this.processEvent(event);
                    // Process event with runtime pipeline
                    // (keep queue open at least until process completes)
                    this.waitUntil(processing);
                    await processing;
                    // Processed, resolve enqueued event
                    enqueuedEvent?.resolve();
                    // If event has stopped propogation, resolve, but don't emit
                    if (this.#stopped.has(event)) {
                        continue;
                    }
                    // Emit event
                    this.#events.emit(event);
                }
                catch (error) {
                    // On unhandled error, reject event and run
                    enqueuedEvent?.reject(error);
                    throw error;
                }
                finally {
                    this.#enqueued.delete(event.id);
                }
            }
            await this.disposeAsync();
            this.#events.close();
            this.#complete.resolve();
        })().catch((error) => {
            this.error(error);
        });
    };
    //
    // #region Run:Lifecycle
    //
    close() {
        this.#queue.close();
    }
    /**
     * Clear enqueued events and notify plugins that the run has been cancelled
     * (note: it's up to plugins to perform cancellation as-needed)
     */
    cancel() {
        for (const { reject } of this.#enqueued.values()) {
            reject(new DOMException('Run cancelled', 'AbortError'));
        }
        this.#queue.empty();
        this.#enqueued.clear();
        this.emit({ type: 'run:cancel' });
    }
    /**
     * Forcefully cancel run, clearing all queued events and disposing
     */
    async abort() {
        this.cancel();
        this.#queue.cancel();
        await this.disposeAsync();
    }
    /**
     * Cancel and retry the run, clearing all queued events,
     * but allowing the current event to finish processing
     */
    async retry() {
        this.cancel();
        this.emit({ type: 'run:retry' });
        await this.#execute();
    }
    error(error) {
        this.runtime.xray?.log?.(`# ERROR\n`);
        this.runtime.xray?.log?.(error);
        this.runtime.xray?.log?.(`\n-----\n`);
        // Include error in emitted events for simpler tracking / aggregation
        if ((0, events_js_1.isErrorEvent)(error)) {
            this.emit(error);
        }
        else {
            this.emit({ type: 'run:error', payload: { error } });
        }
        // Throw error externally in event stream
        this.#events.error((0, events_js_1.isErrorEvent)(error) ? error.payload.error : error);
        (async () => {
            await this.abort();
        })()
            .catch((_error) => {
            // (ignore abort / dispose errors)
        })
            .finally(() => {
            // Complete is equivalent to settled, resolve on success or failure
            this.#complete.resolve();
        });
    }
    [Symbol.asyncIterator]() {
        return this.#events[Symbol.asyncIterator]();
    }
    values(options) {
        return this.#events.values(options);
    }
    //
    // #region Run:Lifetime
    //
    /**
     * Add a Disposable / AsyncDisposable to be disposed when the run completes
     *
     * See [AsyncDisposableStack](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncDisposableStack) for context
     */
    using(disposable) {
        this.#disposables.add(disposable);
    }
    /**
     * Register a callback that is called and await when the stack is disposed.
     */
    defer(onDispose) {
        this.#disposables.add({
            async [Symbol.asyncDispose]() {
                await onDispose();
            },
        });
    }
    /**
     * Keep the run open until at least the continuation is settled
     */
    waitUntil(continuation) {
        this.#queue.waitUntil(continuation);
    }
    async disposeAsync() {
        const disposing = [];
        for (const disposable of this.#disposables) {
            this.#disposables.delete(disposable);
            disposing.push((0, disposables_js_1.dispose)(disposable));
        }
        await Promise.allSettled(disposing);
    }
    async [Symbol.asyncDispose]() {
        await this.abort();
    }
}
exports.Run = Run;
//
// #region Scope
//
/**
 * To handle "source" for events, store scope when executing run methods
 *
 * Note: scope is only accurate during synchronous portion of execution,
 * need [Async Context](https://github.com/tc39/proposal-async-context) for async methods
 */
const activeScope = new WeakMap();
function runWithScope(run, scope, callback) {
    if (!scope) {
        return callback();
    }
    const previous = activeScope.get(run);
    activeScope.set(run, scope);
    const result = callback();
    if (previous) {
        activeScope.set(run, previous);
    }
    else {
        activeScope.delete(run);
    }
    return result;
}
function scopedRun(run, plugin) {
    return new Proxy(run, {
        get(target, prop) {
            const value = Reflect.get(target, prop, target);
            return typeof value === 'function' ?
                (...args) => {
                    const result = runWithScope(run, plugin, () => value.apply(target, args));
                    return result;
                }
                : value;
        },
        set(target, prop, value, receiver) {
            return Reflect.set(target, prop, value, receiver);
        },
    });
}
function time(ms) {
    return ms < 0.1 ? '' : ` (${ms.toFixed(3)}ms)`;
}
//# sourceMappingURL=run.js.map