import type { AnyEvent, BuiltInEvent, InternalEvent, RuntimeEvent } from './events.js';
import type { AnyItem, BuiltInItem } from './items.js';
import { type GRPCPlatform } from './items/grpc';
import { type HTTPPlatform } from './items/http';
import { type MCPPlatform } from './items/mcp';
import { type WebSocketPlatform } from './items/websocket';
import { EventSubscriber } from './lib/event-stream.js';
import type { FileSystemPlatform } from './lib/file-system/file-system.js';
import { type EventHandler } from './lib/match-event.js';
import type { NamespacedPlatform, Platform } from './lib/rpc/index.js';
import { PluginConstructor, type AnyItemWithOptions, type InferItem, type ItemHandler, type Plugin } from './plugin.js';
import { type ProxyPlatform } from './plugins/proxy';
import { Run, type RunContext } from './run.js';
/**
 * Phases of event processing.
 *
 * Phases are generally split into built-in behavior and user behavior:
 *
 * Built-in behavior:
 *
 * 1. prepare: Used to assign event defaults
 * 2. script: User scripting
 * 3. resolve: Variable resolution
 * 4. execute: Item execution
 *
 * User behavior:
 *
 * 1. prepared: Additional preparation work before scripting
 * 2. scripted: Scripting complete, perform work before variable resolution
 * 3. resolved: Variable resolution, perform work before execution
 * 4. (no executed step, can use `subscribe` instead)
 *
 * Plugins can add functionality on built-in phases, but those plugins will always run after built-in behavior.
 * (e.g. a custom resolve process will always run after built-in variable resolution, but before resolved phase)
 */
export declare const phases: readonly ["prepare", "prepared", "script", "scripted", "resolve", "resolved", "execute"];
export type Phase = (typeof phases)[number];
export interface RuntimeConfig<TAdditionalEvent extends AnyEvent = never, TAdditionalItem extends AnyItem | AnyItemWithOptions = never> {
    plugins?: Array<Plugin<TAdditionalEvent, TAdditionalItem> | PluginConstructor<TAdditionalEvent, TAdditionalItem>>;
    platform?: RuntimePlatform;
    /**
     * Disable built-in behavior
     *
     * @internal
     * @default true
     */
    builtins?: boolean;
    xray?: XRay;
}
/**
 * Combined platform configuration for all built-in items / extensions / plugins
 */
export interface RuntimePlatform extends NamespacedPlatform {
    http?: HTTPPlatform;
    mcp?: MCPPlatform;
    fs?: FileSystemPlatform;
    proxy?: ProxyPlatform;
    websocket?: WebSocketPlatform;
    grpc?: GRPCPlatform;
    [name: string]: Platform | undefined;
}
export interface RuntimeEnvironment<TAdditionalEvent extends AnyEvent = never, TAdditionalItem extends AnyItem | AnyItemWithOptions = never> {
    /**
     * List of all registered plugins (built-in and additional)
     */
    readonly plugins: Array<Plugin<TAdditionalEvent, TAdditionalItem>>;
    /**
     * Mapping of items supported by the registered plugins
     */
    readonly supported: {
        [Type in (BuiltInItem | InferItem<TAdditionalItem>)['type']]?: {
            plugin: Plugin<TAdditionalEvent, TAdditionalItem>;
            handler: ItemHandler<TAdditionalEvent, TAdditionalItem, Extract<BuiltInItem | InferItem<TAdditionalItem>, {
                type: Type;
            }>>;
        };
    } & Record<string, {
        plugin: Plugin<TAdditionalEvent, TAdditionalItem>;
        handler: ItemHandler<TAdditionalEvent, TAdditionalItem>;
    }>;
    /**
     * Processing pipeline of event handlers by plugin and phase
     */
    readonly pipeline: Array<{
        phase: Phase;
        plugin: Plugin<TAdditionalEvent, TAdditionalItem>;
        handler: EventHandler<RuntimeEvent<InternalEvent | BuiltInEvent | TAdditionalEvent>, [
            Run<TAdditionalEvent, TAdditionalItem>
        ], void | Promise<void>>;
    }>;
    /**
     * Plugin subscriptions to run events
     */
    readonly subscriptions: Array<EventSubscriber<RuntimeEvent<InternalEvent | BuiltInEvent | TAdditionalEvent>>>;
}
/**
 * Create new instance of the Postman Runtime
 *
 * @example
 * ```ts
 * const runtime = new Runtime();
 * const run = runtime.execute({
 *   type: 'collection',
 *   children: [...]
 * });
 *
 * for await (const event of run) {
 *   console.log(event);
 * }
 * ```
 */
export declare class Runtime<TAdditionalEvent extends AnyEvent = never, TAdditionalItem extends AnyItem | AnyItemWithOptions = never> {
    /**
     * List of all registered plugins or plugin classes (built-in and additional)
     */
    readonly plugins: Array<Plugin<TAdditionalEvent, TAdditionalItem> | PluginConstructor<TAdditionalEvent, TAdditionalItem>>;
    readonly platform?: RuntimePlatform;
    readonly xray: XRay | undefined;
    constructor(config?: RuntimeConfig<TAdditionalEvent, TAdditionalItem>);
    /**
     * Execute the given item with the given context
     *
     * @example
     * ```ts
     * const runtime = new Runtime();
     * const run = runtime.execute({
     *   type: 'graphql-request',
     *   payload: { ... }
     * }, {
     *   options: { operationName: 'getItems' },
     *   variables: [...]
     * });
     *
     * for await (const event of run) {
     *   console.log(event);
     * }
     * ```
     */
    execute<TSpecificItem extends BuiltInItem | InferItem<TAdditionalItem>>(item: TSpecificItem, context?: RunContext<TAdditionalItem, TSpecificItem>): Run<TAdditionalEvent, TAdditionalItem, TSpecificItem>;
    /**
     * Prepare a runtime environment for a run.
     * Since plugins can be instantiated per run for run-local scope,
     * need to be able to create an isolated environment per run.
     */
    prepareEnvironment(): RuntimeEnvironment<TAdditionalEvent, TAdditionalItem>;
}
export interface XRay {
    debug?: (...values: any[]) => void;
    log?: (...details: any[]) => void;
}
