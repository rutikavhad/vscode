"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Runtime = exports.phases = void 0;
const collection_1 = require("./items/collection");
const graphql_1 = require("./items/graphql");
const grpc_1 = require("./items/grpc");
const http_1 = require("./items/http");
const mcp_1 = require("./items/mcp");
const websocket_1 = require("./items/websocket");
const event_stream_js_1 = require("./lib/event-stream.js");
const match_event_js_1 = require("./lib/match-event.js");
const platform_js_1 = require("./platform.js");
const plugin_js_1 = require("./plugin.js");
const auth_1 = require("./plugins/auth");
const certificates_1 = require("./plugins/certificates");
const cookies_1 = require("./plugins/cookies");
const proxy_1 = require("./plugins/proxy");
const index_js_1 = require("./plugins/scripting/index.js");
const variables_1 = require("./plugins/variables");
const run_js_1 = require("./run.js");
/**
 * Phases of event processing.
 *
 * Phases are generally split into built-in behavior and user behavior:
 *
 * Built-in behavior:
 *
 * 1. prepare: Used to assign event defaults
 * 2. script: User scripting
 * 3. resolve: Variable resolution
 * 4. execute: Item execution
 *
 * User behavior:
 *
 * 1. prepared: Additional preparation work before scripting
 * 2. scripted: Scripting complete, perform work before variable resolution
 * 3. resolved: Variable resolution, perform work before execution
 * 4. (no executed step, can use `subscribe` instead)
 *
 * Plugins can add functionality on built-in phases, but those plugins will always run after built-in behavior.
 * (e.g. a custom resolve process will always run after built-in variable resolution, but before resolved phase)
 */
exports.phases = [
    'prepare',
    'prepared',
    'script',
    'scripted',
    'resolve',
    'resolved',
    'execute',
];
/**
 * Create new instance of the Postman Runtime
 *
 * @example
 * ```ts
 * const runtime = new Runtime();
 * const run = runtime.execute({
 *   type: 'collection',
 *   children: [...]
 * });
 *
 * for await (const event of run) {
 *   console.log(event);
 * }
 * ```
 */
class Runtime {
    /**
     * List of all registered plugins or plugin classes (built-in and additional)
     */
    plugins;
    platform;
    xray;
    constructor(config = {}) {
        this.xray = config.xray ?? globalThis.__postman_runtime_xray__;
        // Validate given plugins
        if (config.plugins) {
            for (const [index, plugin] of config.plugins.entries()) {
                if (!(0, plugin_js_1.isPlugin)(plugin) && typeof plugin !== 'function') {
                    throw new Error(`Invalid plugin at index ${index}`);
                }
            }
        }
        // (internal, allow built-ins plugins to be excluded)
        const builtins = (config.builtins === false ?
            []
            : [
                variables_1.variables,
                ...auth_1.auth,
                ...index_js_1.scripting,
                proxy_1.proxy,
                certificates_1.certificates,
                cookies_1.cookies,
                collection_1.collection,
                (0, http_1.http)({
                    platform: config.platform?.http,
                }),
                graphql_1.graphql,
                (0, mcp_1.mcp)({
                    platform: config.platform?.mcp,
                }),
                (0, websocket_1.websocket)({
                    platform: config.platform?.websocket,
                }),
                (0, grpc_1.grpc)({
                    platform: config.platform?.grpc,
                }),
            ]);
        this.plugins = [...builtins, ...(config.plugins ?? [])];
        this.platform = config.platform ?? platform_js_1.platform;
    }
    /**
     * Execute the given item with the given context
     *
     * @example
     * ```ts
     * const runtime = new Runtime();
     * const run = runtime.execute({
     *   type: 'graphql-request',
     *   payload: { ... }
     * }, {
     *   options: { operationName: 'getItems' },
     *   variables: [...]
     * });
     *
     * for await (const event of run) {
     *   console.log(event);
     * }
     * ```
     */
    execute(item, context = {}) {
        return new run_js_1.Run(this, item, context);
    }
    /**
     * Prepare a runtime environment for a run.
     * Since plugins can be instantiated per run for run-local scope,
     * need to be able to create an isolated environment per run.
     */
    prepareEnvironment() {
        const environment = {
            plugins: [],
            supported: {},
            pipeline: [],
            subscriptions: [],
        };
        for (const plugin of this.plugins) {
            environment.plugins.push(typeof plugin === 'function' ? new plugin() : plugin);
        }
        // Extract items from each plugin
        for (const plugin of environment.plugins) {
            for (const [type, handler] of Object.entries(plugin.items ?? {})) {
                if (environment.supported[type]) {
                    console.warn(`The "${plugin.name}" plugin is overwriting the item handler for type "${type}" that was previously registered by the "${environment.supported[type].plugin.name}" plugin`);
                }
                environment.supported[type] = { plugin, handler: handler.bind(plugin) };
            }
            if (plugin.subscribe) {
                environment.subscriptions.push((0, event_stream_js_1.isEventSubscriber)(plugin.subscribe) ?
                    plugin.subscribe
                    : { next: (0, match_event_js_1.matchEvent)(plugin.subscribe).bind(plugin) });
            }
        }
        // Extract events by phase from each plugin
        for (const phase of exports.phases) {
            for (const plugin of environment.plugins) {
                if (!plugin[phase])
                    continue;
                const handler = (0, match_event_js_1.matchEvent)(plugin[phase]).bind(plugin);
                environment.pipeline.push({ phase, plugin, handler });
            }
        }
        return environment;
    }
}
exports.Runtime = Runtime;
//# sourceMappingURL=runtime.js.map