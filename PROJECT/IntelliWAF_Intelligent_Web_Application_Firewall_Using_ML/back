# capture_simple.py
# Simple, easy-to-read mitmproxy addon that writes request captures to Data_captures.txt
from mitmproxy import http
from datetime import datetime
import os

OUTFILE = "Data_captures.txt"
MAX_BODY_CHARS = 200000  # truncate very large bodies for safety

def OP_File():
    """Ensure output file exists (create empty file on first run)."""
    if not os.path.exists(OUTFILE):
        open(OUTFILE, "w", encoding="utf-8").close()

def Plain_String(x):
    """
    Convert many mitmproxy objects to a readable Python string.
    - dict-like objects -> "k=v, k2=v2"
    - bytes -> decode utf-8 (fallback to [binary N bytes])
    - None -> "(none)"
    """
    if x is None:
        return "(none)"

    # mapping-like: headers, query etc.
    try:
        if hasattr(x, "items"):
            try:
                return ", ".join(f"{k}={v}" for k, v in x.items())
            except Exception:
                try:
                    return ", ".join(f"{k}={v}" for k, v in list(x))
                except Exception:
                    return str(x)

        # bytes -> try decode
        if isinstance(x, (bytes, bytearray)):
            try:
                return x.decode("utf-8", errors="replace")
            except Exception:
                return f"[binary {len(x)} bytes]"

        # fallback
        return str(x)
    except Exception:
        return repr(x)

def format_headers(h):
    """Return headers as multi-line string 'Name: value'."""
    try:
        return "\n".join(f"{k}: {v}" for k, v in h.items())
    except Exception:
        return Plain_String(h)

def request(flow: http.HTTPFlow) -> None:
    """
    mitmproxy calls this for each request.
    We capture basic metadata + headers + query + body and append to OUTFILE.
    """
    OP_File()
    req = flow.request

    parts = []
    parts.append("---- CAPTURE START ----")
    parts.append("timestamp: " + datetime.utcnow().isoformat() + "Z")

    # client ip (may be unknown in some environments)
    try:
        client_addr = flow.client_conn.address
        client_ip = f"{client_addr[0]}:{client_addr[1]}" if client_addr else "(unknown)"
    except Exception:
        client_ip = "(unknown)"
    parts.append(f"client_ip: {client_ip}")

    # basic request meta
    parts.append(f"method: {Plain_String(req.method)}")
    parts.append(f"url: {Plain_String(req.pretty_url)}")
    parts.append(f"path: {Plain_String(req.path)}")

    # headers
    parts.append("---- HEADERS ----")
    parts.append(format_headers(req.headers))

    # query params
    parts.append("---- QUERY ----")
    parts.append(Plain_String(req.query))

    # body (text where possible, or binary indicator)
    parts.append("---- BODY ----")
    if req.content:
        try:
            text = req.get_text(strict=False)
            if len(text) > MAX_BODY_CHARS:
                text = text[:MAX_BODY_CHARS] + "\n...(truncated)\n"
            parts.append(text)
        except Exception:
            parts.append(Plain_String(req.content))
    else:
        parts.append("(empty)")

    # cache-related headers
    parts.append("---- CACHE-RELATED HEADERS ----")
    for hname in ("Cache-Control", "Pragma", "Expires", "If-Modified-Since", "If-None-Match"):
        val = req.headers.get(hname)
        parts.append(f"{hname}: {Plain_String(val)}")

    parts.append("---- CAPTURE END ----\n\n")

    # write to file (append)
    try:
        with open(OUTFILE, "a", encoding="utf-8") as f:
            f.write("\n".join(parts))
    except Exception as e:
        # keep addon alive if file write fails
        print("Failed to write capture:", e)
